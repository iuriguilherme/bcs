<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BioChemSim - Multi-Level Life Simulation</title>
    <link rel="stylesheet" href="assets/css/all.min.css">
    <style>
/* CSS Reset & Variables */
*,
*::before,
*::after {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

:root {
    /* Color Palette - Dark Theme */
    --bg-primary: #0a0a0f;
    --bg-secondary: #12121a;
    --bg-tertiary: #1a1a25;
    --bg-glass: rgba(255, 255, 255, 0.03);
    --bg-glass-hover: rgba(255, 255, 255, 0.06);

    --text-primary: #e8e8f0;
    --text-secondary: #9090a0;
    --text-muted: #606070;

    --accent-primary: #6366f1;
    --accent-secondary: #8b5cf6;
    --accent-glow: rgba(99, 102, 241, 0.3);

    --success: #10b981;
    --warning: #f59e0b;
    --danger: #ef4444;

    --border-subtle: rgba(255, 255, 255, 0.06);
    --border-glow: rgba(99, 102, 241, 0.4);

    /* Spacing */
    --space-xs: 4px;
    --space-sm: 8px;
    --space-md: 16px;
    --space-lg: 24px;
    --space-xl: 32px;

    /* Sizing */
    --header-height: 60px;
    --panel-width: 280px;
    --status-bar-height: 32px;

    /* Effects */
    --blur-sm: blur(8px);
    --blur-md: blur(16px);
    --shadow-glow: 0 0 20px var(--accent-glow);
    --transition-fast: 150ms ease;
    --transition-smooth: 300ms cubic-bezier(0.4, 0, 0.2, 1);
}

/* Base Styles */
html,
body {
    height: 100%;
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    background: var(--bg-primary);
    color: var(--text-primary);
    overflow: hidden;
}

#app {
    display: flex;
    flex-direction: column;
    height: 100vh;
}

/* Header */
.header {
    height: var(--header-height);
    background: var(--bg-glass);
    backdrop-filter: var(--blur-md);
    border-bottom: 1px solid var(--border-subtle);
    display: flex;
    align-items: center;
    padding: 0 var(--space-lg);
    gap: var(--space-xl);
    z-index: 100;
}

.logo {
    font-size: 1.4rem;
    font-weight: 700;
    background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    text-shadow: var(--shadow-glow);
}

.version-link {
    font-size: 0.75rem;
    font-weight: 500;
    color: var(--text-secondary);
    background: var(--bg-tertiary);
    padding: 2px 8px;
    border-radius: 12px;
    text-decoration: none;
    border: 1px solid var(--border-subtle);
    margin-left: var(--space-sm);
    transition: var(--transition-fast);
    -webkit-text-fill-color: var(--text-secondary);
}

.version-link:hover {
    color: var(--accent-primary);
    border-color: var(--accent-primary);
    -webkit-text-fill-color: var(--accent-primary);
}

.level-indicator {
    display: flex;
    align-items: center;
    gap: var(--space-md);
}

.level-label {
    color: var(--text-secondary);
    font-size: 0.875rem;
}

.level-buttons {
    display: flex;
    gap: var(--space-xs);
    background: var(--bg-tertiary);
    padding: var(--space-xs);
    border-radius: 12px;
    border: 1px solid var(--border-subtle);
}

.level-btn {
    width: 40px;
    height: 36px;
    border: none;
    background: transparent;
    border-radius: 8px;
    cursor: pointer;
    font-size: 1.1rem;
    transition: var(--transition-fast);
    opacity: 0.6;
}

.level-btn:hover {
    background: var(--bg-glass-hover);
    opacity: 0.9;
}

.level-btn.active {
    background: var(--accent-primary);
    opacity: 1;
    outline: 2px solid var(--accent-secondary);
    outline-offset: 1px;
}

.sim-controls {
    display: flex;
    align-items: center;
    gap: var(--space-md);
    margin-left: auto;
}

.control-btn {
    width: 44px;
    height: 36px;
    border: 1px solid var(--border-subtle);
    background: var(--bg-tertiary);
    border-radius: 8px;
    cursor: pointer;
    font-size: 1.1rem;
    transition: var(--transition-fast);
}

.control-btn:hover {
    background: var(--bg-glass-hover);
    border-color: var(--accent-primary);
}

.play-pause-btn {
    width: auto;
    padding: 0 var(--space-md);
    font-size: 0.9rem;
    min-width: 80px;
}

#speedSlider {
    width: 120px;
    height: 4px;
    -webkit-appearance: none;
    background: var(--bg-tertiary);
    border-radius: 2px;
    cursor: pointer;
}

#speedSlider::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 16px;
    height: 16px;
    background: var(--accent-primary);
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid var(--accent-secondary);
}

/* Main Content */
.main-content {
    flex: 1;
    display: flex;
    overflow: hidden;
}

/* Panels */
.panel {
    width: var(--panel-width);
    background: var(--bg-glass);
    backdrop-filter: var(--blur-sm);
    border: 1px solid var(--border-subtle);
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.left-panel {
    border-right: 1px solid var(--border-subtle);
}

.right-panel {
    border-left: 1px solid var(--border-subtle);
}

.panel-title {
    padding: var(--space-md);
    font-size: 0.875rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--text-secondary);
    border-bottom: 1px solid var(--border-subtle);
}

.tool-section {
    padding: var(--space-md);
    border-bottom: 1px solid var(--border-subtle);
}

.tool-section h3 {
    font-size: 0.75rem;
    color: var(--text-muted);
    margin-bottom: var(--space-sm);
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.atom-palette {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: var(--space-xs);
}

.atom-btn {
    aspect-ratio: 1;
    border: 2px solid var(--border-subtle);
    background: var(--bg-tertiary);
    border-radius: 8px;
    cursor: pointer;
    font-weight: 700;
    font-size: 0.875rem;
    transition: var(--transition-fast);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 2px;
}

.atom-btn:hover {
    transform: scale(1.05);
    border-color: var(--accent-primary);
}

.atom-btn.selected {
    border-color: var(--accent-primary);
    background: var(--accent-primary);
    color: white;
    outline: 2px solid var(--accent-secondary);
    outline-offset: 2px;
}

.atom-btn .symbol {
    font-size: 1rem;
}

.atom-btn .number {
    font-size: 0.6rem;
    color: var(--text-muted);
}

.tool-btn {
    width: 100%;
    padding: var(--space-sm) var(--space-md);
    margin-bottom: var(--space-xs);
    border: 1px solid var(--border-subtle);
    background: var(--bg-tertiary);
    border-radius: 8px;
    cursor: pointer;
    color: var(--text-primary);
    font-size: 0.875rem;
    text-align: left;
    transition: var(--transition-fast);
}

.tool-btn:hover {
    background: var(--bg-glass-hover);
    border-color: var(--accent-primary);
}

.tool-btn.active {
    background: var(--accent-primary);
    border-color: var(--accent-primary);
}

/* Canvas */
.canvas-container {
    flex: 1;
    position: relative;
    background: radial-gradient(ellipse at center, var(--bg-secondary) 0%, var(--bg-primary) 100%);
    overflow: hidden;
}

#simCanvas {
    width: 100%;
    height: 100%;
    display: block;
}

.canvas-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
}

.info-popup {
    position: absolute;
    background: var(--bg-glass);
    backdrop-filter: var(--blur-md);
    border: 1px solid var(--border-subtle);
    border-radius: 12px;
    padding: var(--space-md);
    min-width: 180px;
    pointer-events: auto;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
}

/* Right Panel Tabs */
.panel-tabs {
    display: flex;
    border-bottom: 1px solid var(--border-subtle);
}

.tab-btn {
    flex: 1;
    padding: var(--space-md);
    border: none;
    background: transparent;
    color: var(--text-secondary);
    font-size: 0.875rem;
    cursor: pointer;
    transition: var(--transition-fast);
    border-bottom: 2px solid transparent;
}

.tab-btn:hover {
    color: var(--text-primary);
    background: var(--bg-glass-hover);
}

.tab-btn.active {
    color: var(--accent-primary);
    border-bottom-color: var(--accent-primary);
}

.tab-content {
    display: none;
    flex: 1;
    overflow-y: auto;
    padding: var(--space-md);
}

.tab-content.active {
    display: block;
}

.search-box {
    margin-bottom: var(--space-md);
}

.search-box input {
    width: 100%;
    padding: var(--space-sm) var(--space-md);
    border: 1px solid var(--border-subtle);
    background: var(--bg-tertiary);
    border-radius: 8px;
    color: var(--text-primary);
    font-size: 0.875rem;
}

.search-box input::placeholder {
    color: var(--text-muted);
}

.search-box input:focus {
    outline: none;
    border-color: var(--accent-primary);
}

.empty-state {
    color: var(--text-muted);
    font-size: 0.875rem;
    text-align: center;
    padding: var(--space-xl);
}

.catalogue-list {
    display: flex;
    flex-direction: column;
    gap: var(--space-sm);
}

.catalogue-item {
    padding: var(--space-sm) var(--space-md);
    background: var(--bg-tertiary);
    border: 1px solid var(--border-subtle);
    border-radius: 8px;
    cursor: pointer;
    transition: var(--transition-fast);
}

.catalogue-item:hover {
    border-color: var(--accent-primary);
    transform: translateX(4px);
}

/* Status Bar */
.status-bar {
    height: var(--status-bar-height);
    background: var(--bg-glass);
    backdrop-filter: var(--blur-sm);
    border-top: 1px solid var(--border-subtle);
    display: flex;
    align-items: center;
    padding: 0 var(--space-lg);
    gap: var(--space-xl);
    font-size: 0.75rem;
    color: var(--text-secondary);
}

.status-bar span {
    display: flex;
    align-items: center;
    gap: var(--space-xs);
}

/* Scrollbar */
::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

::-webkit-scrollbar-track {
    background: var(--bg-tertiary);
}

::-webkit-scrollbar-thumb {
    background: var(--text-muted);
    border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
    background: var(--text-secondary);
}

/* Accessibility: Focus States */
.atom-btn:focus-visible,
.palette-btn:focus-visible,
.atom-pool-btn:focus-visible,
.level-btn:focus-visible,
.tool-btn:focus-visible,
.control-btn:focus-visible,
.tab-btn:focus-visible,
.catalogue-item:focus-visible {
    outline: 2px solid var(--accent-primary);
    outline-offset: 2px;
}

/* Reduced motion preference */
@media (prefers-reduced-motion: reduce) {

    *,
    *::before,
    *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
    }
}

/* Animations */
@keyframes pulse {

    0%,
    100% {
        opacity: 1;
    }

    50% {
        opacity: 0.6;
    }
}

@keyframes glow {

    0%,
    100% {
        box-shadow: 0 0 5px var(--accent-glow);
    }

    50% {
        box-shadow: 0 0 20px var(--accent-glow);
    }
}

.pulsing {
    animation: pulse 1.5s ease-in-out infinite;
}

/* Entity Palette (level-aware) */
.palette-section {
    flex: 1;
    overflow-y: auto;
    padding: var(--space-md);
}

.palette-title {
    font-size: 0.75rem;
    color: var(--text-muted);
    margin-bottom: var(--space-sm);
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.entity-palette {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: var(--space-xs);
}

.palette-btn {
    padding: var(--space-sm);
    border: 2px solid var(--border-subtle);
    background: var(--bg-tertiary);
    border-radius: 8px;
    cursor: pointer;
    font-weight: 600;
    font-size: 0.8rem;
    transition: var(--transition-fast);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 2px;
    color: var(--text-primary);
    min-height: 50px;
}

.palette-btn:hover {
    transform: scale(1.02);
    border-color: var(--accent-primary);
}

.palette-btn.selected {
    border-color: var(--accent-primary);
    background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
    color: white;
    outline: 2px solid rgba(255, 255, 255, 0.3);
    outline-offset: 2px;
}

.palette-btn .symbol {
    font-size: 1rem;
}

.palette-btn .number,
.palette-btn .info {
    font-size: 0.6rem;
    color: var(--text-muted);
    font-weight: 400;
}

.palette-btn .formula {
    font-size: 0.75rem;
}

.palette-btn .type {
    font-size: 0.7rem;
    font-weight: 600;
}

.molecule-btn,
.polymer-btn {
    grid-column: span 2;
}

.cell-btn {
    grid-column: span 4;
}

.palette-hint {
    grid-column: span 4;
    color: var(--text-muted);
    font-size: 0.75rem;
    text-align: center;
    padding: var(--space-sm);
}

.palette-subtitle {
    grid-column: span 4;
    color: var(--text-secondary);
    font-size: 0.7rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-top: var(--space-sm);
    margin-bottom: var(--space-xs);
    padding-left: var(--space-xs);
    border-left: 2px solid var(--accent-primary);
}

.polymer-template-btn,
.polymer-existing-btn {
    grid-column: span 2;
}

.polymer-template-btn .type,
.polymer-existing-btn .type {
    font-size: 0.7rem;
    font-weight: 600;
}

.polymer-template-btn .info,
.polymer-existing-btn .info {
    font-size: 0.6rem;
    color: var(--text-muted);
}

/* Spawner Button */
.spawner-btn {
    position: relative;
}

.spawner-btn.active {
    background: var(--success);
    border-color: var(--success);
    color: white;
    outline: 2px solid rgba(255, 255, 255, 0.4);
    outline-offset: 2px;
}

/* Modal Styles */
.modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: center;
}

.modal-backdrop {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.7);
    backdrop-filter: var(--blur-sm);
}

.modal-content {
    position: relative;
    background: var(--bg-secondary);
    border: 1px solid var(--border-subtle);
    border-radius: 16px;
    width: 90%;
    max-width: 420px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    z-index: 1;
}

.modal-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: var(--space-lg);
    border-bottom: 1px solid var(--border-subtle);
}

.modal-header h3 {
    font-size: 1.1rem;
    font-weight: 600;
    color: var(--text-primary);
}

.modal-close {
    background: transparent;
    border: none;
    color: var(--text-secondary);
    font-size: 1.5rem;
    cursor: pointer;
    padding: 0;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 8px;
    transition: var(--transition-fast);
}

.modal-close:hover {
    background: var(--bg-glass-hover);
    color: var(--text-primary);
}

.modal-body {
    padding: var(--space-lg);
}

.modal-footer {
    padding: var(--space-md) var(--space-lg);
    border-top: 1px solid var(--border-subtle);
    display: flex;
    justify-content: flex-end;
    gap: var(--space-sm);
}

.form-group {
    margin-bottom: var(--space-lg);
}

.form-group:last-child {
    margin-bottom: 0;
}

.form-group label {
    display: block;
    font-size: 0.875rem;
    font-weight: 500;
    color: var(--text-secondary);
    margin-bottom: var(--space-sm);
}

.form-group input[type="number"] {
    width: 100px;
    padding: var(--space-sm) var(--space-md);
    border: 1px solid var(--border-subtle);
    background: var(--bg-tertiary);
    border-radius: 8px;
    color: var(--text-primary);
    font-size: 0.875rem;
}

.form-group input[type="number"]:focus {
    outline: none;
    border-color: var(--accent-primary);
}

.form-hint {
    display: block;
    font-size: 0.75rem;
    color: var(--text-muted);
    margin-top: var(--space-xs);
}

.zone-size-inputs {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    color: var(--text-secondary);
}

.atom-pool-selector {
    display: grid;
    grid-template-columns: repeat(6, 1fr);
    gap: var(--space-xs);
    margin-top: var(--space-sm);
}

.atom-pool-btn {
    aspect-ratio: 1;
    border: 2px solid var(--border-subtle);
    background: var(--bg-tertiary);
    border-radius: 8px;
    cursor: pointer;
    font-weight: 700;
    font-size: 0.875rem;
    transition: var(--transition-fast);
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0.5;
}

.atom-pool-btn:hover {
    opacity: 0.8;
}

.atom-pool-btn.selected {
    opacity: 1;
    border-color: var(--success);
    background: var(--success);
    color: white;
    outline: 2px solid rgba(255, 255, 255, 0.4);
    outline-offset: 1px;
}

.btn-primary {
    padding: var(--space-sm) var(--space-lg);
    background: var(--accent-primary);
    border: none;
    border-radius: 8px;
    color: white;
    font-size: 0.875rem;
    font-weight: 500;
    cursor: pointer;
    transition: var(--transition-fast);
}

.btn-primary:hover {
    background: var(--accent-secondary);
}

/* ========================================
   Tutorial System Styles
   ======================================== */

/* Tutorial Button in Header */
.tutorial-btn-header {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    font-size: 1rem;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
}

.tutorial-btn-header.active {
    background: var(--accent-primary);
    border-color: var(--accent-primary);
}

/* Tutorial Hint - First Visit Prompt */
.tutorial-hint {
    position: fixed;
    bottom: 80px;
    right: 24px;
    background: var(--bg-secondary);
    border: 1px solid var(--accent-primary);
    border-radius: 12px;
    padding: var(--space-md) var(--space-lg);
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), 0 0 20px var(--accent-glow);
    z-index: 900;
    max-width: 280px;
    opacity: 0;
    transform: translateY(20px);
    pointer-events: none;
    transition: opacity 0.3s ease, transform 0.3s ease;
}

.tutorial-hint.visible {
    opacity: 1;
    transform: translateY(0);
    pointer-events: auto;
}

.tutorial-hint-content {
    display: flex;
    align-items: flex-start;
    gap: var(--space-md);
}

.tutorial-hint-icon {
    font-size: 1.5rem;
    flex-shrink: 0;
}

.tutorial-hint-text {
    flex: 1;
}

.tutorial-hint-text h4 {
    font-size: 0.9rem;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: var(--space-xs);
}

.tutorial-hint-text p {
    font-size: 0.8rem;
    color: var(--text-secondary);
    margin-bottom: var(--space-sm);
    line-height: 1.4;
}

.tutorial-hint-actions {
    display: flex;
    gap: var(--space-sm);
    margin-top: var(--space-sm);
}

.tutorial-hint-start {
    padding: var(--space-xs) var(--space-md);
    background: var(--accent-primary);
    border: none;
    border-radius: 6px;
    color: white;
    font-size: 0.8rem;
    font-weight: 500;
    cursor: pointer;
    transition: var(--transition-fast);
}

.tutorial-hint-start:hover {
    background: var(--accent-secondary);
}

.tutorial-hint-dismiss {
    padding: var(--space-xs) var(--space-sm);
    background: transparent;
    border: 1px solid var(--border-subtle);
    border-radius: 6px;
    color: var(--text-secondary);
    font-size: 0.8rem;
    cursor: pointer;
    transition: var(--transition-fast);
}

.tutorial-hint-dismiss:hover {
    border-color: var(--text-secondary);
    color: var(--text-primary);
}

.tutorial-hint-arrow {
    position: absolute;
    bottom: -8px;
    right: 24px;
    width: 16px;
    height: 16px;
    background: var(--bg-secondary);
    border-right: 1px solid var(--accent-primary);
    border-bottom: 1px solid var(--accent-primary);
    transform: rotate(45deg);
}

/* Tutorial Overlay - NOT USED in non-blocking mode */
.tutorial-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.6);
    z-index: 950;
    backdrop-filter: blur(2px);
    display: none; /* Disabled for non-blocking tutorial */
}

/* Tutorial Highlight Box - Non-blocking, just visual indication */
.tutorial-highlight {
    position: fixed;
    border: 3px solid var(--accent-primary);
    border-radius: 12px;
    box-shadow: 0 0 30px var(--accent-glow), inset 0 0 20px var(--accent-glow);
    z-index: 960;
    pointer-events: none;
    animation: tutorial-pulse 2s ease-in-out infinite;
}

@keyframes tutorial-pulse {
    0%, 100% {
        box-shadow: 0 0 20px var(--accent-glow), inset 0 0 15px var(--accent-glow);
        border-color: var(--accent-primary);
    }
    50% {
        box-shadow: 0 0 40px var(--accent-glow), inset 0 0 25px var(--accent-glow);
        border-color: var(--accent-secondary);
    }
}

/* Tutorial Balloon */
.tutorial-balloon {
    position: fixed;
    background: var(--bg-secondary);
    border: 2px solid var(--accent-primary);
    border-radius: 16px;
    width: 340px;
    max-width: calc(100vw - 40px);
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6), 0 0 30px var(--accent-glow);
    z-index: 970;
    overflow: hidden;
}

.tutorial-balloon.position-center {
    top: 50% !important;
    left: 50% !important;
    transform: translate(-50%, -50%);
}

.tutorial-balloon-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: var(--space-sm) var(--space-md);
    background: var(--bg-tertiary);
    border-bottom: 1px solid var(--border-subtle);
}

.tutorial-step-indicator {
    font-size: 0.75rem;
    color: var(--text-muted);
    font-weight: 500;
}

.tutorial-close {
    background: transparent;
    border: none;
    color: var(--text-secondary);
    font-size: 1.3rem;
    cursor: pointer;
    padding: 0;
    width: 28px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 6px;
    transition: var(--transition-fast);
}

.tutorial-close:hover {
    background: var(--bg-glass-hover);
    color: var(--text-primary);
}

.tutorial-title {
    font-size: 1.1rem;
    font-weight: 600;
    color: var(--text-primary);
    padding: var(--space-md) var(--space-lg) var(--space-sm);
}

.tutorial-content {
    padding: 0 var(--space-lg) var(--space-md);
    font-size: 0.875rem;
    color: var(--text-secondary);
    line-height: 1.6;
    white-space: pre-line;
}

.tutorial-content strong {
    color: var(--accent-primary);
    font-weight: 600;
}

.tutorial-content em {
    color: var(--text-muted);
    font-style: italic;
}

.tutorial-nav {
    display: flex;
    justify-content: space-between;
    padding: var(--space-md) var(--space-lg);
    border-top: 1px solid var(--border-subtle);
    background: var(--bg-tertiary);
}

.tutorial-btn {
    padding: var(--space-sm) var(--space-md);
    background: var(--bg-glass);
    border: 1px solid var(--border-subtle);
    border-radius: 8px;
    color: var(--text-primary);
    font-size: 0.875rem;
    cursor: pointer;
    transition: var(--transition-fast);
    min-width: 80px;
}

.tutorial-btn:hover {
    background: var(--bg-glass-hover);
    border-color: var(--accent-primary);
}

.tutorial-btn.tutorial-next {
    background: var(--accent-primary);
    border-color: var(--accent-primary);
}

.tutorial-btn.tutorial-next:hover {
    background: var(--accent-secondary);
    border-color: var(--accent-secondary);
}
    </style>
</head>
<body>

    <div id="app">
        <!-- Header -->
        <header class="header">
            <h1 class="logo">üß¨ BioChemSim <a href="https://github.com/iuriguilherme/bcs/releases/tag/v0.19.0"
                    class="version-link" target="_blank">v0.19.0</a></h1>
            <div class="level-indicator">
                <span class="level-label">Level:</span>
                <div class="level-buttons" id="levelButtons">
                    <button class="level-btn active" data-level="0" title="Atoms">1</button>
                    <button class="level-btn" data-level="1" title="Molecules">2</button>
                    <button class="level-btn" data-level="2" title="Proteins">3</button>
                    <button class="level-btn" data-level="3" title="Cells">4</button>
                    <button class="level-btn" data-level="4" title="Organisms">5</button>
                    <button class="level-btn" data-level="5" title="Populations">6</button>
                </div>
            </div>
            <div class="sim-controls">
                <button id="playPauseBtn" class="control-btn play-pause-btn" title="Play/Pause">‚ñ∂Ô∏è Play</button>
                <button id="stepBtn" class="control-btn" title="Step">‚è≠Ô∏è</button>
                <button id="spawnerBtn" class="control-btn spawner-btn" title="Toggle Atom Spawner">‚öõÔ∏è</button>
                <input type="range" id="speedSlider" min="1" max="100" value="50" title="Simulation Speed">
                <button id="tutorialBtn" class="control-btn tutorial-btn-header" title="Tutorial">‚ùì</button>
            </div>
        </header>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Left Panel - Tools -->
            <aside class="panel left-panel">
                <h2 class="panel-title">Tools</h2>
                <div class="tool-section">
                    <h3>Actions</h3>
                    <button class="tool-btn" id="selectTool" data-tool="select">üîç Select</button>
                    <button class="tool-btn active" id="placeTool" data-tool="place">‚ûï Place</button>
                    <button class="tool-btn" id="deleteTool" data-tool="delete">üóëÔ∏è Delete</button>
                </div>
                <div class="tool-section">
                    <h3 id="paletteTitle">Place Atoms</h3>
                    <div class="atom-palette" id="entityPalette">
                        <!-- Populated by JS -->
                    </div>
                </div>
            </aside>

            <!-- Canvas Area -->
            <div class="canvas-container">
                <canvas id="simCanvas"></canvas>
                <div class="canvas-overlay" id="canvasOverlay">
                    <div class="info-popup" id="infoPopup" style="display: none;">
                        <div class="popup-content" id="popupContent"></div>
                    </div>
                </div>
            </div>

            <!-- Right Panel - Catalogue & Info -->
            <aside class="panel right-panel">
                <div class="panel-tabs">
                    <button class="tab-btn active" data-tab="catalogue">Catalogue</button>
                    <button class="tab-btn" data-tab="inspector">Inspector</button>
                </div>

                <div class="tab-content active" id="catalogueTab">
                    <div class="search-box">
                        <input type="text" id="catalogueSearch" placeholder="Search blueprints...">
                    </div>
                    <div class="catalogue-list" id="catalogueList">
                        <p class="empty-state">No blueprints yet. Create stable molecules to add them!</p>
                    </div>
                </div>

                <div class="tab-content" id="inspectorTab">
                    <div class="inspector-content" id="inspectorContent">
                        <p class="empty-state">Click on an entity to inspect it.</p>
                    </div>
                </div>
            </aside>
        </main>

        <!-- Status Bar -->
        <footer class="status-bar">
            <span id="atomCount">Atoms: 0</span>
            <span id="moleculeCount">Mol: 0</span>
            <span id="proteinCount">Prot: 0</span>
            <span id="cellCount">Cells: 0</span>
            <span id="tickCounter">Tick: 0</span>
            <span id="fpsCounter">FPS: 0</span>
        </footer>

        <!-- Spawner Configuration Modal -->
        <div id="spawnerModal" class="modal" style="display: none;">
            <div class="modal-backdrop"></div>
            <div class="modal-content">
                <div class="modal-header">
                    <h3>‚öõÔ∏è Atom Spawner Configuration</h3>
                    <button id="closeSpawnerModal" class="modal-close">&times;</button>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label for="spawnInterval">Ticks Between Spawns:</label>
                        <input type="number" id="spawnInterval" value="60" min="1" max="600">
                        <span class="form-hint">60 ticks ‚âà 1 second</span>
                    </div>
                    <div class="form-group">
                        <label>Atom Pool (select which atoms can spawn):</label>
                        <div class="atom-pool-selector" id="atomPoolSelector">
                            <!-- Populated by JS -->
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Spawn Zone Size:</label>
                        <div class="zone-size-inputs">
                            <input type="number" id="zoneWidth" value="400" min="50"> √ó
                            <input type="number" id="zoneHeight" value="400" min="50"> px
                        </div>
                        <span class="form-hint">Drag zone borders on canvas to resize visually</span>
                    </div>
                </div>
                <div class="modal-footer">
                    <button id="applySpawnerConfig" class="btn-primary">Apply</button>
                </div>
            </div>
        </div>

        <!-- Tutorial Hint (for first-time visitors) -->
        <div id="tutorialHint" class="tutorial-hint">
            <div class="tutorial-hint-content">
                <span class="tutorial-hint-icon">üß¨</span>
                <div class="tutorial-hint-text">
                    <h4>New to BioChemSim?</h4>
                    <p>Learn how to build molecules and explore chemistry!</p>
                    <div class="tutorial-hint-actions">
                        <button class="tutorial-hint-start" onclick="window.cellApp.tutorial.start()">Start Tutorial</button>
                        <button class="tutorial-hint-dismiss" onclick="document.getElementById('tutorialHint').classList.remove('visible')">Maybe Later</button>
                    </div>
                </div>
            </div>
            <div class="tutorial-hint-arrow"></div>
        </div>
    </div>

    <!-- Scripts (order matters) -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    <script>
// ============================================
// Bundled BioChemSim Scripts
// Version: v0.19.0
// Generated: 2026-01-20T21:17:29.134Z
// ============================================

// ==== src/core/utils.js ====
/**
 * Core Utilities
 * Helper functions used throughout the simulation
 */

/**
 * Debug System
 * Toggle verbose logging via console: Debug.enable() / Debug.disable()
 * Filter by molecule ID: Debug.watchMolecule('molecule-id')
 * Filter by formula: Debug.watchFormula('H2O')
 */
const Debug = {
    enabled: false,
    watchedMoleculeId: null,
    watchedFormula: null,
    categories: {
        reshape: true,
        bonds: true,
        molecules: true,
        sync: false,  // Very verbose, off by default
        decay: true,
        intentions: true
    },

    enable() {
        this.enabled = true;
        console.log('%c[Debug] Verbose logging ENABLED', 'color: #00ff00; font-weight: bold');
        console.log('  Debug.disable() - Turn off');
        console.log('  Debug.watchMolecule(id) - Filter by molecule ID');
        console.log('  Debug.watchFormula("H2O") - Filter by formula');
        console.log('  Debug.clearWatch() - Clear filters');
        console.log('  Debug.category("sync", true) - Enable/disable category');
    },

    disable() {
        this.enabled = false;
        console.log('%c[Debug] Verbose logging DISABLED', 'color: #ff6600; font-weight: bold');
    },

    watchMolecule(id) {
        this.watchedMoleculeId = id;
        this.enabled = true;
        console.log(`%c[Debug] Watching molecule: ${id}`, 'color: #00ffff; font-weight: bold');
    },

    watchFormula(formula) {
        this.watchedFormula = formula;
        this.enabled = true;
        console.log(`%c[Debug] Watching formula: ${formula}`, 'color: #00ffff; font-weight: bold');
    },

    clearWatch() {
        this.watchedMoleculeId = null;
        this.watchedFormula = null;
        console.log('%c[Debug] Watch filters cleared', 'color: #ffff00');
    },

    category(name, enabled) {
        if (this.categories.hasOwnProperty(name)) {
            this.categories[name] = enabled;
            console.log(`%c[Debug] Category '${name}' ${enabled ? 'ENABLED' : 'DISABLED'}`, 'color: #ffff00');
        } else {
            console.log(`Available categories: ${Object.keys(this.categories).join(', ')}`);
        }
    },

    /**
     * Check if we should log for this molecule
     */
    shouldLog(category, molecule = null) {
        if (!this.enabled) return false;
        if (!this.categories[category]) return false;
        
        // If watching specific molecule/formula, filter
        if (this.watchedMoleculeId && molecule) {
            if (molecule.id !== this.watchedMoleculeId) return false;
        }
        if (this.watchedFormula && molecule) {
            if (molecule.formula !== this.watchedFormula) return false;
        }
        return true;
    },

    /**
     * Log molecule-related message with rich context
     */
    logMolecule(category, action, molecule, extra = {}) {
        if (!this.shouldLog(category, molecule)) return;

        const id = molecule.id.substring(0, 8);  // Short ID
        const formula = molecule.formula || '?';
        const atomCount = molecule.atoms?.length || 0;
        const bondCount = molecule.bonds?.length || 0;
        // Don't call isStable() here - it would cause infinite recursion
        const reshaping = molecule.isReshaping ? 'RESHAPING' : '';
        const verified = molecule.geometryVerified ? 'VERIFIED' : '';

        let msg = `[${category.toUpperCase()}] ${action} | ${formula} (${id}) | atoms:${atomCount} bonds:${bondCount} | ${reshaping} ${verified}`;
        
        if (Object.keys(extra).length > 0) {
            msg += ` | ${JSON.stringify(extra)}`;
        }

        const color = {
            reshape: '#ff00ff',
            bonds: '#00ff00',
            molecules: '#00ffff',
            sync: '#888888',
            decay: '#ff6600',
            intentions: '#ffff00'
        }[category] || '#ffffff';

        console.log(`%c${msg}`, `color: ${color}`);
    },

    /**
     * Log bond-related message
     */
    logBond(action, bond, molecule = null, extra = {}) {
        if (!this.shouldLog('bonds', molecule)) return;

        const atom1 = `${bond.atom1?.symbol || '?'}(${bond.atom1?.id?.substring(0, 6) || '?'})`;
        const atom2 = `${bond.atom2?.symbol || '?'}(${bond.atom2?.id?.substring(0, 6) || '?'})`;
        const molId = molecule ? molecule.id.substring(0, 8) : 'none';

        let msg = `[BOND] ${action} | ${atom1} --${bond.order || 1}-- ${atom2} | mol:${molId}`;
        
        if (Object.keys(extra).length > 0) {
            msg += ` | ${JSON.stringify(extra)}`;
        }

        console.log(`%c${msg}`, 'color: #00ff00');
    },

    /**
     * Log state dump for a molecule (detailed)
     */
    dumpMolecule(molecule) {
        console.group(`%c[DUMP] Molecule ${molecule.formula} (${molecule.id})`, 'color: #ff00ff; font-weight: bold');
        console.log('ID:', molecule.id);
        console.log('Formula:', molecule.formula);
        console.log('Name:', molecule.name);
        console.log('Atoms:', molecule.atoms?.length, molecule.atoms?.map(a => `${a.symbol}(${a.id.substring(0,6)})`));
        console.log('Bonds:', molecule.bonds?.length, molecule.bonds?.map(b => `${b.atom1?.symbol}-${b.atom2?.symbol} o${b.order}`));
        console.log('isStable():', molecule.isStable?.());
        console.log('hasValidValence():', molecule.hasValidValence?.());
        console.log('isReshaping:', molecule.isReshaping);
        console.log('geometryVerified:', molecule.geometryVerified);
        console.log('reshapingTimer:', molecule.reshapingTimer);
        console.log('targetTemplate:', molecule.targetTemplate?.name);
        console.log('atomToTemplateIndex size:', molecule.atomToTemplateIndex?.size);
        console.log('Atom valences:', molecule.atoms?.map(a => `${a.symbol}: ${a.bondCount}/${a.maxBonds} (avail:${a.availableValence})`));
        console.groupEnd();
    }
};

// Make Debug available globally
window.Debug = Debug;

const Utils = {
    /**
     * Generate a unique ID
     */
    generateId() {
        return `${Date.now().toString(36)}-${Math.random().toString(36).substr(2, 9)}`;
    },

    /**
     * Calculate distance between two points
     */
    distance(x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        return Math.sqrt(dx * dx + dy * dy);
    },

    /**
     * Calculate distance squared (faster, no sqrt)
     */
    distanceSquared(x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        return dx * dx + dy * dy;
    },

    /**
     * Clamp a value between min and max
     */
    clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
    },

    /**
     * Linear interpolation
     */
    lerp(a, b, t) {
        return a + (b - a) * t;
    },

    /**
     * Random number in range
     */
    random(min, max) {
        return min + Math.random() * (max - min);
    },

    /**
     * Random integer in range (inclusive)
     */
    randomInt(min, max) {
        return Math.floor(min + Math.random() * (max - min + 1));
    },

    /**
     * Pick random element from array
     */
    randomChoice(array) {
        return array[Math.floor(Math.random() * array.length)];
    },

    /**
     * Shuffle array in place
     */
    shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    },

    /**
     * Convert HSL to RGB hex color
     */
    hslToHex(h, s, l) {
        s /= 100;
        l /= 100;
        const a = s * Math.min(l, 1 - l);
        const f = n => {
            const k = (n + h / 30) % 12;
            const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
            return Math.round(255 * color).toString(16).padStart(2, '0');
        };
        return `#${f(0)}${f(8)}${f(4)}`;
    },

    /**
     * Normalize a 2D vector
     */
    normalize(x, y) {
        const len = Math.sqrt(x * x + y * y);
        if (len === 0) return { x: 0, y: 0 };
        return { x: x / len, y: y / len };
    },

    /**
     * Calculate angle between two points
     */
    angle(x1, y1, x2, y2) {
        return Math.atan2(y2 - y1, x2 - x1);
    },

    /**
     * Deep clone an object
     */
    deepClone(obj) {
        return JSON.parse(JSON.stringify(obj));
    },

    /**
     * Debounce a function
     */
    debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    },

    /**
     * Format number with commas
     */
    formatNumber(num) {
        return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
    }
};

// Vector2 class for physics calculations
class Vector2 {
    constructor(x = 0, y = 0) {
        this.x = x;
        this.y = y;
    }

    add(v) {
        return new Vector2(this.x + v.x, this.y + v.y);
    }

    sub(v) {
        return new Vector2(this.x - v.x, this.y - v.y);
    }

    mul(scalar) {
        return new Vector2(this.x * scalar, this.y * scalar);
    }

    div(scalar) {
        if (scalar === 0) return new Vector2(0, 0);
        return new Vector2(this.x / scalar, this.y / scalar);
    }

    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }

    lengthSquared() {
        return this.x * this.x + this.y * this.y;
    }

    normalize() {
        const len = this.length();
        if (len === 0) return new Vector2(0, 0);
        return this.div(len);
    }

    dot(v) {
        return this.x * v.x + this.y * v.y;
    }

    distanceTo(v) {
        return this.sub(v).length();
    }

    clone() {
        return new Vector2(this.x, this.y);
    }

    set(x, y) {
        this.x = x;
        this.y = y;
        return this;
    }

    static fromAngle(angle, length = 1) {
        return new Vector2(
            Math.cos(angle) * length,
            Math.sin(angle) * length
        );
    }

    static random(minX, maxX, minY, maxY) {
        return new Vector2(
            Utils.random(minX, maxX),
            Utils.random(minY, maxY)
        );
    }
}

// Make available globally
window.Utils = Utils;
window.Vector2 = Vector2;


// ==== src/data/periodic-table.js ====
/**
 * Periodic Table Data
 * Extensible structure for all chemical elements
 * Currently includes essential elements for biochemistry
 * Can be expanded to full 118 elements without refactoring
 */

const ELEMENTS = {
    // Essential for organic chemistry / life
    H: {
        number: 1,
        symbol: 'H',
        name: 'Hydrogen',
        valence: 1,
        mass: 1.008,
        radius: 25,
        color: '#FFFFFF',
        category: 'nonmetal'
    },
    C: {
        number: 6,
        symbol: 'C',
        name: 'Carbon',
        valence: 4,
        mass: 12.011,
        radius: 35,
        color: '#333333',
        category: 'nonmetal'
    },
    N: {
        number: 7,
        symbol: 'N',
        name: 'Nitrogen',
        valence: 3,
        mass: 14.007,
        radius: 32,
        color: '#3050F8',
        category: 'nonmetal'
    },
    O: {
        number: 8,
        symbol: 'O',
        name: 'Oxygen',
        valence: 2,
        mass: 15.999,
        radius: 30,
        color: '#FF0D0D',
        category: 'nonmetal'
    },
    P: {
        number: 15,
        symbol: 'P',
        name: 'Phosphorus',
        valence: 5,
        mass: 30.974,
        radius: 38,
        color: '#FF8000',
        category: 'nonmetal'
    },
    S: {
        number: 16,
        symbol: 'S',
        name: 'Sulfur',
        valence: 2,  // Can also be 4 or 6, keeping simple
        mass: 32.065,
        radius: 36,
        color: '#FFFF30',
        category: 'nonmetal'
    },

    // Metals important for biology
    Na: {
        number: 11,
        symbol: 'Na',
        name: 'Sodium',
        valence: 1,
        mass: 22.990,
        radius: 40,
        color: '#AB5CF2',
        category: 'alkali-metal'
    },
    K: {
        number: 19,
        symbol: 'K',
        name: 'Potassium',
        valence: 1,
        mass: 39.098,
        radius: 45,
        color: '#8F40D4',
        category: 'alkali-metal'
    },
    Ca: {
        number: 20,
        symbol: 'Ca',
        name: 'Calcium',
        valence: 2,
        mass: 40.078,
        radius: 42,
        color: '#3DFF00',
        category: 'alkaline-earth'
    },
    Fe: {
        number: 26,
        symbol: 'Fe',
        name: 'Iron',
        valence: 2,  // Can also be 3
        mass: 55.845,
        radius: 38,
        color: '#E06633',
        category: 'transition-metal'
    },
    Mg: {
        number: 12,
        symbol: 'Mg',
        name: 'Magnesium',
        valence: 2,
        mass: 24.305,
        radius: 38,
        color: '#8AFF00',
        category: 'alkaline-earth'
    },
    Zn: {
        number: 30,
        symbol: 'Zn',
        name: 'Zinc',
        valence: 2,
        mass: 65.38,
        radius: 37,
        color: '#7D80B0',
        category: 'transition-metal'
    },

    // Halogens
    Cl: {
        number: 17,
        symbol: 'Cl',
        name: 'Chlorine',
        valence: 1,
        mass: 35.453,
        radius: 34,
        color: '#1FF01F',
        category: 'halogen'
    },

    // Noble gases (for future use)
    He: {
        number: 2,
        symbol: 'He',
        name: 'Helium',
        valence: 0,
        mass: 4.003,
        radius: 28,
        color: '#D9FFFF',
        category: 'noble-gas'
    }
};

// Bond energies (simplified, in arbitrary units)
// Higher = stronger bond
const BOND_ENERGIES = {
    'C-C': 83,
    'C=C': 146,
    'C‚â°C': 200,
    'C-H': 99,
    'C-O': 86,
    'C=O': 177,
    'C-N': 73,
    'C=N': 147,
    'C‚â°N': 213,
    'O-H': 111,
    'O-O': 35,
    'O=O': 119,
    'N-H': 93,
    'N-N': 39,
    'N=N': 100,
    'N‚â°N': 226,
    'P-O': 90,
    'S-H': 82,
    'S-S': 54,
    'DEFAULT': 60
};

// Electronegativity values (Pauling scale)
const ELECTRONEGATIVITY = {
    H: 2.20,
    C: 2.55,
    N: 3.04,
    O: 3.44,
    P: 2.19,
    S: 2.58,
    Na: 0.93,
    K: 0.82,
    Ca: 1.00,
    Fe: 1.83,
    Mg: 1.31,
    Zn: 1.65,
    Cl: 3.16,
    He: 0
};

// Common molecules templates (can be expanded)
const MOLECULE_TEMPLATES = {
    water: {
        formula: 'H2O',
        atoms: ['O', 'H', 'H'],
        bonds: [[0, 1], [0, 2]]
    },
    carbonDioxide: {
        formula: 'CO2',
        atoms: ['C', 'O', 'O'],
        bonds: [[0, 1, 2], [0, 2, 2]]  // double bonds
    },
    methane: {
        formula: 'CH4',
        atoms: ['C', 'H', 'H', 'H', 'H'],
        bonds: [[0, 1], [0, 2], [0, 3], [0, 4]]
    },
    ammonia: {
        formula: 'NH3',
        atoms: ['N', 'H', 'H', 'H'],
        bonds: [[0, 1], [0, 2], [0, 3]]
    },
    oxygen: {
        formula: 'O2',
        atoms: ['O', 'O'],
        bonds: [[0, 1, 2]]  // double bond
    }
};

/**
 * Get element data by symbol
 * @param {string} symbol - Element symbol (e.g., 'C', 'H', 'O')
 * @returns {object|null} Element data or null if not found
 */
function getElement(symbol) {
    return ELEMENTS[symbol] || null;
}

/**
 * Get bond energy between two elements
 * @param {string} symbol1 - First element symbol
 * @param {string} symbol2 - Second element symbol
 * @param {number} bondOrder - 1, 2, or 3 for single/double/triple
 * @returns {number} Bond energy
 */
function getBondEnergy(symbol1, symbol2, bondOrder = 1) {
    const bondSymbols = ['', '-', '=', '‚â°'];
    const key1 = `${symbol1}${bondSymbols[bondOrder]}${symbol2}`;
    const key2 = `${symbol2}${bondSymbols[bondOrder]}${symbol1}`;

    return BOND_ENERGIES[key1] || BOND_ENERGIES[key2] || BOND_ENERGIES.DEFAULT;
}

/**
 * Get all available element symbols
 * @returns {string[]} Array of element symbols
 */
function getAvailableElements() {
    return Object.keys(ELEMENTS);
}

/**
 * Get elements by category
 * @param {string} category - Element category
 * @returns {object[]} Array of elements in that category
 */
function getElementsByCategory(category) {
    return Object.values(ELEMENTS).filter(e => e.category === category);
}

// Make available globally
window.ELEMENTS = ELEMENTS;
window.BOND_ENERGIES = BOND_ENERGIES;
window.ELECTRONEGATIVITY = ELECTRONEGATIVITY;
window.MOLECULE_TEMPLATES = MOLECULE_TEMPLATES;
window.getElement = getElement;
window.getBondEnergy = getBondEnergy;
window.getAvailableElements = getAvailableElements;
window.getElementsByCategory = getElementsByCategory;


// ==== src/data/stable-molecules.js ====
/**
 * Stable Molecule Registry
 * Defines known stable molecules with their correct geometric configurations.
 * Used to reshape unstable molecules that match these formulas into their
 * natural stable forms.
 * 
 * ============================================================================
 * VALENCE CLOSURE REQUIREMENT
 * ============================================================================
 * 
 * All molecules in this registry MUST have fully closed valence - meaning
 * every atom must have its bonding capacity completely satisfied:
 * 
 *   Element | Valence | Must have exactly this many bonds
 *   --------|---------|----------------------------------
 *   H       |    1    | 1 bond
 *   C       |    4    | 4 bonds (single, double, triple combinations)
 *   N       |    3    | 3 bonds
 *   O       |    2    | 2 bonds
 *   S       |    2    | 2 bonds
 *   Cl      |    1    | 1 bond
 *   Na      |    1    | 1 bond
 *   K       |    1    | 1 bond
 *   Ca      |    2    | 2 bonds
 *   Fe      |  2 or 3 | 2 or 3 bonds
 * 
 * WHY NO OPEN VALENCE MOLECULES?
 * ------------------------------
 * 
 * 1. STABILITY DEFINITION: In this simulation, a molecule is "stable" when
 *    ALL atoms have availableValence === 0. This is the fundamental gate
 *    for molecule completion and cataloguing.
 * 
 * 2. RESHAPE LOOPS: Molecules with unsatisfied valence never become stable,
 *    causing infinite reshape attempts as the system tries to fix them.
 * 
 * 3. POLYMER FORMATION: The canPolymerize() check relies on isStable().
 *    Open-valence molecules would incorrectly try to form polymers.
 * 
 * 4. CHEMISTRY ACCURACY: Real radicals and ions (like OH‚Ä¢, H3O+, CO3¬≤‚Åª)
 *    are highly reactive intermediates, not stable end products. This
 *    simulation focuses on stable molecular species.
 * 
 * REMOVED MOLECULES (for reference):
 * - C3, C4, C5, C6, C8, C10, C12: End carbons have 2 bonds (need 4)
 * - C2O, C4O, C5O: End carbon has 3 bonds (need 4)
 * - C3O: End carbon has 2 bonds (need 4)
 * - CO3: Oxygen atoms have 1 bond each (need 2) - carbonate radical
 * - C2O3: End carbons have 2 bonds each (need 4)
 * - H3O: Oxygen has 3 bonds (max 2) - hydronium ion
 * 
 * ============================================================================
 */

const STABLE_MOLECULES = {
    'H2': {
        name: 'Hydrogen',
        formula: 'H2',
        atoms: [
            { symbol: 'H', relX: -15, relY: 0 },
            { symbol: 'H', relX: 15, relY: 0 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 }
        ],
        description: 'Diatomic hydrogen - single bond'
    },
    'O2': {
        name: 'Oxygen',
        formula: 'O2',
        atoms: [
            { symbol: 'O', relX: -20, relY: 0 },
            { symbol: 'O', relX: 20, relY: 0 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 2 }
        ],
        description: 'Diatomic oxygen - double bond'
    },
    'N2': {
        name: 'Nitrogen',
        formula: 'N2',
        atoms: [
            { symbol: 'N', relX: -18, relY: 0 },
            { symbol: 'N', relX: 18, relY: 0 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 3 }
        ],
        description: 'Diatomic nitrogen - triple bond'
    },
    'H2O': {
        name: 'Water',
        formula: 'H2O',
        atoms: [
            { symbol: 'O', relX: 0, relY: 0 },          // Central oxygen
            { symbol: 'H', relX: -24, relY: 19 },       // 104.5¬∞ bond angle
            { symbol: 'H', relX: 24, relY: 19 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },
            { atom1: 0, atom2: 2, order: 1 }
        ],
        description: 'Water - bent shape, 104.5¬∞ bond angle'
    },
    'CO2': {
        name: 'Carbon Dioxide',
        formula: 'CO2',
        atoms: [
            { symbol: 'C', relX: 0, relY: 0 },          // Central carbon
            { symbol: 'O', relX: -35, relY: 0 },        // Linear: 180¬∞
            { symbol: 'O', relX: 35, relY: 0 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 2 },           // Double bond
            { atom1: 0, atom2: 2, order: 2 }            // Double bond
        ],
        description: 'Carbon dioxide - linear, double bonds'
    },
    'CH4': {
        name: 'Methane',
        formula: 'CH4',
        atoms: [
            { symbol: 'C', relX: 0, relY: 0 },          // Central carbon
            { symbol: 'H', relX: 0, relY: -25 },        // Tetrahedral (2D projection)
            { symbol: 'H', relX: 23, relY: 12 },
            { symbol: 'H', relX: -23, relY: 12 },
            { symbol: 'H', relX: 0, relY: 25 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },
            { atom1: 0, atom2: 2, order: 1 },
            { atom1: 0, atom2: 3, order: 1 },
            { atom1: 0, atom2: 4, order: 1 }
        ],
        description: 'Methane - tetrahedral geometry'
    },
    'NH3': {
        name: 'Ammonia',
        formula: 'NH3',
        atoms: [
            { symbol: 'N', relX: 0, relY: 0 },          // Central nitrogen
            { symbol: 'H', relX: 0, relY: -22 },
            { symbol: 'H', relX: 19, relY: 11 },
            { symbol: 'H', relX: -19, relY: 11 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },
            { atom1: 0, atom2: 2, order: 1 },
            { atom1: 0, atom2: 3, order: 1 }
        ],
        description: 'Ammonia - trigonal pyramidal'
    },
    'HCl': {
        name: 'Hydrogen Chloride',
        formula: 'ClH',
        atoms: [
            { symbol: 'Cl', relX: -17, relY: 0 },
            { symbol: 'H', relX: 17, relY: 0 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 }
        ],
        description: 'Hydrogen chloride - polar covalent'
    },
    'CO': {
        name: 'Carbon Monoxide',
        formula: 'CO',
        atoms: [
            { symbol: 'C', relX: -15, relY: 0 },
            { symbol: 'O', relX: 15, relY: 0 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 3 }
        ],
        description: 'Carbon monoxide - triple bond'
    },
    'H2S': {
        name: 'Hydrogen Sulfide',
        formula: 'H2S',
        atoms: [
            { symbol: 'S', relX: 0, relY: 0 },          // Central sulfur
            { symbol: 'H', relX: -22, relY: 16 },       // ~92¬∞ bond angle
            { symbol: 'H', relX: 22, relY: 16 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },
            { atom1: 0, atom2: 2, order: 1 }
        ],
        description: 'Hydrogen sulfide - bent shape'
    },

    // ===== CARBON ALLOTROPES & CLUSTERS =====
    // NOTE: Most carbon allotropes (C3-C12) removed because they have unsatisfied valences.
    // Linear cumulenes have end carbons with only 2 bonds (need 4).
    // Cyclic rings with alternating double/single bonds give 3 bonds per carbon (need 4).
    // Only C2 with quadruple bond is kept.

    'C2': {
        name: 'Dicarbon',
        formula: 'C2',
        atoms: [
            { symbol: 'C', relX: -15, relY: 0 },
            { symbol: 'C', relX: 15, relY: 0 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 4 }  // Quadruple bond (or double based on model)
        ],
        description: 'Dicarbon - found in carbon vapor and comets'
    },

    // ===== CARBON-OXYGEN COMPOUNDS =====

    'C3O2': {
        name: 'Carbon Suboxide',
        formula: 'C3O2',
        atoms: [
            { symbol: 'O', relX: -45, relY: 0 },
            { symbol: 'C', relX: -22, relY: 0 },
            { symbol: 'C', relX: 0, relY: 0 },
            { symbol: 'C', relX: 22, relY: 0 },
            { symbol: 'O', relX: 45, relY: 0 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 2 },
            { atom1: 1, atom2: 2, order: 2 },
            { atom1: 2, atom2: 3, order: 2 },
            { atom1: 3, atom2: 4, order: 2 }
        ],
        description: 'Carbon suboxide - linear O=C=C=C=O'
    },
    // C2O, C4O, C5O removed - end carbon has only 3 bonds (needs 4)
    // CO3 removed - bottom oxygens have only 1 bond each (need 2) - it's a radical
    // C2O3 removed - end carbons have only 2 bonds each (needs 4)
    // C3O removed - end carbon has only 2 bonds (needs 4)
    'C2O2': {
        name: 'Ethylenedione',
        formula: 'C2O2',
        atoms: [
            { symbol: 'O', relX: -35, relY: 0 },
            { symbol: 'C', relX: -12, relY: 0 },
            { symbol: 'C', relX: 12, relY: 0 },
            { symbol: 'O', relX: 35, relY: 0 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 2 },
            { atom1: 1, atom2: 2, order: 2 },
            { atom1: 2, atom2: 3, order: 2 }
        ],
        description: 'Ethylenedione - O=C=C=O (glyoxal precursor)'
    },
    'C4O2': {
        name: 'Butatrienedione',
        formula: 'C4O2',
        atoms: [
            { symbol: 'O', relX: -50, relY: 0 },
            { symbol: 'C', relX: -28, relY: 0 },
            { symbol: 'C', relX: -9, relY: 0 },
            { symbol: 'C', relX: 9, relY: 0 },
            { symbol: 'C', relX: 28, relY: 0 },
            { symbol: 'O', relX: 50, relY: 0 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 2 },
            { atom1: 1, atom2: 2, order: 2 },
            { atom1: 2, atom2: 3, order: 2 },
            { atom1: 3, atom2: 4, order: 2 },
            { atom1: 4, atom2: 5, order: 2 }
        ],
        description: 'Butatrienedione - O=C=C=C=C=O'
    },
    'C5O2': {
        name: 'Pentatetraenedione',
        formula: 'C5O2',
        atoms: [
            { symbol: 'O', relX: -60, relY: 0 },
            { symbol: 'C', relX: -38, relY: 0 },
            { symbol: 'C', relX: -19, relY: 0 },
            { symbol: 'C', relX: 0, relY: 0 },
            { symbol: 'C', relX: 19, relY: 0 },
            { symbol: 'C', relX: 38, relY: 0 },
            { symbol: 'O', relX: 60, relY: 0 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 2 },
            { atom1: 1, atom2: 2, order: 2 },
            { atom1: 2, atom2: 3, order: 2 },
            { atom1: 3, atom2: 4, order: 2 },
            { atom1: 4, atom2: 5, order: 2 },
            { atom1: 5, atom2: 6, order: 2 }
        ],
        description: 'Pentatetraenedione - O=C=C=C=C=C=O'
    },

    // ===== NITROGEN COMPOUNDS =====
    // Note: N2 and NH3 are defined above in the basic molecules section

    'HCN': {
        name: 'Hydrogen Cyanide',
        formula: 'CHN',
        atoms: [
            { symbol: 'H', relX: -30, relY: 0 },
            { symbol: 'C', relX: 0, relY: 0 },
            { symbol: 'N', relX: 25, relY: 0 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },  // H-C single
            { atom1: 1, atom2: 2, order: 3 }   // C‚â°N triple
        ],
        description: 'Hydrogen cyanide - linear, triple bond C‚â°N'
    },
    // N2O removed - resonance structure doesn't fit simple valence model (middle N would have 4 bonds)
    'CH3N': {
        name: 'Methanimine',
        formula: 'CH3N',
        atoms: [
            { symbol: 'C', relX: -12, relY: 0 },
            { symbol: 'N', relX: 18, relY: 0 },
            { symbol: 'H', relX: -30, relY: -15 },
            { symbol: 'H', relX: -30, relY: 15 },
            { symbol: 'H', relX: 35, relY: 0 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 2 },  // C=N double
            { atom1: 0, atom2: 2, order: 1 },  // C-H
            { atom1: 0, atom2: 3, order: 1 },  // C-H
            { atom1: 1, atom2: 4, order: 1 }   // N-H
        ],
        description: 'Methanimine - simplest imine H2C=NH'
    },
    'CH5N': {
        name: 'Methylamine',
        formula: 'CH5N',
        atoms: [
            { symbol: 'C', relX: -15, relY: 0 },
            { symbol: 'N', relX: 20, relY: 0 },
            { symbol: 'H', relX: -35, relY: 0 },
            { symbol: 'H', relX: -25, relY: -20 },
            { symbol: 'H', relX: -25, relY: 20 },
            { symbol: 'H', relX: 35, relY: -15 },
            { symbol: 'H', relX: 35, relY: 15 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },  // C-N single
            { atom1: 0, atom2: 2, order: 1 },  // C-H
            { atom1: 0, atom2: 3, order: 1 },  // C-H
            { atom1: 0, atom2: 4, order: 1 },  // C-H
            { atom1: 1, atom2: 5, order: 1 },  // N-H
            { atom1: 1, atom2: 6, order: 1 }   // N-H
        ],
        description: 'Methylamine - simplest primary amine CH3-NH2'
    },
    'N2H4': {
        name: 'Hydrazine',
        formula: 'H4N2',
        atoms: [
            { symbol: 'N', relX: -15, relY: 0 },
            { symbol: 'N', relX: 15, relY: 0 },
            { symbol: 'H', relX: -30, relY: -15 },
            { symbol: 'H', relX: -30, relY: 15 },
            { symbol: 'H', relX: 30, relY: -15 },
            { symbol: 'H', relX: 30, relY: 15 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },  // N-N single
            { atom1: 0, atom2: 2, order: 1 },  // N-H
            { atom1: 0, atom2: 3, order: 1 },  // N-H
            { atom1: 1, atom2: 4, order: 1 },  // N-H
            { atom1: 1, atom2: 5, order: 1 }   // N-H
        ],
        description: 'Hydrazine - rocket fuel precursor H2N-NH2'
    },
    'CHNO': {
        name: 'Isocyanic Acid',
        formula: 'CHNO',
        atoms: [
            { symbol: 'H', relX: -40, relY: 0 },
            { symbol: 'N', relX: -15, relY: 0 },
            { symbol: 'C', relX: 10, relY: 0 },
            { symbol: 'O', relX: 35, relY: 0 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },  // H-N single
            { atom1: 1, atom2: 2, order: 2 },  // N=C double
            { atom1: 2, atom2: 3, order: 2 }   // C=O double
        ],
        description: 'Isocyanic acid - linear H-N=C=O'
    },
    'CH2N2': {
        name: 'Cyanamide',
        formula: 'CH2N2',
        atoms: [
            { symbol: 'N', relX: -25, relY: 0 },
            { symbol: 'C', relX: 0, relY: 0 },
            { symbol: 'N', relX: 25, relY: 0 },
            { symbol: 'H', relX: -40, relY: -15 },
            { symbol: 'H', relX: -40, relY: 15 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },  // N-C single
            { atom1: 1, atom2: 2, order: 3 },  // C‚â°N triple
            { atom1: 0, atom2: 3, order: 1 },  // N-H
            { atom1: 0, atom2: 4, order: 1 }   // N-H
        ],
        description: 'Cyanamide - H2N-C‚â°N, prebiotic molecule'
    },

    // ===== SIMPLE CARBOHYDRATES =====

    'CH2O': {
        name: 'Formaldehyde',
        formula: 'CH2O',
        atoms: [
            { symbol: 'C', relX: 0, relY: 0 },
            { symbol: 'O', relX: 25, relY: 0 },
            { symbol: 'H', relX: -15, relY: -18 },
            { symbol: 'H', relX: -15, relY: 18 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 2 },
            { atom1: 0, atom2: 2, order: 1 },
            { atom1: 0, atom2: 3, order: 1 }
        ],
        description: 'Formaldehyde - simplest aldehyde (H2C=O)'
    },
    'C2H4O2': {
        name: 'Glycolaldehyde',
        formula: 'C2H4O2',
        atoms: [
            { symbol: 'C', relX: -20, relY: 0 },        // CHO carbon
            { symbol: 'C', relX: 20, relY: 0 },         // CH2OH carbon
            { symbol: 'O', relX: -40, relY: 0 },        // Aldehyde O
            { symbol: 'O', relX: 40, relY: 10 },        // Hydroxyl O
            { symbol: 'H', relX: -20, relY: -22 },      // CHO hydrogen
            { symbol: 'H', relX: 20, relY: -22 },
            { symbol: 'H', relX: 20, relY: 22 },
            { symbol: 'H', relX: 55, relY: 15 }         // OH hydrogen
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },
            { atom1: 0, atom2: 2, order: 2 },
            { atom1: 1, atom2: 3, order: 1 },
            { atom1: 0, atom2: 4, order: 1 },
            { atom1: 1, atom2: 5, order: 1 },
            { atom1: 1, atom2: 6, order: 1 },
            { atom1: 3, atom2: 7, order: 1 }
        ],
        description: 'Glycolaldehyde - simplest sugar, found in space (HOCH2-CHO)'
    },
    'C3H6O3': {
        name: 'Glyceraldehyde',
        formula: 'C3H6O3',
        atoms: [
            { symbol: 'C', relX: -30, relY: 0 },        // CHO
            { symbol: 'C', relX: 0, relY: 0 },          // CHOH
            { symbol: 'C', relX: 30, relY: 0 },         // CH2OH
            { symbol: 'O', relX: -50, relY: 0 },        // Aldehyde O
            { symbol: 'O', relX: 0, relY: 25 },         // Middle OH
            { symbol: 'O', relX: 50, relY: 10 },        // Terminal OH
            { symbol: 'H', relX: -30, relY: -22 },
            { symbol: 'H', relX: 0, relY: -22 },
            { symbol: 'H', relX: 30, relY: -22 },
            { symbol: 'H', relX: 30, relY: 22 },
            { symbol: 'H', relX: 10, relY: 38 },
            { symbol: 'H', relX: 62, relY: 18 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },
            { atom1: 1, atom2: 2, order: 1 },
            { atom1: 0, atom2: 3, order: 2 },
            { atom1: 1, atom2: 4, order: 1 },
            { atom1: 2, atom2: 5, order: 1 },
            { atom1: 0, atom2: 6, order: 1 },
            { atom1: 1, atom2: 7, order: 1 },
            { atom1: 2, atom2: 8, order: 1 },
            { atom1: 2, atom2: 9, order: 1 },
            { atom1: 4, atom2: 10, order: 1 },
            { atom1: 5, atom2: 11, order: 1 }
        ],
        description: 'Glyceraldehyde - 3-carbon aldose sugar (triose)'
    },
    'C3H6O3k': {
        name: 'Dihydroxyacetone',
        formula: 'C3H6O3',
        atoms: [
            { symbol: 'C', relX: -30, relY: 0 },        // CH2OH
            { symbol: 'C', relX: 0, relY: 0 },          // C=O
            { symbol: 'C', relX: 30, relY: 0 },         // CH2OH
            { symbol: 'O', relX: 0, relY: -25 },        // Ketone O
            { symbol: 'O', relX: -50, relY: 10 },       // Left OH
            { symbol: 'O', relX: 50, relY: 10 },        // Right OH
            { symbol: 'H', relX: -30, relY: -22 },
            { symbol: 'H', relX: -30, relY: 22 },
            { symbol: 'H', relX: 30, relY: -22 },
            { symbol: 'H', relX: 30, relY: 22 },
            { symbol: 'H', relX: -62, relY: 18 },
            { symbol: 'H', relX: 62, relY: 18 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },
            { atom1: 1, atom2: 2, order: 1 },
            { atom1: 1, atom2: 3, order: 2 },
            { atom1: 0, atom2: 4, order: 1 },
            { atom1: 2, atom2: 5, order: 1 },
            { atom1: 0, atom2: 6, order: 1 },
            { atom1: 0, atom2: 7, order: 1 },
            { atom1: 2, atom2: 8, order: 1 },
            { atom1: 2, atom2: 9, order: 1 },
            { atom1: 4, atom2: 10, order: 1 },
            { atom1: 5, atom2: 11, order: 1 }
        ],
        description: 'Dihydroxyacetone - 3-carbon ketose sugar (triose)'
    },
    'C4H8O4': {
        name: 'Erythrose',
        formula: 'C4H8O4',
        atoms: [
            { symbol: 'C', relX: -45, relY: 0 },        // CHO
            { symbol: 'C', relX: -15, relY: 0 },        // CHOH
            { symbol: 'C', relX: 15, relY: 0 },         // CHOH
            { symbol: 'C', relX: 45, relY: 0 },         // CH2OH
            { symbol: 'O', relX: -65, relY: 0 },        // Aldehyde O
            { symbol: 'O', relX: -15, relY: 25 },       // OH
            { symbol: 'O', relX: 15, relY: 25 },        // OH
            { symbol: 'O', relX: 65, relY: 10 },        // Terminal OH
            { symbol: 'H', relX: -45, relY: -20 },
            { symbol: 'H', relX: -15, relY: -20 },
            { symbol: 'H', relX: 15, relY: -20 },
            { symbol: 'H', relX: 45, relY: -20 },
            { symbol: 'H', relX: 45, relY: 20 },
            { symbol: 'H', relX: -5, relY: 38 },
            { symbol: 'H', relX: 25, relY: 38 },
            { symbol: 'H', relX: 77, relY: 18 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },
            { atom1: 1, atom2: 2, order: 1 },
            { atom1: 2, atom2: 3, order: 1 },
            { atom1: 0, atom2: 4, order: 2 },
            { atom1: 1, atom2: 5, order: 1 },
            { atom1: 2, atom2: 6, order: 1 },
            { atom1: 3, atom2: 7, order: 1 },
            { atom1: 0, atom2: 8, order: 1 },
            { atom1: 1, atom2: 9, order: 1 },
            { atom1: 2, atom2: 10, order: 1 },
            { atom1: 3, atom2: 11, order: 1 },
            { atom1: 3, atom2: 12, order: 1 },
            { atom1: 5, atom2: 13, order: 1 },
            { atom1: 6, atom2: 14, order: 1 },
            { atom1: 7, atom2: 15, order: 1 }
        ],
        description: 'Erythrose - 4-carbon aldose sugar (tetrose)'
    },
    'C5H10O5': {
        name: 'Ribose',
        formula: 'C5H10O5',
        atoms: [
            { symbol: 'C', relX: -55, relY: 0 },        // CHO
            { symbol: 'C', relX: -28, relY: 0 },        // CHOH
            { symbol: 'C', relX: 0, relY: 0 },          // CHOH
            { symbol: 'C', relX: 28, relY: 0 },         // CHOH
            { symbol: 'C', relX: 55, relY: 0 },         // CH2OH
            { symbol: 'O', relX: -75, relY: 0 },        // Aldehyde O
            { symbol: 'O', relX: -28, relY: 25 },       // OH
            { symbol: 'O', relX: 0, relY: 25 },         // OH
            { symbol: 'O', relX: 28, relY: 25 },        // OH
            { symbol: 'O', relX: 75, relY: 10 },        // Terminal OH
            { symbol: 'H', relX: -55, relY: -20 },
            { symbol: 'H', relX: -28, relY: -20 },
            { symbol: 'H', relX: 0, relY: -20 },
            { symbol: 'H', relX: 28, relY: -20 },
            { symbol: 'H', relX: 55, relY: -20 },
            { symbol: 'H', relX: 55, relY: 20 },
            { symbol: 'H', relX: -18, relY: 38 },
            { symbol: 'H', relX: 10, relY: 38 },
            { symbol: 'H', relX: 38, relY: 38 },
            { symbol: 'H', relX: 87, relY: 18 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },
            { atom1: 1, atom2: 2, order: 1 },
            { atom1: 2, atom2: 3, order: 1 },
            { atom1: 3, atom2: 4, order: 1 },
            { atom1: 0, atom2: 5, order: 2 },
            { atom1: 1, atom2: 6, order: 1 },
            { atom1: 2, atom2: 7, order: 1 },
            { atom1: 3, atom2: 8, order: 1 },
            { atom1: 4, atom2: 9, order: 1 },
            { atom1: 0, atom2: 10, order: 1 },
            { atom1: 1, atom2: 11, order: 1 },
            { atom1: 2, atom2: 12, order: 1 },
            { atom1: 3, atom2: 13, order: 1 },
            { atom1: 4, atom2: 14, order: 1 },
            { atom1: 4, atom2: 15, order: 1 },
            { atom1: 6, atom2: 16, order: 1 },
            { atom1: 7, atom2: 17, order: 1 },
            { atom1: 8, atom2: 18, order: 1 },
            { atom1: 9, atom2: 19, order: 1 }
        ],
        description: 'Ribose - 5-carbon aldose sugar (pentose), RNA backbone'
    },
    'C5H10O5k': {
        name: 'Ribulose',
        formula: 'C5H10O5',
        atoms: [
            { symbol: 'C', relX: -55, relY: 0 },        // CH2OH
            { symbol: 'C', relX: -28, relY: 0 },        // C=O
            { symbol: 'C', relX: 0, relY: 0 },          // CHOH
            { symbol: 'C', relX: 28, relY: 0 },         // CHOH
            { symbol: 'C', relX: 55, relY: 0 },         // CH2OH
            { symbol: 'O', relX: -75, relY: 10 },       // Terminal OH
            { symbol: 'O', relX: -28, relY: -25 },      // Ketone O
            { symbol: 'O', relX: 0, relY: 25 },         // OH
            { symbol: 'O', relX: 28, relY: 25 },        // OH
            { symbol: 'O', relX: 75, relY: 10 },        // Terminal OH
            { symbol: 'H', relX: -55, relY: -20 },
            { symbol: 'H', relX: -55, relY: 20 },
            { symbol: 'H', relX: 0, relY: -20 },
            { symbol: 'H', relX: 28, relY: -20 },
            { symbol: 'H', relX: 55, relY: -20 },
            { symbol: 'H', relX: 55, relY: 20 },
            { symbol: 'H', relX: -87, relY: 18 },
            { symbol: 'H', relX: 10, relY: 38 },
            { symbol: 'H', relX: 38, relY: 38 },
            { symbol: 'H', relX: 87, relY: 18 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },
            { atom1: 1, atom2: 2, order: 1 },
            { atom1: 2, atom2: 3, order: 1 },
            { atom1: 3, atom2: 4, order: 1 },
            { atom1: 0, atom2: 5, order: 1 },
            { atom1: 1, atom2: 6, order: 2 },
            { atom1: 2, atom2: 7, order: 1 },
            { atom1: 3, atom2: 8, order: 1 },
            { atom1: 4, atom2: 9, order: 1 },
            { atom1: 0, atom2: 10, order: 1 },
            { atom1: 0, atom2: 11, order: 1 },
            { atom1: 2, atom2: 12, order: 1 },
            { atom1: 3, atom2: 13, order: 1 },
            { atom1: 4, atom2: 14, order: 1 },
            { atom1: 4, atom2: 15, order: 1 },
            { atom1: 5, atom2: 16, order: 1 },
            { atom1: 7, atom2: 17, order: 1 },
            { atom1: 8, atom2: 18, order: 1 },
            { atom1: 9, atom2: 19, order: 1 }
        ],
        description: 'Ribulose - 5-carbon ketose sugar (pentose), CO2 fixation'
    },
    'C6H12O6': {
        name: 'Glucose',
        formula: 'C6H12O6',
        atoms: [
            { symbol: 'C', relX: -70, relY: 0 },        // CHO
            { symbol: 'C', relX: -42, relY: 0 },        // CHOH
            { symbol: 'C', relX: -14, relY: 0 },        // CHOH
            { symbol: 'C', relX: 14, relY: 0 },         // CHOH
            { symbol: 'C', relX: 42, relY: 0 },         // CHOH
            { symbol: 'C', relX: 70, relY: 0 },         // CH2OH
            { symbol: 'O', relX: -90, relY: 0 },        // Aldehyde O
            { symbol: 'O', relX: -42, relY: 25 },       // OH
            { symbol: 'O', relX: -14, relY: 25 },       // OH
            { symbol: 'O', relX: 14, relY: 25 },        // OH
            { symbol: 'O', relX: 42, relY: 25 },        // OH
            { symbol: 'O', relX: 90, relY: 10 },        // Terminal OH
            { symbol: 'H', relX: -70, relY: -20 },
            { symbol: 'H', relX: -42, relY: -20 },
            { symbol: 'H', relX: -14, relY: -20 },
            { symbol: 'H', relX: 14, relY: -20 },
            { symbol: 'H', relX: 42, relY: -20 },
            { symbol: 'H', relX: 70, relY: -20 },
            { symbol: 'H', relX: 70, relY: 20 },
            { symbol: 'H', relX: -32, relY: 38 },
            { symbol: 'H', relX: -4, relY: 38 },
            { symbol: 'H', relX: 24, relY: 38 },
            { symbol: 'H', relX: 52, relY: 38 },
            { symbol: 'H', relX: 102, relY: 18 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },
            { atom1: 1, atom2: 2, order: 1 },
            { atom1: 2, atom2: 3, order: 1 },
            { atom1: 3, atom2: 4, order: 1 },
            { atom1: 4, atom2: 5, order: 1 },
            { atom1: 0, atom2: 6, order: 2 },
            { atom1: 1, atom2: 7, order: 1 },
            { atom1: 2, atom2: 8, order: 1 },
            { atom1: 3, atom2: 9, order: 1 },
            { atom1: 4, atom2: 10, order: 1 },
            { atom1: 5, atom2: 11, order: 1 },
            { atom1: 0, atom2: 12, order: 1 },
            { atom1: 1, atom2: 13, order: 1 },
            { atom1: 2, atom2: 14, order: 1 },
            { atom1: 3, atom2: 15, order: 1 },
            { atom1: 4, atom2: 16, order: 1 },
            { atom1: 5, atom2: 17, order: 1 },
            { atom1: 5, atom2: 18, order: 1 },
            { atom1: 7, atom2: 19, order: 1 },
            { atom1: 8, atom2: 20, order: 1 },
            { atom1: 9, atom2: 21, order: 1 },
            { atom1: 10, atom2: 22, order: 1 },
            { atom1: 11, atom2: 23, order: 1 }
        ],
        description: 'Glucose - 6-carbon aldose sugar (hexose), primary energy source'
    },
    'C6H12O6k': {
        name: 'Fructose',
        formula: 'C6H12O6',
        atoms: [
            { symbol: 'C', relX: -70, relY: 0 },        // CH2OH
            { symbol: 'C', relX: -42, relY: 0 },        // C=O
            { symbol: 'C', relX: -14, relY: 0 },        // CHOH
            { symbol: 'C', relX: 14, relY: 0 },         // CHOH
            { symbol: 'C', relX: 42, relY: 0 },         // CHOH
            { symbol: 'C', relX: 70, relY: 0 },         // CH2OH
            { symbol: 'O', relX: -90, relY: 10 },       // Terminal OH
            { symbol: 'O', relX: -42, relY: -25 },      // Ketone O
            { symbol: 'O', relX: -14, relY: 25 },       // OH
            { symbol: 'O', relX: 14, relY: 25 },        // OH
            { symbol: 'O', relX: 42, relY: 25 },        // OH
            { symbol: 'O', relX: 90, relY: 10 },        // Terminal OH
            { symbol: 'H', relX: -70, relY: -20 },
            { symbol: 'H', relX: -70, relY: 20 },
            { symbol: 'H', relX: -14, relY: -20 },
            { symbol: 'H', relX: 14, relY: -20 },
            { symbol: 'H', relX: 42, relY: -20 },
            { symbol: 'H', relX: 70, relY: -20 },
            { symbol: 'H', relX: 70, relY: 20 },
            { symbol: 'H', relX: -102, relY: 18 },
            { symbol: 'H', relX: -4, relY: 38 },
            { symbol: 'H', relX: 24, relY: 38 },
            { symbol: 'H', relX: 52, relY: 38 },
            { symbol: 'H', relX: 102, relY: 18 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },
            { atom1: 1, atom2: 2, order: 1 },
            { atom1: 2, atom2: 3, order: 1 },
            { atom1: 3, atom2: 4, order: 1 },
            { atom1: 4, atom2: 5, order: 1 },
            { atom1: 0, atom2: 6, order: 1 },
            { atom1: 1, atom2: 7, order: 2 },
            { atom1: 2, atom2: 8, order: 1 },
            { atom1: 3, atom2: 9, order: 1 },
            { atom1: 4, atom2: 10, order: 1 },
            { atom1: 5, atom2: 11, order: 1 },
            { atom1: 0, atom2: 12, order: 1 },
            { atom1: 0, atom2: 13, order: 1 },
            { atom1: 2, atom2: 14, order: 1 },
            { atom1: 3, atom2: 15, order: 1 },
            { atom1: 4, atom2: 16, order: 1 },
            { atom1: 5, atom2: 17, order: 1 },
            { atom1: 5, atom2: 18, order: 1 },
            { atom1: 6, atom2: 19, order: 1 },
            { atom1: 8, atom2: 20, order: 1 },
            { atom1: 9, atom2: 21, order: 1 },
            { atom1: 10, atom2: 22, order: 1 },
            { atom1: 11, atom2: 23, order: 1 }
        ],
        description: 'Fructose - 6-carbon ketose sugar (hexose), fruit sugar'
    },

    // ===== HYDROXIDES & BASES =====

    'HNaO': {
        name: 'Sodium Hydroxide',
        formula: 'HNaO',
        atoms: [
            { symbol: 'Na', relX: -20, relY: 0 },
            { symbol: 'O', relX: 10, relY: 0 },
            { symbol: 'H', relX: 30, relY: 0 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },
            { atom1: 1, atom2: 2, order: 1 }
        ],
        description: 'Sodium hydroxide (lye/caustic soda) - strong base NaOH'
    },
    'HKO': {
        name: 'Potassium Hydroxide',
        formula: 'HKO',
        atoms: [
            { symbol: 'K', relX: -22, relY: 0 },
            { symbol: 'O', relX: 10, relY: 0 },
            { symbol: 'H', relX: 30, relY: 0 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },
            { atom1: 1, atom2: 2, order: 1 }
        ],
        description: 'Potassium hydroxide (caustic potash) - strong base KOH'
    },
    'CaH2O2': {
        name: 'Calcium Hydroxide',
        formula: 'CaH2O2',
        atoms: [
            { symbol: 'Ca', relX: 0, relY: 0 },
            { symbol: 'O', relX: -25, relY: 15 },
            { symbol: 'O', relX: 25, relY: 15 },
            { symbol: 'H', relX: -40, relY: 25 },
            { symbol: 'H', relX: 40, relY: 25 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },
            { atom1: 0, atom2: 2, order: 1 },
            { atom1: 1, atom2: 3, order: 1 },
            { atom1: 2, atom2: 4, order: 1 }
        ],
        description: 'Calcium hydroxide (slaked lime) - Ca(OH)2'
    },
    'FeH2O2': {
        name: 'Iron(II) Hydroxide',
        formula: 'FeH2O2',
        atoms: [
            { symbol: 'Fe', relX: 0, relY: 0 },
            { symbol: 'O', relX: -25, relY: 15 },
            { symbol: 'O', relX: 25, relY: 15 },
            { symbol: 'H', relX: -40, relY: 25 },
            { symbol: 'H', relX: 40, relY: 25 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },
            { atom1: 0, atom2: 2, order: 1 },
            { atom1: 1, atom2: 3, order: 1 },
            { atom1: 2, atom2: 4, order: 1 }
        ],
        description: 'Iron(II) hydroxide (ferrous hydroxide) - Fe(OH)2'
    },
    'FeH3O3': {
        name: 'Iron(III) Hydroxide',
        formula: 'FeH3O3',
        atoms: [
            { symbol: 'Fe', relX: 0, relY: 0 },
            { symbol: 'O', relX: 0, relY: -25 },
            { symbol: 'O', relX: -22, relY: 12 },
            { symbol: 'O', relX: 22, relY: 12 },
            { symbol: 'H', relX: 0, relY: -45 },
            { symbol: 'H', relX: -37, relY: 22 },
            { symbol: 'H', relX: 37, relY: 22 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },
            { atom1: 0, atom2: 2, order: 1 },
            { atom1: 0, atom2: 3, order: 1 },
            { atom1: 1, atom2: 4, order: 1 },
            { atom1: 2, atom2: 5, order: 1 },
            { atom1: 3, atom2: 6, order: 1 }
        ],
        description: 'Iron(III) hydroxide (ferric hydroxide) - Fe(OH)3'
    },
    'ClHO': {
        name: 'Hypochlorous Acid',
        formula: 'ClHO',
        atoms: [
            { symbol: 'Cl', relX: -18, relY: 0 },
            { symbol: 'O', relX: 10, relY: 0 },
            { symbol: 'H', relX: 28, relY: 0 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },
            { atom1: 1, atom2: 2, order: 1 }
        ],
        description: 'Hypochlorous acid - weak acid, disinfectant HOCl'
    },
    // H3O (Hydronium) removed - it's an ion (O has 3 bonds but valence is 2)
    'H2O2': {
        name: 'Hydrogen Peroxide',
        formula: 'H2O2',
        atoms: [
            { symbol: 'O', relX: -12, relY: 0 },
            { symbol: 'O', relX: 12, relY: 0 },
            { symbol: 'H', relX: -28, relY: 15 },
            { symbol: 'H', relX: 28, relY: -15 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },
            { atom1: 0, atom2: 2, order: 1 },
            { atom1: 1, atom2: 3, order: 1 }
        ],
        description: 'Hydrogen peroxide - oxidizer with O-O bond'
    },

    // ===== HYDROCARBONS - ALKANES (saturated) =====

    'C2H6': {
        name: 'Ethane',
        formula: 'C2H6',
        atoms: [
            { symbol: 'C', relX: -18, relY: 0 },        // C1
            { symbol: 'C', relX: 18, relY: 0 },         // C2
            { symbol: 'H', relX: -33, relY: -15 },
            { symbol: 'H', relX: -33, relY: 15 },
            { symbol: 'H', relX: -18, relY: -25 },
            { symbol: 'H', relX: 33, relY: -15 },
            { symbol: 'H', relX: 33, relY: 15 },
            { symbol: 'H', relX: 18, relY: 25 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },
            { atom1: 0, atom2: 2, order: 1 },
            { atom1: 0, atom2: 3, order: 1 },
            { atom1: 0, atom2: 4, order: 1 },
            { atom1: 1, atom2: 5, order: 1 },
            { atom1: 1, atom2: 6, order: 1 },
            { atom1: 1, atom2: 7, order: 1 }
        ],
        description: 'Ethane - simplest alkane with C-C bond'
    },
    'C3H8': {
        name: 'Propane',
        formula: 'C3H8',
        atoms: [
            { symbol: 'C', relX: -30, relY: 0 },        // C1 (methyl)
            { symbol: 'C', relX: 0, relY: 0 },          // C2 (central)
            { symbol: 'C', relX: 30, relY: 0 },         // C3 (methyl)
            { symbol: 'H', relX: -45, relY: -15 },
            { symbol: 'H', relX: -45, relY: 15 },
            { symbol: 'H', relX: -30, relY: -22 },
            { symbol: 'H', relX: 0, relY: -22 },
            { symbol: 'H', relX: 0, relY: 22 },
            { symbol: 'H', relX: 45, relY: -15 },
            { symbol: 'H', relX: 45, relY: 15 },
            { symbol: 'H', relX: 30, relY: 22 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },
            { atom1: 1, atom2: 2, order: 1 },
            { atom1: 0, atom2: 3, order: 1 },
            { atom1: 0, atom2: 4, order: 1 },
            { atom1: 0, atom2: 5, order: 1 },
            { atom1: 1, atom2: 6, order: 1 },
            { atom1: 1, atom2: 7, order: 1 },
            { atom1: 2, atom2: 8, order: 1 },
            { atom1: 2, atom2: 9, order: 1 },
            { atom1: 2, atom2: 10, order: 1 }
        ],
        description: 'Propane - 3-carbon alkane'
    },
    'C4H10': {
        name: 'Butane',
        formula: 'C4H10',
        atoms: [
            { symbol: 'C', relX: -45, relY: 0 },        // C1
            { symbol: 'C', relX: -15, relY: 0 },        // C2
            { symbol: 'C', relX: 15, relY: 0 },         // C3
            { symbol: 'C', relX: 45, relY: 0 },         // C4
            { symbol: 'H', relX: -60, relY: -15 },
            { symbol: 'H', relX: -60, relY: 15 },
            { symbol: 'H', relX: -45, relY: -22 },
            { symbol: 'H', relX: -15, relY: -22 },
            { symbol: 'H', relX: -15, relY: 22 },
            { symbol: 'H', relX: 15, relY: -22 },
            { symbol: 'H', relX: 15, relY: 22 },
            { symbol: 'H', relX: 60, relY: -15 },
            { symbol: 'H', relX: 60, relY: 15 },
            { symbol: 'H', relX: 45, relY: 22 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },
            { atom1: 1, atom2: 2, order: 1 },
            { atom1: 2, atom2: 3, order: 1 },
            { atom1: 0, atom2: 4, order: 1 },
            { atom1: 0, atom2: 5, order: 1 },
            { atom1: 0, atom2: 6, order: 1 },
            { atom1: 1, atom2: 7, order: 1 },
            { atom1: 1, atom2: 8, order: 1 },
            { atom1: 2, atom2: 9, order: 1 },
            { atom1: 2, atom2: 10, order: 1 },
            { atom1: 3, atom2: 11, order: 1 },
            { atom1: 3, atom2: 12, order: 1 },
            { atom1: 3, atom2: 13, order: 1 }
        ],
        description: 'Butane - 4-carbon alkane'
    },
    'C5H12': {
        name: 'Pentane',
        formula: 'C5H12',
        atoms: [
            { symbol: 'C', relX: -60, relY: 0 },        // C1
            { symbol: 'C', relX: -30, relY: 0 },        // C2
            { symbol: 'C', relX: 0, relY: 0 },          // C3
            { symbol: 'C', relX: 30, relY: 0 },         // C4
            { symbol: 'C', relX: 60, relY: 0 },         // C5
            { symbol: 'H', relX: -75, relY: -15 },
            { symbol: 'H', relX: -75, relY: 15 },
            { symbol: 'H', relX: -60, relY: -22 },
            { symbol: 'H', relX: -30, relY: -22 },
            { symbol: 'H', relX: -30, relY: 22 },
            { symbol: 'H', relX: 0, relY: -22 },
            { symbol: 'H', relX: 0, relY: 22 },
            { symbol: 'H', relX: 30, relY: -22 },
            { symbol: 'H', relX: 30, relY: 22 },
            { symbol: 'H', relX: 75, relY: -15 },
            { symbol: 'H', relX: 75, relY: 15 },
            { symbol: 'H', relX: 60, relY: 22 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },
            { atom1: 1, atom2: 2, order: 1 },
            { atom1: 2, atom2: 3, order: 1 },
            { atom1: 3, atom2: 4, order: 1 },
            { atom1: 0, atom2: 5, order: 1 },
            { atom1: 0, atom2: 6, order: 1 },
            { atom1: 0, atom2: 7, order: 1 },
            { atom1: 1, atom2: 8, order: 1 },
            { atom1: 1, atom2: 9, order: 1 },
            { atom1: 2, atom2: 10, order: 1 },
            { atom1: 2, atom2: 11, order: 1 },
            { atom1: 3, atom2: 12, order: 1 },
            { atom1: 3, atom2: 13, order: 1 },
            { atom1: 4, atom2: 14, order: 1 },
            { atom1: 4, atom2: 15, order: 1 },
            { atom1: 4, atom2: 16, order: 1 }
        ],
        description: 'Pentane - 5-carbon alkane'
    },
    'C6H14': {
        name: 'Hexane',
        formula: 'C6H14',
        atoms: [
            { symbol: 'C', relX: -75, relY: 0 },        // C1
            { symbol: 'C', relX: -45, relY: 0 },        // C2
            { symbol: 'C', relX: -15, relY: 0 },        // C3
            { symbol: 'C', relX: 15, relY: 0 },         // C4
            { symbol: 'C', relX: 45, relY: 0 },         // C5
            { symbol: 'C', relX: 75, relY: 0 },         // C6
            { symbol: 'H', relX: -90, relY: -15 },
            { symbol: 'H', relX: -90, relY: 15 },
            { symbol: 'H', relX: -75, relY: -22 },
            { symbol: 'H', relX: -45, relY: -22 },
            { symbol: 'H', relX: -45, relY: 22 },
            { symbol: 'H', relX: -15, relY: -22 },
            { symbol: 'H', relX: -15, relY: 22 },
            { symbol: 'H', relX: 15, relY: -22 },
            { symbol: 'H', relX: 15, relY: 22 },
            { symbol: 'H', relX: 45, relY: -22 },
            { symbol: 'H', relX: 45, relY: 22 },
            { symbol: 'H', relX: 90, relY: -15 },
            { symbol: 'H', relX: 90, relY: 15 },
            { symbol: 'H', relX: 75, relY: 22 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },
            { atom1: 1, atom2: 2, order: 1 },
            { atom1: 2, atom2: 3, order: 1 },
            { atom1: 3, atom2: 4, order: 1 },
            { atom1: 4, atom2: 5, order: 1 },
            { atom1: 0, atom2: 6, order: 1 },
            { atom1: 0, atom2: 7, order: 1 },
            { atom1: 0, atom2: 8, order: 1 },
            { atom1: 1, atom2: 9, order: 1 },
            { atom1: 1, atom2: 10, order: 1 },
            { atom1: 2, atom2: 11, order: 1 },
            { atom1: 2, atom2: 12, order: 1 },
            { atom1: 3, atom2: 13, order: 1 },
            { atom1: 3, atom2: 14, order: 1 },
            { atom1: 4, atom2: 15, order: 1 },
            { atom1: 4, atom2: 16, order: 1 },
            { atom1: 5, atom2: 17, order: 1 },
            { atom1: 5, atom2: 18, order: 1 },
            { atom1: 5, atom2: 19, order: 1 }
        ],
        description: 'Hexane - 6-carbon alkane'
    },

    // ===== HYDROCARBONS - ALKENES (unsaturated with C=C) =====

    'C3H6': {
        name: 'Propene',
        formula: 'C3H6',
        atoms: [
            { symbol: 'C', relX: -30, relY: 0 },        // C1 (CH3)
            { symbol: 'C', relX: 0, relY: 0 },          // C2 (=CH)
            { symbol: 'C', relX: 30, relY: 0 },         // C3 (=CH2)
            { symbol: 'H', relX: -45, relY: -15 },
            { symbol: 'H', relX: -45, relY: 15 },
            { symbol: 'H', relX: -30, relY: -22 },
            { symbol: 'H', relX: 0, relY: 22 },
            { symbol: 'H', relX: 45, relY: -15 },
            { symbol: 'H', relX: 45, relY: 15 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },
            { atom1: 1, atom2: 2, order: 2 },           // C=C double bond
            { atom1: 0, atom2: 3, order: 1 },
            { atom1: 0, atom2: 4, order: 1 },
            { atom1: 0, atom2: 5, order: 1 },
            { atom1: 1, atom2: 6, order: 1 },
            { atom1: 2, atom2: 7, order: 1 },
            { atom1: 2, atom2: 8, order: 1 }
        ],
        description: 'Propene - 3-carbon alkene (propylene)'
    },
    'C4H8': {
        name: 'Butene',
        formula: 'C4H8',
        atoms: [
            { symbol: 'C', relX: -45, relY: 0 },        // C1 (CH3)
            { symbol: 'C', relX: -15, relY: 0 },        // C2
            { symbol: 'C', relX: 15, relY: 0 },         // C3
            { symbol: 'C', relX: 45, relY: 0 },         // C4 (=CH2)
            { symbol: 'H', relX: -60, relY: -15 },
            { symbol: 'H', relX: -60, relY: 15 },
            { symbol: 'H', relX: -45, relY: -22 },
            { symbol: 'H', relX: -15, relY: -22 },
            { symbol: 'H', relX: -15, relY: 22 },
            { symbol: 'H', relX: 15, relY: 22 },
            { symbol: 'H', relX: 60, relY: -15 },
            { symbol: 'H', relX: 60, relY: 15 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },
            { atom1: 1, atom2: 2, order: 1 },
            { atom1: 2, atom2: 3, order: 2 },           // C=C double bond
            { atom1: 0, atom2: 4, order: 1 },
            { atom1: 0, atom2: 5, order: 1 },
            { atom1: 0, atom2: 6, order: 1 },
            { atom1: 1, atom2: 7, order: 1 },
            { atom1: 1, atom2: 8, order: 1 },
            { atom1: 2, atom2: 9, order: 1 },
            { atom1: 3, atom2: 10, order: 1 },
            { atom1: 3, atom2: 11, order: 1 }
        ],
        description: 'Butene - 4-carbon alkene (1-butene)'
    },
    'C5H10': {
        name: 'Pentene',
        formula: 'C5H10',
        atoms: [
            { symbol: 'C', relX: -60, relY: 0 },        // C1
            { symbol: 'C', relX: -30, relY: 0 },        // C2
            { symbol: 'C', relX: 0, relY: 0 },          // C3
            { symbol: 'C', relX: 30, relY: 0 },         // C4
            { symbol: 'C', relX: 60, relY: 0 },         // C5 (=CH2)
            { symbol: 'H', relX: -75, relY: -15 },
            { symbol: 'H', relX: -75, relY: 15 },
            { symbol: 'H', relX: -60, relY: -22 },
            { symbol: 'H', relX: -30, relY: -22 },
            { symbol: 'H', relX: -30, relY: 22 },
            { symbol: 'H', relX: 0, relY: -22 },
            { symbol: 'H', relX: 0, relY: 22 },
            { symbol: 'H', relX: 30, relY: 22 },
            { symbol: 'H', relX: 75, relY: -15 },
            { symbol: 'H', relX: 75, relY: 15 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },
            { atom1: 1, atom2: 2, order: 1 },
            { atom1: 2, atom2: 3, order: 1 },
            { atom1: 3, atom2: 4, order: 2 },           // C=C double bond
            { atom1: 0, atom2: 5, order: 1 },
            { atom1: 0, atom2: 6, order: 1 },
            { atom1: 0, atom2: 7, order: 1 },
            { atom1: 1, atom2: 8, order: 1 },
            { atom1: 1, atom2: 9, order: 1 },
            { atom1: 2, atom2: 10, order: 1 },
            { atom1: 2, atom2: 11, order: 1 },
            { atom1: 3, atom2: 12, order: 1 },
            { atom1: 4, atom2: 13, order: 1 },
            { atom1: 4, atom2: 14, order: 1 }
        ],
        description: 'Pentene - 5-carbon alkene (1-pentene)'
    },

    // ===== HYDROCARBONS - ALKYNES (triple bond) =====

    'C2H2': {
        name: 'Acetylene',
        formula: 'C2H2',
        atoms: [
            { symbol: 'C', relX: -15, relY: 0 },
            { symbol: 'C', relX: 15, relY: 0 },
            { symbol: 'H', relX: -35, relY: 0 },
            { symbol: 'H', relX: 35, relY: 0 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 3 },           // C‚â°C triple bond
            { atom1: 0, atom2: 2, order: 1 },
            { atom1: 1, atom2: 3, order: 1 }
        ],
        description: 'Acetylene - simplest alkyne with C‚â°C triple bond'
    },
    'C3H4': {
        name: 'Propyne',
        formula: 'C3H4',
        atoms: [
            { symbol: 'C', relX: -30, relY: 0 },        // CH3
            { symbol: 'C', relX: 0, relY: 0 },          // C (triple)
            { symbol: 'C', relX: 30, relY: 0 },         // CH
            { symbol: 'H', relX: -45, relY: -15 },
            { symbol: 'H', relX: -45, relY: 15 },
            { symbol: 'H', relX: -30, relY: -22 },
            { symbol: 'H', relX: 50, relY: 0 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },
            { atom1: 1, atom2: 2, order: 3 },           // C‚â°C triple bond
            { atom1: 0, atom2: 3, order: 1 },
            { atom1: 0, atom2: 4, order: 1 },
            { atom1: 0, atom2: 5, order: 1 },
            { atom1: 2, atom2: 6, order: 1 }
        ],
        description: 'Propyne - 3-carbon alkyne (methylacetylene)'
    },
    'C4H6': {
        name: 'Butyne',
        formula: 'C4H6',
        atoms: [
            { symbol: 'C', relX: -45, relY: 0 },        // CH3
            { symbol: 'C', relX: -15, relY: 0 },        // C (triple)
            { symbol: 'C', relX: 15, relY: 0 },         // C (triple)
            { symbol: 'C', relX: 45, relY: 0 },         // CH3
            { symbol: 'H', relX: -60, relY: -15 },
            { symbol: 'H', relX: -60, relY: 15 },
            { symbol: 'H', relX: -45, relY: -22 },
            { symbol: 'H', relX: 60, relY: -15 },
            { symbol: 'H', relX: 60, relY: 15 },
            { symbol: 'H', relX: 45, relY: 22 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },
            { atom1: 1, atom2: 2, order: 3 },           // C‚â°C triple bond
            { atom1: 2, atom2: 3, order: 1 },
            { atom1: 0, atom2: 4, order: 1 },
            { atom1: 0, atom2: 5, order: 1 },
            { atom1: 0, atom2: 6, order: 1 },
            { atom1: 3, atom2: 7, order: 1 },
            { atom1: 3, atom2: 8, order: 1 },
            { atom1: 3, atom2: 9, order: 1 }
        ],
        description: 'Butyne - 4-carbon alkyne (2-butyne)'
    },

    // ===== HYDROCARBONS - AROMATICS =====

    'C6H6': {
        name: 'Benzene',
        formula: 'C6H6',
        atoms: [
            // Hexagonal ring of carbons (60¬∞ apart)
            { symbol: 'C', relX: 0, relY: -30 },        // Top
            { symbol: 'C', relX: 26, relY: -15 },       // Top-right
            { symbol: 'C', relX: 26, relY: 15 },        // Bottom-right
            { symbol: 'C', relX: 0, relY: 30 },         // Bottom
            { symbol: 'C', relX: -26, relY: 15 },       // Bottom-left
            { symbol: 'C', relX: -26, relY: -15 },      // Top-left
            // Hydrogens pointing outward
            { symbol: 'H', relX: 0, relY: -50 },
            { symbol: 'H', relX: 43, relY: -25 },
            { symbol: 'H', relX: 43, relY: 25 },
            { symbol: 'H', relX: 0, relY: 50 },
            { symbol: 'H', relX: -43, relY: 25 },
            { symbol: 'H', relX: -43, relY: -25 }
        ],
        bonds: [
            // Alternating double bonds (Kekul√© structure)
            { atom1: 0, atom2: 1, order: 2 },
            { atom1: 1, atom2: 2, order: 1 },
            { atom1: 2, atom2: 3, order: 2 },
            { atom1: 3, atom2: 4, order: 1 },
            { atom1: 4, atom2: 5, order: 2 },
            { atom1: 5, atom2: 0, order: 1 },
            // C-H bonds
            { atom1: 0, atom2: 6, order: 1 },
            { atom1: 1, atom2: 7, order: 1 },
            { atom1: 2, atom2: 8, order: 1 },
            { atom1: 3, atom2: 9, order: 1 },
            { atom1: 4, atom2: 10, order: 1 },
            { atom1: 5, atom2: 11, order: 1 }
        ],
        description: 'Benzene - aromatic ring with delocalized electrons'
    },
    'C7H8': {
        name: 'Toluene',
        formula: 'C7H8',
        atoms: [
            // Benzene ring
            { symbol: 'C', relX: 0, relY: -30 },
            { symbol: 'C', relX: 26, relY: -15 },
            { symbol: 'C', relX: 26, relY: 15 },
            { symbol: 'C', relX: 0, relY: 30 },
            { symbol: 'C', relX: -26, relY: 15 },
            { symbol: 'C', relX: -26, relY: -15 },
            // Methyl group on top carbon
            { symbol: 'C', relX: 0, relY: -55 },
            // Ring hydrogens (5, top has CH3)
            { symbol: 'H', relX: 43, relY: -25 },
            { symbol: 'H', relX: 43, relY: 25 },
            { symbol: 'H', relX: 0, relY: 50 },
            { symbol: 'H', relX: -43, relY: 25 },
            { symbol: 'H', relX: -43, relY: -25 },
            // Methyl hydrogens
            { symbol: 'H', relX: -15, relY: -65 },
            { symbol: 'H', relX: 15, relY: -65 },
            { symbol: 'H', relX: 0, relY: -75 }
        ],
        bonds: [
            // Aromatic ring
            { atom1: 0, atom2: 1, order: 2 },
            { atom1: 1, atom2: 2, order: 1 },
            { atom1: 2, atom2: 3, order: 2 },
            { atom1: 3, atom2: 4, order: 1 },
            { atom1: 4, atom2: 5, order: 2 },
            { atom1: 5, atom2: 0, order: 1 },
            // C-CH3
            { atom1: 0, atom2: 6, order: 1 },
            // C-H on ring
            { atom1: 1, atom2: 7, order: 1 },
            { atom1: 2, atom2: 8, order: 1 },
            { atom1: 3, atom2: 9, order: 1 },
            { atom1: 4, atom2: 10, order: 1 },
            { atom1: 5, atom2: 11, order: 1 },
            // CH3 hydrogens
            { atom1: 6, atom2: 12, order: 1 },
            { atom1: 6, atom2: 13, order: 1 },
            { atom1: 6, atom2: 14, order: 1 }
        ],
        description: 'Toluene - methylbenzene aromatic compound'
    },

    // ===== HYDROCARBONS - CYCLIC =====

    'C3H6cyc': {
        name: 'Cyclopropane',
        formula: 'C3H6',
        atoms: [
            // Triangular ring
            { symbol: 'C', relX: 0, relY: -20 },
            { symbol: 'C', relX: 17, relY: 10 },
            { symbol: 'C', relX: -17, relY: 10 },
            // Hydrogens
            { symbol: 'H', relX: -12, relY: -35 },
            { symbol: 'H', relX: 12, relY: -35 },
            { symbol: 'H', relX: 32, relY: 0 },
            { symbol: 'H', relX: 27, relY: 25 },
            { symbol: 'H', relX: -32, relY: 0 },
            { symbol: 'H', relX: -27, relY: 25 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },
            { atom1: 1, atom2: 2, order: 1 },
            { atom1: 2, atom2: 0, order: 1 },
            { atom1: 0, atom2: 3, order: 1 },
            { atom1: 0, atom2: 4, order: 1 },
            { atom1: 1, atom2: 5, order: 1 },
            { atom1: 1, atom2: 6, order: 1 },
            { atom1: 2, atom2: 7, order: 1 },
            { atom1: 2, atom2: 8, order: 1 }
        ],
        description: 'Cyclopropane - 3-membered carbon ring'
    },
    'C4H8cyc': {
        name: 'Cyclobutane',
        formula: 'C4H8',
        atoms: [
            // Square ring
            { symbol: 'C', relX: -15, relY: -15 },
            { symbol: 'C', relX: 15, relY: -15 },
            { symbol: 'C', relX: 15, relY: 15 },
            { symbol: 'C', relX: -15, relY: 15 },
            // Hydrogens
            { symbol: 'H', relX: -30, relY: -25 },
            { symbol: 'H', relX: -15, relY: -35 },
            { symbol: 'H', relX: 30, relY: -25 },
            { symbol: 'H', relX: 15, relY: -35 },
            { symbol: 'H', relX: 30, relY: 25 },
            { symbol: 'H', relX: 15, relY: 35 },
            { symbol: 'H', relX: -30, relY: 25 },
            { symbol: 'H', relX: -15, relY: 35 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },
            { atom1: 1, atom2: 2, order: 1 },
            { atom1: 2, atom2: 3, order: 1 },
            { atom1: 3, atom2: 0, order: 1 },
            { atom1: 0, atom2: 4, order: 1 },
            { atom1: 0, atom2: 5, order: 1 },
            { atom1: 1, atom2: 6, order: 1 },
            { atom1: 1, atom2: 7, order: 1 },
            { atom1: 2, atom2: 8, order: 1 },
            { atom1: 2, atom2: 9, order: 1 },
            { atom1: 3, atom2: 10, order: 1 },
            { atom1: 3, atom2: 11, order: 1 }
        ],
        description: 'Cyclobutane - 4-membered carbon ring'
    },
    'C5H10cyc': {
        name: 'Cyclopentane',
        formula: 'C5H10',
        atoms: [
            // Pentagon ring
            { symbol: 'C', relX: 0, relY: -25 },
            { symbol: 'C', relX: 24, relY: -8 },
            { symbol: 'C', relX: 15, relY: 20 },
            { symbol: 'C', relX: -15, relY: 20 },
            { symbol: 'C', relX: -24, relY: -8 },
            // Hydrogens
            { symbol: 'H', relX: -12, relY: -40 },
            { symbol: 'H', relX: 12, relY: -40 },
            { symbol: 'H', relX: 40, relY: -18 },
            { symbol: 'H', relX: 35, relY: 5 },
            { symbol: 'H', relX: 25, relY: 35 },
            { symbol: 'H', relX: 5, relY: 35 },
            { symbol: 'H', relX: -25, relY: 35 },
            { symbol: 'H', relX: -5, relY: 35 },
            { symbol: 'H', relX: -40, relY: -18 },
            { symbol: 'H', relX: -35, relY: 5 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },
            { atom1: 1, atom2: 2, order: 1 },
            { atom1: 2, atom2: 3, order: 1 },
            { atom1: 3, atom2: 4, order: 1 },
            { atom1: 4, atom2: 0, order: 1 },
            { atom1: 0, atom2: 5, order: 1 },
            { atom1: 0, atom2: 6, order: 1 },
            { atom1: 1, atom2: 7, order: 1 },
            { atom1: 1, atom2: 8, order: 1 },
            { atom1: 2, atom2: 9, order: 1 },
            { atom1: 2, atom2: 10, order: 1 },
            { atom1: 3, atom2: 11, order: 1 },
            { atom1: 3, atom2: 12, order: 1 },
            { atom1: 4, atom2: 13, order: 1 },
            { atom1: 4, atom2: 14, order: 1 }
        ],
        description: 'Cyclopentane - 5-membered carbon ring'
    },
    'C6H12': {
        name: 'Cyclohexane',
        formula: 'C6H12',
        atoms: [
            // Hexagonal ring
            { symbol: 'C', relX: 0, relY: -28 },
            { symbol: 'C', relX: 24, relY: -14 },
            { symbol: 'C', relX: 24, relY: 14 },
            { symbol: 'C', relX: 0, relY: 28 },
            { symbol: 'C', relX: -24, relY: 14 },
            { symbol: 'C', relX: -24, relY: -14 },
            // Hydrogens (2 per carbon)
            { symbol: 'H', relX: -12, relY: -43 },
            { symbol: 'H', relX: 12, relY: -43 },
            { symbol: 'H', relX: 40, relY: -24 },
            { symbol: 'H', relX: 38, relY: -4 },
            { symbol: 'H', relX: 40, relY: 24 },
            { symbol: 'H', relX: 38, relY: 4 },
            { symbol: 'H', relX: -12, relY: 43 },
            { symbol: 'H', relX: 12, relY: 43 },
            { symbol: 'H', relX: -40, relY: 24 },
            { symbol: 'H', relX: -38, relY: 4 },
            { symbol: 'H', relX: -40, relY: -24 },
            { symbol: 'H', relX: -38, relY: -4 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },
            { atom1: 1, atom2: 2, order: 1 },
            { atom1: 2, atom2: 3, order: 1 },
            { atom1: 3, atom2: 4, order: 1 },
            { atom1: 4, atom2: 5, order: 1 },
            { atom1: 5, atom2: 0, order: 1 },
            { atom1: 0, atom2: 6, order: 1 },
            { atom1: 0, atom2: 7, order: 1 },
            { atom1: 1, atom2: 8, order: 1 },
            { atom1: 1, atom2: 9, order: 1 },
            { atom1: 2, atom2: 10, order: 1 },
            { atom1: 2, atom2: 11, order: 1 },
            { atom1: 3, atom2: 12, order: 1 },
            { atom1: 3, atom2: 13, order: 1 },
            { atom1: 4, atom2: 14, order: 1 },
            { atom1: 4, atom2: 15, order: 1 },
            { atom1: 5, atom2: 16, order: 1 },
            { atom1: 5, atom2: 17, order: 1 }
        ],
        description: 'Cyclohexane - 6-membered carbon ring (chair conformation)'
    },

    // ===== MONOMER MOLECULES (for polymer formation) =====

    'C2H4': {
        name: 'Ethylene',
        formula: 'C2H4',
        isMonomer: true,
        polymerName: 'Polyethylene',
        atoms: [
            { symbol: 'C', relX: -15, relY: 0 },
            { symbol: 'C', relX: 15, relY: 0 },
            { symbol: 'H', relX: -30, relY: -15 },
            { symbol: 'H', relX: -30, relY: 15 },
            { symbol: 'H', relX: 30, relY: -15 },
            { symbol: 'H', relX: 30, relY: 15 }
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 2 },  // C=C double bond
            { atom1: 0, atom2: 2, order: 1 },  // C-H
            { atom1: 0, atom2: 3, order: 1 },  // C-H
            { atom1: 1, atom2: 4, order: 1 },  // C-H
            { atom1: 1, atom2: 5, order: 1 }   // C-H
        ],
        description: 'Ethylene - simplest alkene with C=C double bond'
    },
    'C2H5NO2': {
        name: 'Glycine',
        formula: 'C2H5NO2',
        isMonomer: true,
        polymerName: 'Protein',
        atoms: [
            { symbol: 'N', relX: -30, relY: 0 },    // Amino nitrogen
            { symbol: 'C', relX: 0, relY: 0 },      // Alpha carbon
            { symbol: 'C', relX: 30, relY: 0 },     // Carboxyl carbon
            { symbol: 'O', relX: 45, relY: -15 },   // Carboxyl O (double bond)
            { symbol: 'O', relX: 45, relY: 15 },    // Carboxyl OH
            { symbol: 'H', relX: -45, relY: -10 },  // NH2 hydrogen
            { symbol: 'H', relX: -45, relY: 10 },   // NH2 hydrogen
            { symbol: 'H', relX: 0, relY: -20 },    // CH2 hydrogen
            { symbol: 'H', relX: 0, relY: 20 },     // CH2 hydrogen
            { symbol: 'H', relX: 60, relY: 20 }     // OH hydrogen
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },  // N-C
            { atom1: 1, atom2: 2, order: 1 },  // C-C
            { atom1: 2, atom2: 3, order: 2 },  // C=O
            { atom1: 2, atom2: 4, order: 1 },  // C-O
            { atom1: 0, atom2: 5, order: 1 },  // N-H
            { atom1: 0, atom2: 6, order: 1 },  // N-H
            { atom1: 1, atom2: 7, order: 1 },  // C-H
            { atom1: 1, atom2: 8, order: 1 },  // C-H
            { atom1: 4, atom2: 9, order: 1 }   // O-H
        ],
        description: 'Glycine - simplest amino acid (H2N-CH2-COOH)'
    },
    'C4H8O2': {
        name: 'Butyric Acid (Fatty Acid)',
        formula: 'C4H8O2',
        isMonomer: true,
        polymerName: 'Lipid Chain',
        atoms: [
            { symbol: 'C', relX: -45, relY: 0 },   // Methyl C
            { symbol: 'C', relX: -15, relY: 0 },   // CH2
            { symbol: 'C', relX: 15, relY: 0 },    // CH2
            { symbol: 'C', relX: 45, relY: 0 },    // Carboxyl C
            { symbol: 'O', relX: 60, relY: -15 },  // C=O
            { symbol: 'O', relX: 60, relY: 15 },   // C-OH
            { symbol: 'H', relX: -55, relY: -12 },
            { symbol: 'H', relX: -55, relY: 12 },
            { symbol: 'H', relX: -55, relY: 0 },   // CH3 H
            { symbol: 'H', relX: -15, relY: -15 },
            { symbol: 'H', relX: -15, relY: 15 },
            { symbol: 'H', relX: 15, relY: -15 },
            { symbol: 'H', relX: 15, relY: 15 },
            { symbol: 'H', relX: 75, relY: 20 }    // OH hydrogen
        ],
        bonds: [
            { atom1: 0, atom2: 1, order: 1 },
            { atom1: 1, atom2: 2, order: 1 },
            { atom1: 2, atom2: 3, order: 1 },
            { atom1: 3, atom2: 4, order: 2 },
            { atom1: 3, atom2: 5, order: 1 },
            { atom1: 0, atom2: 6, order: 1 },
            { atom1: 0, atom2: 7, order: 1 },
            { atom1: 0, atom2: 8, order: 1 },
            { atom1: 1, atom2: 9, order: 1 },
            { atom1: 1, atom2: 10, order: 1 },
            { atom1: 2, atom2: 11, order: 1 },
            { atom1: 2, atom2: 12, order: 1 },
            { atom1: 5, atom2: 13, order: 1 }
        ],
        description: 'Butyric acid - short chain fatty acid (CH3-CH2-CH2-COOH)'
    }
};

/**
 * Get a stable molecule template by formula
 * @param {string} formula - Molecular formula (e.g., 'H2O', 'CO2')
 * @returns {Object|null} Template object or null if not found
 */
function getStableMoleculeTemplate(formula) {
    return STABLE_MOLECULES[formula] || null;
}

/**
 * Check if a molecule's atoms match a known stable template
 * Returns the template if matched, null otherwise
 * @param {Molecule} molecule - The molecule to check
 * @returns {Object|null} Matching template or null
 */
function matchesStableTemplate(molecule) {
    if (!molecule || !molecule.formula) return null;

    const template = STABLE_MOLECULES[molecule.formula];
    if (!template) return null;

    // Verify atom counts match
    const moleculeAtomCounts = {};
    for (const atom of molecule.atoms) {
        moleculeAtomCounts[atom.symbol] = (moleculeAtomCounts[atom.symbol] || 0) + 1;
    }

    const templateAtomCounts = {};
    for (const atomData of template.atoms) {
        templateAtomCounts[atomData.symbol] = (templateAtomCounts[atomData.symbol] || 0) + 1;
    }

    // Check if counts match
    const moleculeSymbols = Object.keys(moleculeAtomCounts).sort();
    const templateSymbols = Object.keys(templateAtomCounts).sort();

    if (moleculeSymbols.length !== templateSymbols.length) return null;

    for (let i = 0; i < moleculeSymbols.length; i++) {
        if (moleculeSymbols[i] !== templateSymbols[i]) return null;
        if (moleculeAtomCounts[moleculeSymbols[i]] !== templateAtomCounts[templateSymbols[i]]) return null;
    }

    return template;
}

/**
 * Calculate the target positions for a molecule's atoms based on a template
 * This maps the molecule's atoms to the template atoms by element type
 * @param {Molecule} molecule - The molecule to reshape
 * @param {Object} template - The stable template
 * @returns {Object} Object with targetPositions (Map<Atom, Vector2>) and atomToTemplateIndex (Map<Atom, number>)
 */
function getTargetConfiguration(molecule, template) {
    const center = molecule.centerOfMass;
    const targetPositions = new Map();
    const atomToTemplateIndex = new Map();  // Track which template index each atom maps to

    // Group molecule atoms by symbol
    const atomsBySymbol = {};
    for (const atom of molecule.atoms) {
        if (!atomsBySymbol[atom.symbol]) {
            atomsBySymbol[atom.symbol] = [];
        }
        atomsBySymbol[atom.symbol].push(atom);
    }

    // Group template atoms by symbol
    const templateAtomsBySymbol = {};
    for (let i = 0; i < template.atoms.length; i++) {
        const atomData = template.atoms[i];
        if (!templateAtomsBySymbol[atomData.symbol]) {
            templateAtomsBySymbol[atomData.symbol] = [];
        }
        templateAtomsBySymbol[atomData.symbol].push({
            ...atomData,
            index: i
        });
    }

    // Match atoms to template positions
    // For each symbol, assign molecule atoms to template positions
    // Use a simple greedy assignment based on current proximity
    for (const symbol of Object.keys(atomsBySymbol)) {
        const atoms = atomsBySymbol[symbol];
        const templatePositions = templateAtomsBySymbol[symbol];

        if (!templatePositions || atoms.length !== templatePositions.length) {
            continue;
        }

        // For each atom, find the closest available template position
        const usedTemplateIndices = new Set();

        for (const atom of atoms) {
            let bestIndex = -1;
            let bestDistance = Infinity;

            for (let i = 0; i < templatePositions.length; i++) {
                if (usedTemplateIndices.has(i)) continue;

                const tPos = templatePositions[i];
                const targetX = center.x + tPos.relX;
                const targetY = center.y + tPos.relY;
                const dist = atom.position.distanceTo(new Vector2(targetX, targetY));

                if (dist < bestDistance) {
                    bestDistance = dist;
                    bestIndex = i;
                }
            }

            if (bestIndex !== -1) {
                usedTemplateIndices.add(bestIndex);
                const tPos = templatePositions[bestIndex];
                targetPositions.set(atom, new Vector2(
                    center.x + tPos.relX,
                    center.y + tPos.relY
                ));
                // Store the original template index for this atom
                atomToTemplateIndex.set(atom, tPos.index);
            }
        }
    }

    return { targetPositions, atomToTemplateIndex };
}

/**
 * Get the target bond configuration for a template
 * Returns an array of { atom1Index, atom2Index, order } objects
 * @param {Object} template - The stable template
 * @returns {Array} Bond configuration array
 */
function getTemplateBonds(template) {
    return template.bonds || [];
}

/**
 * Check if a molecule needs reshaping (has wrong geometry or bond orders)
 * @param {Molecule} molecule - The molecule to check
 * @param {Object} template - The stable template
 * @returns {boolean} True if reshaping is needed
 */
function needsReshaping(molecule, template) {
    if (!molecule || !template) return false;

    // Check if bond orders match template
    const templateBonds = template.bonds;
    const moleculeBonds = molecule.bonds;

    // If bond count doesn't match, definitely needs reshaping
    if (moleculeBonds.length !== templateBonds.length) {
        return true;
    }

    // Check bond orders
    for (const bond of moleculeBonds) {
        // Find matching template bond (by atom symbols)
        const symbols = [bond.atom1.symbol, bond.atom2.symbol].sort();
        let foundMatch = false;

        for (const tBond of templateBonds) {
            const tSymbols = [
                template.atoms[tBond.atom1].symbol,
                template.atoms[tBond.atom2].symbol
            ].sort();

            if (symbols[0] === tSymbols[0] && symbols[1] === tSymbols[1]) {
                if (bond.order !== tBond.order) {
                    return true; // Bond order mismatch
                }
                foundMatch = true;
                break;
            }
        }

        if (!foundMatch) {
            return true; // Bond not found in template
        }
    }

    // Check if atom positions are significantly different from template
    const config = getTargetConfiguration(molecule, template);
    const targetPositions = config.targetPositions;
    const threshold = 15; // Pixels - if any atom is more than this far from target

    for (const [atom, targetPos] of targetPositions) {
        const dist = atom.position.distanceTo(targetPos);
        if (dist > threshold) {
            return true;
        }
    }

    return false;
}

// Make available globally
window.STABLE_MOLECULES = STABLE_MOLECULES;
window.getStableMoleculeTemplate = getStableMoleculeTemplate;
window.matchesStableTemplate = matchesStableTemplate;
window.getTargetConfiguration = getTargetConfiguration;
window.getTemplateBonds = getTemplateBonds;
window.needsReshaping = needsReshaping;


// ==== src/entities/atom.js ====
/**
 * Atom Entity
 * The fundamental building block of the simulation
 */

class Atom {
    /**
     * Create a new atom
     * @param {string} symbol - Element symbol (e.g., 'C', 'H', 'O')
     * @param {number} x - X position
     * @param {number} y - Y position
     */
    constructor(symbol, x, y) {
        this.id = Utils.generateId();
        this.symbol = symbol;
        this.element = getElement(symbol);

        if (!this.element) {
            throw new Error(`Unknown element: ${symbol}`);
        }

        // Position and physics
        this.position = new Vector2(x, y);
        this.velocity = new Vector2(0, 0);
        this.acceleration = new Vector2(0, 0);

        // Bonding
        this.bonds = [];  // Array of Bond objects
        this.maxBonds = this.element.valence;

        // State
        this.selected = false;
        this.highlighted = false;
        this.moleculeId = null;  // Reference to parent molecule if bonded

        // Physics properties
        this.mass = this.element.mass;
        this.radius = this.element.radius * 0.5;  // Visual radius scaled down
        this.charge = 0;  // Net charge (for ions)
        
        // Repulsion tracking - Map of moleculeId -> remaining ticks of repulsion
        this.repulsions = new Map();
    }

    /**
     * Get the number of current bonds (counting bond order)
     */
    get bondCount() {
        return this.bonds.reduce((sum, bond) => sum + bond.order, 0);
    }

    /**
     * Get available valence (how many more bonds can form)
     */
    get availableValence() {
        return Math.max(0, this.maxBonds - this.bondCount);
    }

    /**
     * Check if this atom can bond with another
     * @param {Atom} other - The other atom
     * @param {number} order - Bond order (1, 2, or 3)
     */
    canBondWith(other, order = 1) {
        if (this === other) return false;
        if (this.availableValence < order) return false;
        if (other.availableValence < order) return false;

        // Sealed atoms (in stable polymers) cannot form new bonds
        if (this.isSealed || other.isSealed) return false;

        // Check if already bonded
        if (this.isBondedTo(other)) return false;
        
        // Check if this atom is repelled from the other atom's molecule
        if (other.moleculeId && this.repulsions.has(other.moleculeId)) return false;
        // Check if the other atom is repelled from this atom's molecule
        if (this.moleculeId && other.repulsions.has(this.moleculeId)) return false;

        return true;
    }

    /**
     * Check if already bonded to another atom
     * @param {Atom} other - The other atom
     */
    isBondedTo(other) {
        return this.bonds.some(bond =>
            bond.atom1 === other || bond.atom2 === other
        );
    }

    /**
     * Get the bond with another atom
     * @param {Atom} other - The other atom
     * @returns {Bond|null}
     */
    getBondWith(other) {
        return this.bonds.find(bond =>
            bond.atom1 === other || bond.atom2 === other
        ) || null;
    }

    /**
     * Add a bond to this atom
     * @param {Bond} bond - The bond to add
     */
    addBond(bond) {
        if (!this.bonds.includes(bond)) {
            this.bonds.push(bond);
        }
    }

    /**
     * Remove a bond from this atom
     * @param {Bond} bond - The bond to remove
     */
    removeBond(bond) {
        const index = this.bonds.indexOf(bond);
        if (index !== -1) {
            this.bonds.splice(index, 1);
        }
    }

    /**
     * Get all atoms bonded to this one
     * @returns {Atom[]}
     */
    getBondedAtoms() {
        return this.bonds.map(bond =>
            bond.atom1 === this ? bond.atom2 : bond.atom1
        );
    }

    /**
     * Add a repulsion from a molecule
     * @param {string} moleculeId - ID of the molecule to be repelled from
     * @param {number} duration - Duration in ticks (default 200)
     */
    addRepulsion(moleculeId, duration = 200) {
        this.repulsions.set(moleculeId, duration);
    }

    /**
     * Check if this atom is repelled from a molecule
     * @param {string} moleculeId - ID of the molecule
     * @returns {boolean}
     */
    isRepelledFrom(moleculeId) {
        return this.repulsions.has(moleculeId);
    }

    /**
     * Update repulsion timers, removing expired ones
     */
    updateRepulsions() {
        for (const [moleculeId, remaining] of this.repulsions) {
            if (remaining <= 1) {
                this.repulsions.delete(moleculeId);
            } else {
                this.repulsions.set(moleculeId, remaining - 1);
            }
        }
    }

    /**
     * Apply a force to this atom
     * @param {Vector2} force - Force vector
     */
    applyForce(force) {
        // F = ma, so a = F/m
        const a = force.div(this.mass);
        this.acceleration = this.acceleration.add(a);
    }

    /**
     * Update physics
     * @param {number} dt - Delta time
     */
    update(dt) {
        // Decay repulsions
        this.updateRepulsions();
        
        // Verlet-style integration
        this.velocity = this.velocity.add(this.acceleration.mul(dt));

        // Apply damping (friction)
        this.velocity = this.velocity.mul(0.99);

        // Update position
        this.position = this.position.add(this.velocity.mul(dt));

        // Reset acceleration
        this.acceleration = new Vector2(0, 0);
    }

    /**
     * Render the atom
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {number} scale - Zoom scale
     * @param {Vector2} offset - Camera offset
     */
    render(ctx, scale = 1, offset = { x: 0, y: 0 }) {
        const screenX = (this.position.x + offset.x) * scale;
        const screenY = (this.position.y + offset.y) * scale;
        const screenRadius = this.radius * scale;

        // Draw atom circle
        ctx.beginPath();
        ctx.arc(screenX, screenY, screenRadius, 0, Math.PI * 2);

        // Gradient fill
        const gradient = ctx.createRadialGradient(
            screenX - screenRadius * 0.3,
            screenY - screenRadius * 0.3,
            0,
            screenX,
            screenY,
            screenRadius
        );
        gradient.addColorStop(0, this.lightenColor(this.element.color, 40));
        gradient.addColorStop(1, this.element.color);

        ctx.fillStyle = gradient;
        ctx.fill();

        // Border
        if (this.selected) {
            ctx.strokeStyle = '#6366f1';
            ctx.lineWidth = 3;
        } else if (this.highlighted) {
            ctx.strokeStyle = '#8b5cf6';
            ctx.lineWidth = 2;
        } else {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
        }
        ctx.stroke();

        // Draw symbol
        if (screenRadius > 10) {
            ctx.fillStyle = this.getContrastColor(this.element.color);
            ctx.font = `bold ${Math.max(10, screenRadius * 0.7)}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(this.symbol, screenX, screenY);
        }
    }

    /**
     * Lighten a hex color
     */
    lightenColor(hex, percent) {
        const num = parseInt(hex.replace('#', ''), 16);
        const amt = Math.round(2.55 * percent);
        const R = Math.min(255, (num >> 16) + amt);
        const G = Math.min(255, ((num >> 8) & 0x00FF) + amt);
        const B = Math.min(255, (num & 0x0000FF) + amt);
        return `rgb(${R}, ${G}, ${B})`;
    }

    /**
     * Get contrasting text color (black or white)
     */
    getContrastColor(hex) {
        const num = parseInt(hex.replace('#', ''), 16);
        const r = (num >> 16) & 255;
        const g = (num >> 8) & 255;
        const b = num & 255;
        const brightness = (r * 299 + g * 587 + b * 114) / 1000;
        return brightness > 128 ? '#000000' : '#FFFFFF';
    }

    /**
     * Check if a point is inside this atom
     * @param {number} x - X coordinate
     * @param {number} y - Y coordinate
     * @param {number} scale - Current zoom scale
     * @param {Vector2} offset - Camera offset
     */
    containsPoint(x, y, scale = 1, offset = { x: 0, y: 0 }) {
        const screenX = (this.position.x + offset.x) * scale;
        const screenY = (this.position.y + offset.y) * scale;
        const screenRadius = this.radius * scale;

        const dx = x - screenX;
        const dy = y - screenY;
        return (dx * dx + dy * dy) <= (screenRadius * screenRadius);
    }

    /**
     * Serialize atom to plain object
     */
    serialize() {
        return {
            id: this.id,
            symbol: this.symbol,
            x: this.position.x,
            y: this.position.y,
            vx: this.velocity.x,
            vy: this.velocity.y,
            charge: this.charge,
            moleculeId: this.moleculeId
        };
    }

    /**
     * Create atom from serialized data
     */
    static deserialize(data) {
        const atom = new Atom(data.symbol, data.x, data.y);
        atom.id = data.id;
        atom.velocity = new Vector2(data.vx, data.vy);
        atom.charge = data.charge || 0;
        atom.moleculeId = data.moleculeId;
        return atom;
    }
}

// Make available globally
window.Atom = Atom;


// ==== src/entities/bond.js ====
/**
 * Bond Entity
 * Represents a chemical bond between two atoms
 */

class Bond {
    /**
     * Create a new bond
     * @param {Atom} atom1 - First atom
     * @param {Atom} atom2 - Second atom
     * @param {number} order - Bond order (1=single, 2=double, 3=triple)
     */
    constructor(atom1, atom2, order = 1) {
        this.id = Utils.generateId();
        this.atom1 = atom1;
        this.atom2 = atom2;
        this.order = Utils.clamp(order, 1, 3);

        // Visual properties
        this.highlighted = false;
        this.selected = false;

        // Physics
        this.restLength = this.calculateRestLength();
        this.strength = this.calculateStrength();

        // Register bond with atoms
        atom1.addBond(this);
        atom2.addBond(this);
    }

    /**
     * Calculate the rest length based on atomic radii
     */
    calculateRestLength() {
        const r1 = this.atom1.element.radius * 0.5;
        const r2 = this.atom2.element.radius * 0.5;
        // Shorter for higher bond orders
        const orderFactor = 1 - (this.order - 1) * 0.1;
        return (r1 + r2) * 1.5 * orderFactor;
    }

    /**
     * Calculate bond strength based on elements
     */
    calculateStrength() {
        return getBondEnergy(this.atom1.symbol, this.atom2.symbol, this.order);
    }

    /**
     * Get the current length of the bond
     */
    get length() {
        return this.atom1.position.distanceTo(this.atom2.position);
    }

    /**
     * Get the strain on the bond (how stretched/compressed)
     */
    get strain() {
        return Math.abs(this.length - this.restLength) / this.restLength;
    }

    /**
     * Check if bond should break based on strain
     */
    shouldBreak() {
        // Higher order bonds are stronger
        const maxStrain = 0.5 + this.order * 0.2;
        return this.strain > maxStrain;
    }

    /**
     * Apply spring forces to maintain bond length
     * @param {number} stiffness - Spring stiffness
     */
    applySpringForce(stiffness = 0.5) {
        const delta = this.atom2.position.sub(this.atom1.position);
        const distance = delta.length();

        if (distance === 0) return;

        // Spring force: F = -k * (x - rest)
        const displacement = distance - this.restLength;
        const forceMagnitude = stiffness * displacement * this.order;

        const direction = delta.normalize();
        const force = direction.mul(forceMagnitude);

        this.atom1.applyForce(force);
        this.atom2.applyForce(force.mul(-1));
    }

    /**
     * Break this bond with energy release
     * @param {boolean} addEnergy - Whether to add repulsion velocity (default true)
     */
    break(addEnergy = true) {
        // Release energy as velocity pushing atoms apart
        if (addEnergy && this.atom1 && this.atom2) {
            const delta = this.atom2.position.sub(this.atom1.position);
            const dist = delta.length();
            if (dist > 0) {
                const direction = delta.normalize();
                // Energy released proportional to bond strength
                const energyFactor = 3 + this.order * 2;  // Higher order = more energy
                this.atom1.velocity = this.atom1.velocity.add(direction.mul(-energyFactor));
                this.atom2.velocity = this.atom2.velocity.add(direction.mul(energyFactor));
            }
        }
        
        this.atom1.removeBond(this);
        this.atom2.removeBond(this);
    }

    /**
     * Get the other atom in the bond
     * @param {Atom} atom - One of the bonded atoms
     * @returns {Atom} The other atom
     */
    getOther(atom) {
        return atom === this.atom1 ? this.atom2 : this.atom1;
    }

    /**
     * Get midpoint of the bond
     */
    getMidpoint() {
        return this.atom1.position.add(this.atom2.position).div(2);
    }

    /**
     * Render the bond
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {number} scale - Zoom scale
     * @param {Vector2} offset - Camera offset
     */
    render(ctx, scale = 1, offset = { x: 0, y: 0 }) {
        const x1 = (this.atom1.position.x + offset.x) * scale;
        const y1 = (this.atom1.position.y + offset.y) * scale;
        const x2 = (this.atom2.position.x + offset.x) * scale;
        const y2 = (this.atom2.position.y + offset.y) * scale;

        // Calculate perpendicular direction for multiple lines
        const dx = x2 - x1;
        const dy = y2 - y1;
        const length = Math.sqrt(dx * dx + dy * dy);
        const perpX = -dy / length;
        const perpY = dx / length;

        // Line spacing for multiple bonds
        const spacing = 4 * scale;

        // Set style
        if (this.selected) {
            ctx.strokeStyle = '#6366f1';
            ctx.lineWidth = 4;
        } else if (this.highlighted) {
            ctx.strokeStyle = '#8b5cf6';
            ctx.lineWidth = 3;
        } else {
            // Color based on strain
            const strainColor = this.strain > 0.3
                ? `rgba(255, ${Math.floor(255 * (1 - this.strain))}, 0, 0.8)`
                : 'rgba(255, 255, 255, 0.6)';
            ctx.strokeStyle = strainColor;
            ctx.lineWidth = 2;
        }

        // Draw bond lines based on order
        if (this.order === 1) {
            // Single bond
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        } else if (this.order === 2) {
            // Double bond
            ctx.beginPath();
            ctx.moveTo(x1 + perpX * spacing, y1 + perpY * spacing);
            ctx.lineTo(x2 + perpX * spacing, y2 + perpY * spacing);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(x1 - perpX * spacing, y1 - perpY * spacing);
            ctx.lineTo(x2 - perpX * spacing, y2 - perpY * spacing);
            ctx.stroke();
        } else if (this.order === 3) {
            // Triple bond
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(x1 + perpX * spacing * 1.5, y1 + perpY * spacing * 1.5);
            ctx.lineTo(x2 + perpX * spacing * 1.5, y2 + perpY * spacing * 1.5);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(x1 - perpX * spacing * 1.5, y1 - perpY * spacing * 1.5);
            ctx.lineTo(x2 - perpX * spacing * 1.5, y2 - perpY * spacing * 1.5);
            ctx.stroke();
        }
    }

    /**
     * Check if a point is near this bond
     * @param {number} x - X coordinate
     * @param {number} y - Y coordinate
     * @param {number} threshold - Distance threshold
     * @param {number} scale - Current zoom scale
     * @param {Vector2} offset - Camera offset
     */
    containsPoint(x, y, threshold = 5, scale = 1, offset = { x: 0, y: 0 }) {
        const x1 = (this.atom1.position.x + offset.x) * scale;
        const y1 = (this.atom1.position.y + offset.y) * scale;
        const x2 = (this.atom2.position.x + offset.x) * scale;
        const y2 = (this.atom2.position.y + offset.y) * scale;

        // Point to line segment distance
        const A = x - x1;
        const B = y - y1;
        const C = x2 - x1;
        const D = y2 - y1;

        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        let param = -1;

        if (lenSq !== 0) {
            param = dot / lenSq;
        }

        let xx, yy;

        if (param < 0) {
            xx = x1;
            yy = y1;
        } else if (param > 1) {
            xx = x2;
            yy = y2;
        } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        const dx = x - xx;
        const dy = y - yy;
        const distance = Math.sqrt(dx * dx + dy * dy);

        return distance <= threshold;
    }

    /**
     * Serialize bond to plain object
     */
    serialize() {
        return {
            id: this.id,
            atom1Id: this.atom1.id,
            atom2Id: this.atom2.id,
            order: this.order
        };
    }

    /**
     * Create bond from serialized data
     * @param {object} data - Serialized bond data
     * @param {Map} atomMap - Map of atom IDs to Atom objects
     */
    static deserialize(data, atomMap) {
        const atom1 = atomMap.get(data.atom1Id);
        const atom2 = atomMap.get(data.atom2Id);

        if (!atom1 || !atom2) {
            throw new Error('Cannot deserialize bond: atoms not found');
        }

        const bond = new Bond(atom1, atom2, data.order);
        bond.id = data.id;
        return bond;
    }
}

/**
 * Try to form a bond between two atoms
 * @param {Atom} atom1 - First atom
 * @param {Atom} atom2 - Second atom
 * @param {number} order - Desired bond order
 * @returns {Bond|null} The created bond or null if not possible
 */
function tryFormBond(atom1, atom2, order = 1) {
    if (!atom1.canBondWith(atom2, order)) {
        return null;
    }

    return new Bond(atom1, atom2, order);
}

// Make available globally
window.Bond = Bond;
window.tryFormBond = tryFormBond;


// ==== src/entities/molecule.js ====
/**
 * Molecule Entity
 * A collection of bonded atoms forming a stable structure
 */

class Molecule {
    /**
     * Create a new molecule from a set of atoms
     * @param {Atom[]} atoms - Array of bonded atoms
     */
    constructor(atoms = []) {
        this.id = Utils.generateId();
        this.atoms = atoms;
        this.name = null;  // Set when catalogued
        this.formula = null;

        // Link atoms to this molecule immediately
        // This ensures atoms have correct moleculeId right after creation
        for (const atom of this.atoms) {
            atom.moleculeId = this.id;
        }

        // Calculate properties
        this.updateProperties();

        // State
        this.selected = false;
        this.highlighted = false;

        // Polymer membership
        this.polymerId = null;

        // Monomer properties - for proper biological polymerization
        this.isMonomer = false;         // Is this molecule a known monomer type?
        this.monomerTemplate = null;    // Reference to the monomer template this matches

        // Abstraction state - stable molecules can be abstracted for performance
        this.abstracted = false;
        this.blueprintRef = null; // Reference to blueprint for reconstruction

        // Decay timer for unstable molecules (in simulation ticks)
        // Unstable molecules decay after 500-1500 ticks, releasing atoms
        this.decayTimer = null;
        this.decayRate = 0; // How fast decay progresses per tick

        // Reshaping state - for transitioning to stable configuration
        this.reshapingTimer = null;        // Countdown timer (in ticks)
        this.reshapingDuration = 200;      // Total ticks to reshape
        this.targetTemplate = null;        // The stable template to reshape towards
        this.isReshaping = false;          // Currently reshaping flag
        this.targetPositions = null;       // Cached target positions for atoms
        this.reshapingProgress = 0;        // 0 to 1 progress
        this.geometryVerified = false;     // Set true after reshaping completes successfully

        // Auto-detect if this matches a monomer template
        this._detectMonomerType();

        // Check for stable template match and initiate reshaping if needed
        this._checkForStableTemplate();
    }

    /**
     * Get all bonds in this molecule
     */
    get bonds() {
        const bondSet = new Set();
        for (const atom of this.atoms) {
            for (const bond of atom.bonds) {
                // Only include bonds where both atoms are in this molecule
                if (this.atoms.includes(bond.atom1) && this.atoms.includes(bond.atom2)) {
                    bondSet.add(bond);
                }
            }
        }
        return Array.from(bondSet);
    }

    /**
     * Calculate center of mass
     */
    get centerOfMass() {
        if (this.atoms.length === 0) return new Vector2(0, 0);

        let totalMass = 0;
        let weightedPos = new Vector2(0, 0);

        for (const atom of this.atoms) {
            totalMass += atom.mass;
            weightedPos = weightedPos.add(atom.position.mul(atom.mass));
        }

        return weightedPos.div(totalMass);
    }

    /**
     * Calculate total mass
     */
    get mass() {
        return this.atoms.reduce((sum, atom) => sum + atom.mass, 0);
    }

    /**
     * Get center position (alias for centerOfMass for compatibility)
     */
    getCenter() {
        return this.centerOfMass;
    }

    /**
     * Update derived properties
     */
    updateProperties() {
        const oldFormula = this.formula;
        this.formula = this.calculateFormula();
        this.fingerprint = this.calculateFingerprint();

        // If formula changed, geometry needs re-verification
        if (oldFormula && oldFormula !== this.formula) {
            this.geometryVerified = false;
        }
    }

    /**
     * Calculate molecular formula (e.g., "H2O", "CH4")
     */
    calculateFormula() {
        const counts = {};

        for (const atom of this.atoms) {
            counts[atom.symbol] = (counts[atom.symbol] || 0) + 1;
        }

        // Standard ordering: C, H, then alphabetical
        const order = ['C', 'H'];
        const symbols = Object.keys(counts).sort((a, b) => {
            const ai = order.indexOf(a);
            const bi = order.indexOf(b);
            if (ai >= 0 && bi >= 0) return ai - bi;
            if (ai >= 0) return -1;
            if (bi >= 0) return 1;
            return a.localeCompare(b);
        });

        let formula = '';
        for (const symbol of symbols) {
            formula += symbol;
            if (counts[symbol] > 1) {
                formula += counts[symbol];
            }
        }

        return formula;
    }

    /**
     * Calculate a fingerprint for identifying equivalent structures
     */
    calculateFingerprint() {
        // Create a canonical representation
        const atomCounts = {};
        const bondCounts = {};

        for (const atom of this.atoms) {
            atomCounts[atom.symbol] = (atomCounts[atom.symbol] || 0) + 1;
        }

        for (const bond of this.bonds) {
            const symbols = [bond.atom1.symbol, bond.atom2.symbol].sort();
            const key = `${symbols[0]}-${symbols[1]}-${bond.order}`;
            bondCounts[key] = (bondCounts[key] || 0) + 1;
        }

        return JSON.stringify({ atoms: atomCounts, bonds: bondCounts });
    }

    /**
     * Check if molecule has valid valence (all valences satisfied)
     * This is a prerequisite for stability but not sufficient alone.
     */
    hasValidValence() {
        // Need at least 2 atoms to be a molecule
        if (this.atoms.length < 2) return false;

        // Need at least 1 bond
        if (this.bonds.length < 1) return false;

        // All atoms must have their valences satisfied
        for (const atom of this.atoms) {
            if (atom.availableValence > 0) {
                return false;
            }
        }
        return true;
    }

    /**
     * Check if molecule is stable (valences satisfied AND geometry matches known template if applicable)
     * A molecule needs at least 2 atoms, at least 1 bond, and must match its template geometry.
     * If currently reshaping, the molecule is NOT considered stable until reshaping completes.
     */
    isStable() {
        // Basic valence check first
        if (!this.hasValidValence()) {
            if (typeof Debug !== 'undefined' && Debug.shouldLog('molecules', this)) {
                Debug.logMolecule('molecules', 'isStable=FALSE (invalid valence)', this, {
                    atoms: this.atoms.map(a => `${a.symbol}:${a.bondCount}/${a.maxBonds}`)
                });
            }
            return false;
        }

        // If currently reshaping, NOT stable yet - wait for completion
        if (this.isReshaping) return false;

        // If geometry was already verified (after reshaping), skip re-check
        if (this.geometryVerified) return true;

        // Check if this formula matches a known stable template
        if (typeof matchesStableTemplate === 'function') {
            const template = matchesStableTemplate(this);
            if (template) {
                // This molecule matches a known formula - check geometry
                if (typeof needsReshaping === 'function' && needsReshaping(this, template)) {
                    // Geometry doesn't match template - NOT stable
                    if (typeof Debug !== 'undefined' && Debug.shouldLog('reshape', this)) {
                        Debug.logMolecule('reshape', 'isStable=FALSE (needs reshaping)', this, {
                            template: template.name,
                            geometryVerified: this.geometryVerified
                        });
                    }
                    // Start reshaping if not already
                    if (!this.isReshaping) {
                        this.startReshaping(template);
                    }
                    return false;
                }
            }
        }

        return true;
    }

    /**
     * Check if molecule can participate in polymer formation
     * NEW: Only molecules that are known monomers can polymerize.
     * Random stable molecules cannot chain together - that's not how polymers work.
     */
    canPolymerize() {
        // Must have at least 2 atoms to be a molecule
        if (this.atoms.length < 2) return false;

        // Must be stable - unstable molecules can't form polymers
        if (!this.isStable()) return false;

        // NEW: Must be a known monomer type
        // Only molecules that match a monomer template can polymerize
        return this.isMonomer;
    }

    /**
     * Detect if this molecule matches a known monomer template
     * Called automatically when formula is calculated
     */
    _detectMonomerType() {
        // Check if findMonomerByFormula function exists (from monomer-templates.js)
        if (typeof findMonomerByFormula === 'function' && this.formula) {
            const template = findMonomerByFormula(this.formula);
            if (template) {
                this.isMonomer = true;
                this.monomerTemplate = template;
                console.log(`Molecule ${this.formula} detected as monomer: ${template.name}`);
            }
        }
    }

    /**
     * Check if this molecule matches a known stable template
     * If so, initiate reshaping to the stable configuration
     */
    _checkForStableTemplate() {
        // Only check if we're not already reshaping
        if (this.isReshaping) return;

        // Check if matchesStableTemplate function exists (from stable-molecules.js)
        if (typeof matchesStableTemplate !== 'function') return;

        const template = matchesStableTemplate(this);
        if (template && typeof needsReshaping === 'function' && needsReshaping(this, template)) {
            this.startReshaping(template);
        }
    }

    /**
     * Start the reshaping process toward a stable configuration
     * @param {Object} template - The stable molecule template
     */
    startReshaping(template) {
        if (!template) return;

        this.targetTemplate = template;
        this.reshapingTimer = this.reshapingDuration;
        this.isReshaping = true;
        this.reshapingProgress = 0;
        this.geometryVerified = false;  // Clear until reshaping completes

        // Calculate target positions and atom-to-template mapping
        if (typeof getTargetConfiguration === 'function') {
            const config = getTargetConfiguration(this, template);
            this.targetPositions = config.targetPositions;
            this.atomToTemplateIndex = config.atomToTemplateIndex;  // Store mapping for bond restructuring
        }

        if (typeof Debug !== 'undefined') {
            Debug.logMolecule('reshape', `START ‚Üí ${template.name}`, this, {
                mappingSize: this.atomToTemplateIndex?.size,
                templateBonds: template.bonds?.length
            });
        }
    }

    /**
     * Cancel the reshaping process (e.g., when molecule composition changes)
     */
    cancelReshaping() {
        if (this.isReshaping && typeof Debug !== 'undefined') {
            Debug.logMolecule('reshape', 'CANCELLED', this);
        }
        this.targetTemplate = null;
        this.reshapingTimer = null;
        this.isReshaping = false;
        this.reshapingProgress = 0;
        this.targetPositions = null;
        this.atomToTemplateIndex = null;  // Clear the mapping
        this.geometryVerified = false;  // Needs re-verification
    }

    /**
     * Update the reshaping animation
     * @param {number} dt - Delta time
     * @returns {boolean} True if reshaping completed this tick
     */
    updateReshaping(dt) {
        if (!this.isReshaping || !this.targetPositions) return false;

        // Progress the timer
        this.reshapingTimer -= 1;
        this.reshapingProgress = 1 - (this.reshapingTimer / this.reshapingDuration);

        // Apply forces to move atoms toward target positions
        const lerpFactor = 0.05 + (this.reshapingProgress * 0.1); // Accelerate as we progress

        for (const [atom, targetPos] of this.targetPositions) {
            const direction = targetPos.sub(atom.position);
            const distance = direction.length();

            if (distance > 1) {
                // Apply a spring-like force toward target
                const force = direction.normalize().mul(distance * lerpFactor * 2);
                atom.applyForce(force);

                // Also directly lerp position for smoother animation
                atom.position = atom.position.add(direction.mul(lerpFactor));
            }
        }

        // Check if reshaping is complete
        if (this.reshapingTimer <= 0) {
            this.applyStableConfiguration();
            return true;
        }

        return false;
    }

    /**
     * Apply the final stable configuration
     * Snaps atoms to target positions and restructures bonds per template
     */
    applyStableConfiguration() {
        if (!this.targetTemplate || !this.targetPositions) {
            this.cancelReshaping();
            return;
        }

        if (typeof Debug !== 'undefined') {
            Debug.logMolecule('reshape', `COMPLETING ‚Üí ${this.targetTemplate.name}`, this, {
                atomCount: this.atoms.length,
                currentBonds: this.bonds.length,
                templateBonds: this.targetTemplate.bonds?.length
            });
        }

        // Snap atoms to final positions
        for (const [atom, targetPos] of this.targetPositions) {
            atom.position = targetPos;
            atom.velocity = new Vector2(0, 0); // Stop movement
        }

        // Restructure bonds to match template (break wrong bonds, create correct ones)
        this._restructureBonds();

        // Clear reshaping state
        this.isReshaping = false;
        this.reshapingProgress = 1;
        this.reshapingTimer = null;
        this.geometryVerified = true;  // Mark geometry as verified to prevent re-check loop

        // Update properties now that we're stable
        this.updateProperties();

        // Set the name from template
        if (this.targetTemplate.name) {
            this.name = this.targetTemplate.name;
        }

        // Copy monomer flag from template if present
        if (this.targetTemplate.isMonomer) {
            this.isMonomer = true;
        }

        // Final state log
        if (typeof Debug !== 'undefined') {
            Debug.logMolecule('reshape', 'FINISHED - Now stable', this, {
                finalBonds: this.bonds.length,
                isStableNow: this.hasValidValence(),
                geometryVerified: this.geometryVerified,
                atomValences: this.atoms.map(a => `${a.symbol}:${a.bondCount}/${a.maxBonds}`)
            });
        }
    }

    /**
     * Restructure bonds to match the target template
     * This breaks all existing bonds and creates new ones per the template
     * Uses the atomToTemplateIndex mapping computed when reshaping started
     */
    _restructureBonds() {
        if (!this.targetTemplate || !this.targetTemplate.bonds) return;

        const templateBonds = this.targetTemplate.bonds;

        // Use the stored mapping from startReshaping() - this is the SAME mapping
        // that was used to calculate target positions, ensuring consistency
        if (!this.atomToTemplateIndex || this.atomToTemplateIndex.size === 0) {
            if (typeof Debug !== 'undefined') {
                Debug.logMolecule('reshape', 'ERROR: No atom-to-template mapping', this);
            }
            return;
        }

        // Build reverse mapping: template index -> atom
        const templateIndexToAtom = new Map();
        for (const [atom, templateIndex] of this.atomToTemplateIndex) {
            templateIndexToAtom.set(templateIndex, atom);
        }

        if (typeof Debug !== 'undefined') {
            Debug.logMolecule('reshape', 'Restructuring bonds', this, {
                mappedAtoms: this.atomToTemplateIndex.size,
                templateAtoms: this.targetTemplate.atoms?.length
            });
        }

        // Step 1: Break ALL existing bonds in this molecule
        // Use break(false) to not add repulsion energy - we're restructuring, not decaying
        const bondsToBreak = [...this.bonds]; // Copy since we're modifying
        for (const bond of bondsToBreak) {
            if (typeof Debug !== 'undefined') {
                Debug.logBond('BREAK (restructure)', bond, this);
            }
            bond.break(false);  // No energy release during restructure
        }

        // Step 2: Create new bonds exactly per template
        for (const tBond of templateBonds) {
            const atom1 = templateIndexToAtom.get(tBond.atom1);
            const atom2 = templateIndexToAtom.get(tBond.atom2);
            const order = tBond.order || 1;

            if (atom1 && atom2) {
                // Create new bond with correct order
                const bond = new Bond(atom1, atom2, order);

                if (typeof Debug !== 'undefined') {
                    Debug.logBond(`CREATE order:${order}`, bond, this);
                }

                // Note: Bond constructor automatically adds itself to atoms
                // and the Environment will pick it up via syncBonds
            } else {
                if (typeof Debug !== 'undefined') {
                    Debug.logMolecule('reshape', `ERROR: Could not create bond indices ${tBond.atom1}-${tBond.atom2}`, this, {
                        hasAtom1: !!atom1,
                        hasAtom2: !!atom2
                    });
                }
            }
        }

        // Step 3: Verify the new bonds are correct
        const newBonds = this.bonds;
        if (typeof Debug !== 'undefined') {
            Debug.logMolecule('reshape', 'RESTRUCTURE COMPLETE', this, {
                newBondCount: newBonds.length,
                templateBondCount: templateBonds.length,
                match: newBonds.length === templateBonds.length
            });
        }
    }

    /**
     * Get the monomer template this molecule matches, if any
     * @returns {Object|null} Monomer template or null
     */
    getMonomerTemplate() {
        return this.monomerTemplate;
    }

    /**
     * Check if two molecules have the same structure
     * @param {Molecule} other - Other molecule to compare
     */
    isEquivalentTo(other) {
        return this.fingerprint === other.fingerprint;
    }

    /**
     * Apply a force to the entire molecule (distributed by mass)
     * @param {Vector2} force - Force vector
     */
    applyForce(force) {
        const totalMass = this.mass;
        for (const atom of this.atoms) {
            const fraction = atom.mass / totalMass;
            atom.applyForce(force.mul(fraction));
        }
    }

    /**
     * Update all atoms in the molecule
     * @param {number} dt - Delta time
     * @param {Environment} environment - The environment (optional, for intention-aware decay)
     * @returns {object|null} - Returns decay info if atom was released, null otherwise
     */
    update(dt, environment = null) {
        // If molecule is stable and abstracted, skip individual atom physics
        if (this.abstracted && this.isStable()) {
            // Just update center position based on velocity if moving
            return null;
        }

        // Handle reshaping animation (takes priority over decay)
        if (this.isReshaping) {
            const completed = this.updateReshaping(dt);
            if (completed) {
                // Reshaping complete - molecule should now be stable
                return { type: 'reshaped', molecule: this };
            }
            // Don't decay while reshaping
        } else if (!this.isStable()) {
            // isStable() automatically starts reshaping if template match found
            // If we're here and not reshaping, molecule is truly unstable

            // Handle decay for unstable molecules (only if not reshaping)
            if (!this.isReshaping) {
                // Initialize decay timer if not set
                if (this.decayTimer === null) {
                    // Decay time: 100-400 ticks depending on stability (faster decay)
                    const stabilityRatio = this._calculateStabilityRatio();
                    this.decayTimer = 100 + Math.floor(stabilityRatio * 300);
                    this.decayRate = 1;
                }

                // Progress decay
                this.decayTimer -= this.decayRate;

                // Check if it's time to release an atom
                if (this.decayTimer <= 0) {
                    const releasedAtom = this._releaseWeakestAtom(environment);
                    if (releasedAtom) {
                        // Reset timer for next potential decay (faster)
                        this.decayTimer = 80 + Math.floor(Math.random() * 120);
                        return { type: 'decay', atom: releasedAtom };
                    }
                }
            }
        } else {
            // Molecule is truly stable - reset decay timer
            this.decayTimer = null;

            // Auto-abstract stable molecules in polymers for performance
            if (this.polymerId && !this.abstracted) {
                this.abstracted = true;
            }
        }

        // Apply bond spring forces
        for (const bond of this.bonds) {
            bond.applySpringForce(0.8);
        }

        // Update atom positions
        for (const atom of this.atoms) {
            atom.update(dt);
        }

        return null;
    }

    /**
     * Calculate how stable the molecule is (0 = very unstable, 1 = almost stable)
     */
    _calculateStabilityRatio() {
        let filledValences = 0;
        let totalValences = 0;
        for (const atom of this.atoms) {
            totalValences += atom.maxBonds;
            filledValences += atom.bondCount;
        }
        return totalValences > 0 ? filledValences / totalValences : 0;
    }

    /**
     * Release the atom with the weakest bond (most unsatisfied valence)
     * If inside an intention zone, prioritize releasing atoms that are in EXCESS of the target composition
     * @param {Environment} environment - The environment (optional)
     * @returns {Atom|null} - The released atom, or null if none released
     */
    _releaseWeakestAtom(environment = null) {
        // Check if we're inside an intention zone and get composition delta
        let insideIntention = false;
        let excessElements = null;  // Elements we have too many of
        let neededElements = null;  // Elements we need more of or should keep

        if (environment) {
            const center = this.centerOfMass;
            for (const intention of environment.intentions.values()) {
                if (intention.type !== 'molecule') continue;
                if (intention.fulfilled) continue;

                const dist = center.distanceTo(intention.position);
                if (dist < intention.radius) {
                    insideIntention = true;
                    // Get what we need to add/remove to match target
                    const delta = intention.getCompositionDelta(this);
                    if (delta) {
                        if (Object.keys(delta.excess).length > 0) {
                            excessElements = new Set(Object.keys(delta.excess));
                        }
                        // Get target composition to know which elements to KEEP
                        const targetComp = intention.getTargetComposition();
                        if (targetComp) {
                            neededElements = new Set(Object.keys(targetComp));
                        }
                    }
                    break;
                }
            }
        }

        // If inside intention and NO excess elements, don't release anything!
        // Let the molecule try to stabilize with the atoms it has
        if (insideIntention && !excessElements) {
            return null;  // Hold onto all atoms - they're all needed
        }

        // Find atom to release
        // Priority 1: Atoms that are in EXCESS of target composition (if inside intention)
        // Priority 2: Weakest bonded atom that is NOT needed (if inside intention)
        // Priority 3: Weakest bonded atom (only if NOT inside intention)
        let weakestAtom = null;
        let lowestSatisfaction = 1;
        let bestExcessAtom = null;
        let lowestExcessSatisfaction = 1;
        let weakestUnneededAtom = null;
        let lowestUnneededSatisfaction = 1;

        for (const atom of this.atoms) {
            if (atom.bonds.length === 0) continue; // Skip already free atoms
            const satisfaction = atom.bondCount / atom.maxBonds;

            // Track best excess atom (atoms we have too many of)
            if (excessElements && excessElements.has(atom.symbol)) {
                if (satisfaction < lowestExcessSatisfaction) {
                    lowestExcessSatisfaction = satisfaction;
                    bestExcessAtom = atom;
                }
            }

            // Track weakest atom that is NOT needed by the intention
            if (insideIntention && neededElements && !neededElements.has(atom.symbol)) {
                if (satisfaction < lowestUnneededSatisfaction) {
                    lowestUnneededSatisfaction = satisfaction;
                    weakestUnneededAtom = atom;
                }
            }

            // Also track overall weakest (only used outside intentions)
            if (satisfaction < lowestSatisfaction) {
                lowestSatisfaction = satisfaction;
                weakestAtom = atom;
            }
        }

        // Choose which atom to release based on priority
        let atomToRelease = null;
        if (bestExcessAtom) {
            // First priority: release excess atoms
            atomToRelease = bestExcessAtom;
        } else if (insideIntention && weakestUnneededAtom) {
            // Second priority (inside intention): release unneeded atoms
            atomToRelease = weakestUnneededAtom;
        } else if (!insideIntention && weakestAtom) {
            // Third priority (outside intention only): release weakest
            atomToRelease = weakestAtom;
        }
        // If inside intention and all atoms are needed, atomToRelease stays null

        if (atomToRelease && atomToRelease.bonds.length > 0) {
            // Break the weakest bond
            const bondToBreak = atomToRelease.bonds[0];
            bondToBreak.break();

            // Give atom strong velocity away from molecule center
            const center = this.centerOfMass;
            const direction = atomToRelease.position.sub(center).normalize();
            atomToRelease.velocity = direction.mul(15);  // Much stronger push away

            // Mark the atom as repelled from this molecule to prevent immediate re-bonding
            atomToRelease.addRepulsion(this.id, 500);  // Repelled for 500 ticks (longer)

            // Clear molecule reference
            atomToRelease.moleculeId = null;

            return atomToRelease;
        }

        return null;
    }

    /**
     * Restore molecule shape from blueprint reference
     * Repositions atoms to match the original blueprint layout
     * Used for replication and visual consistency of abstracted molecules
     */
    restoreShape() {
        if (!this.blueprintRef || !this.blueprintRef.atomData) return false;

        const center = this.centerOfMass;
        const atomData = this.blueprintRef.atomData;

        // Only restore if we have matching atom count
        if (atomData.length !== this.atoms.length) return false;

        // Reposition atoms to match blueprint relative positions
        for (let i = 0; i < this.atoms.length; i++) {
            const atom = this.atoms[i];
            const data = atomData[i];
            if (atom && data) {
                atom.position.x = center.x + data.relX;
                atom.position.y = center.y + data.relY;
                atom.velocity = new Vector2(0, 0); // Reset velocity
            }
        }

        return true;
    }

    /**
     * Create a copy of this molecule using its blueprint
     * @param {number} x - X position for copy
     * @param {number} y - Y position for copy
     * @returns {Molecule|null} - New molecule instance or null if no blueprint
     */
    replicate(x, y) {
        if (!this.blueprintRef) return null;
        return this.blueprintRef.instantiate(x, y);
    }

    /**
     * Render the molecule at the molecule abstraction level
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {number} scale - Zoom scale
     * @param {Vector2} offset - Camera offset
     */
    render(ctx, scale = 1, offset = { x: 0, y: 0 }) {
        // Draw reshaping indicator if molecule is transitioning
        if (this.isReshaping) {
            this._renderReshapingIndicator(ctx, scale, offset);
        }

        // Draw bonds first (behind atoms)
        for (const bond of this.bonds) {
            bond.render(ctx, scale, offset);
        }

        // Draw atoms
        for (const atom of this.atoms) {
            atom.render(ctx, scale, offset);
        }

        // Draw molecule highlight/selection
        if (this.selected || this.highlighted) {
            this.renderBoundingBox(ctx, scale, offset);
        }
    }

    /**
     * Render visual indicator for reshaping molecules
     */
    _renderReshapingIndicator(ctx, scale, offset) {
        const center = this.centerOfMass;
        const screenX = (center.x + offset.x) * scale;
        const screenY = (center.y + offset.y) * scale;

        // Calculate bounding radius
        let maxDist = 0;
        for (const atom of this.atoms) {
            const dist = atom.position.distanceTo(center) + atom.radius;
            maxDist = Math.max(maxDist, dist);
        }
        const screenRadius = Math.max(30, (maxDist + 10) * scale);

        // Pulsing effect based on progress
        const pulse = Math.sin(Date.now() / 100) * 0.3 + 0.7;

        // Draw reshaping glow
        const gradient = ctx.createRadialGradient(
            screenX, screenY, 0,
            screenX, screenY, screenRadius
        );
        gradient.addColorStop(0, `rgba(34, 197, 94, ${0.4 * pulse})`);  // Green glow
        gradient.addColorStop(0.5, `rgba(34, 197, 94, ${0.2 * pulse})`);
        gradient.addColorStop(1, 'rgba(34, 197, 94, 0)');

        ctx.beginPath();
        ctx.arc(screenX, screenY, screenRadius, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();

        // Draw progress arc
        ctx.beginPath();
        ctx.arc(screenX, screenY, screenRadius * 0.9,
            -Math.PI / 2,
            -Math.PI / 2 + (this.reshapingProgress * Math.PI * 2));
        ctx.strokeStyle = 'rgba(34, 197, 94, 0.8)';
        ctx.lineWidth = 3;
        ctx.stroke();

        // Draw "Reshaping" label
        ctx.fillStyle = '#4ade80';
        ctx.font = `${10 * scale}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        ctx.fillText('Reshaping...', screenX, screenY - screenRadius - 5);
    }

    /**
     * Render at molecule level (simplified view)
     * Uses different colors based on stability:
     * - Stable: Green gradient (solid)
     * - Unstable: Red-orange gradient (pulsing)
     * - Reshaping: Yellow gradient (with progress indicator)
     */
    renderSimplified(ctx, scale = 1, offset = { x: 0, y: 0 }) {
        const center = this.centerOfMass;
        const screenX = (center.x + offset.x) * scale;
        const screenY = (center.y + offset.y) * scale;

        // Calculate bounding radius
        let maxDist = 0;
        for (const atom of this.atoms) {
            const dist = atom.position.distanceTo(center) + atom.radius;
            maxDist = Math.max(maxDist, dist);
        }
        const screenRadius = Math.max(20, maxDist * scale);

        // Determine stability state and colors
        const isStable = this.isStable();
        const isReshaping = this.isReshaping;

        let colorInner, colorOuter, strokeColor;
        let pulseMultiplier = 1;

        if (isReshaping) {
            // Reshaping: Yellow/gold gradient
            colorInner = 'rgba(234, 179, 8, 0.7)';   // yellow-500
            colorOuter = 'rgba(202, 138, 4, 0.4)';   // yellow-600
            strokeColor = 'rgba(234, 179, 8, 0.8)';
        } else if (isStable) {
            // Stable: Green gradient
            colorInner = 'rgba(34, 197, 94, 0.6)';   // green-500
            colorOuter = 'rgba(22, 163, 74, 0.3)';   // green-600
            strokeColor = 'rgba(34, 197, 94, 0.7)';
        } else {
            // Unstable: Red-orange gradient with pulse
            pulseMultiplier = 0.7 + Math.sin(Date.now() / 200) * 0.3;
            colorInner = `rgba(249, 115, 22, ${0.6 * pulseMultiplier})`;  // orange-500
            colorOuter = `rgba(239, 68, 68, ${0.3 * pulseMultiplier})`;   // red-500
            strokeColor = `rgba(249, 115, 22, ${0.7 * pulseMultiplier})`;
        }

        // Draw molecule blob
        ctx.beginPath();
        ctx.arc(screenX, screenY, screenRadius, 0, Math.PI * 2);

        const gradient = ctx.createRadialGradient(
            screenX - screenRadius * 0.3,
            screenY - screenRadius * 0.3,
            0,
            screenX,
            screenY,
            screenRadius
        );
        gradient.addColorStop(0, colorInner);
        gradient.addColorStop(1, colorOuter);

        ctx.fillStyle = gradient;
        ctx.fill();

        // Stroke style based on state
        if (this.selected) {
            ctx.strokeStyle = isStable ? '#22c55e' : '#f97316';
            ctx.lineWidth = 3;
            ctx.setLineDash([]);
        } else if (!isStable && !isReshaping) {
            // Unstable molecules get dashed stroke
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = 2;
            ctx.setLineDash([4, 4]);
        } else {
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = 1;
            ctx.setLineDash([]);
        }
        ctx.stroke();
        ctx.setLineDash([]);

        // Draw decay indicator for unstable molecules
        if (!isStable && !isReshaping && this.decayTimer !== null) {
            const decayProgress = this.decayTimer / (100 + 300); // Approximate max decay time
            const decayRadius = screenRadius + 5;

            // Draw decay arc (depleting)
            ctx.beginPath();
            ctx.arc(screenX, screenY, decayRadius,
                -Math.PI / 2,
                -Math.PI / 2 + (decayProgress * Math.PI * 2));
            ctx.strokeStyle = 'rgba(239, 68, 68, 0.5)';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // Draw formula label
        if (screenRadius > 15) {
            ctx.fillStyle = '#FFFFFF';
            ctx.font = `bold ${Math.max(10, screenRadius * 0.4)}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(this.formula, screenX, screenY);
        }

        // Draw stability indicator icon
        if (screenRadius > 25) {
            const iconY = screenY + screenRadius * 0.5;
            ctx.font = `${Math.max(8, screenRadius * 0.25)}px sans-serif`;
            ctx.textAlign = 'center';
            if (isReshaping) {
                ctx.fillText('‚ü≥', screenX, iconY);
            } else if (isStable) {
                ctx.fillText('‚úì', screenX, iconY);
            } else {
                ctx.fillText('!', screenX, iconY);
            }
        }
    }


    /**
     * Render bounding box for selection
     */
    renderBoundingBox(ctx, scale, offset) {
        const bounds = this.getBounds();
        const padding = 10;

        const x = (bounds.minX + offset.x) * scale - padding;
        const y = (bounds.minY + offset.y) * scale - padding;
        const w = (bounds.maxX - bounds.minX) * scale + padding * 2;
        const h = (bounds.maxY - bounds.minY) * scale + padding * 2;

        ctx.strokeStyle = this.selected ? '#6366f1' : '#8b5cf6';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.strokeRect(x, y, w, h);
        ctx.setLineDash([]);
    }

    /**
     * Get bounding box
     */
    getBounds() {
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;

        for (const atom of this.atoms) {
            minX = Math.min(minX, atom.position.x - atom.radius);
            minY = Math.min(minY, atom.position.y - atom.radius);
            maxX = Math.max(maxX, atom.position.x + atom.radius);
            maxY = Math.max(maxY, atom.position.y + atom.radius);
        }

        return { minX, minY, maxX, maxY };
    }

    /**
     * Check if point is inside molecule (also checks blob area for level 2+ selection)
     */
    containsPoint(x, y, scale = 1, offset = { x: 0, y: 0 }) {
        // Check individual atoms
        for (const atom of this.atoms) {
            if (atom.containsPoint(x, y, scale, offset)) {
                return true;
            }
        }

        // Also check the blob area (for molecule level selection)
        const center = this.centerOfMass;
        const screenX = (center.x + offset.x) * scale;
        const screenY = (center.y + offset.y) * scale;

        // Calculate bounding radius (same as renderSimplified)
        let maxDist = 0;
        for (const atom of this.atoms) {
            const dist = atom.position.distanceTo(center) + atom.radius;
            maxDist = Math.max(maxDist, dist);
        }
        const screenRadius = Math.max(20, maxDist * scale);

        const dx = x - screenX;
        const dy = y - screenY;
        if (dx * dx + dy * dy <= screenRadius * screenRadius) {
            return true;
        }

        return false;
    }

    /**
     * Serialize molecule to plain object
     */
    serialize() {
        return {
            id: this.id,
            name: this.name,
            formula: this.formula,
            atoms: this.atoms.map(a => a.serialize()),
            bonds: this.bonds.map(b => b.serialize())
        };
    }

    /**
     * Create molecule from serialized data
     */
    static deserialize(data) {
        // Recreate atoms
        const atomMap = new Map();
        const atoms = data.atoms.map(atomData => {
            const atom = Atom.deserialize(atomData);
            atomMap.set(atom.id, atom);
            return atom;
        });

        // Recreate bonds
        data.bonds.forEach(bondData => {
            Bond.deserialize(bondData, atomMap);
        });

        const molecule = new Molecule(atoms);
        molecule.id = data.id;
        molecule.name = data.name;

        return molecule;
    }
}

/**
 * Find connected atom groups using BFS
 * @param {Atom[]} atoms - Array of atoms
 * @returns {Atom[][]} Array of connected groups
 */
function findConnectedGroups(atoms) {
    const visited = new Set();
    const groups = [];

    for (const startAtom of atoms) {
        if (visited.has(startAtom)) continue;

        const group = [];
        const queue = [startAtom];

        while (queue.length > 0) {
            const atom = queue.shift();
            if (visited.has(atom)) continue;

            visited.add(atom);
            group.push(atom);

            for (const bond of atom.bonds) {
                const other = bond.getOther(atom);
                if (!visited.has(other) && atoms.includes(other)) {
                    queue.push(other);
                }
            }
        }

        if (group.length > 0) {
            groups.push(group);
        }
    }

    return groups;
}

/**
 * Create molecules from a set of atoms
 * @param {Atom[]} atoms - Array of atoms
 * @returns {Molecule[]} Array of molecules
 */
function createMoleculesFromAtoms(atoms) {
    const groups = findConnectedGroups(atoms);
    return groups.map(group => new Molecule(group));
}

// Make available globally
window.Molecule = Molecule;
window.findConnectedGroups = findConnectedGroups;
window.createMoleculesFromAtoms = createMoleculesFromAtoms;


// ==== src/entities/polymer.js ====
/**
 * Polymer / Biomolecule
 * Chains of molecules with functional properties
 * Level 3 in the abstraction hierarchy
 * 
 * Polymer Types:
 * - LIPID: Fatty acid chains (membranes)
 * - CARBOHYDRATE: Sugar chains (energy)
 * - PROTEIN: Amino acid chains (structure/enzymes)
 * - NUCLEIC_ACID: Nucleotide chains (DNA/RNA)
 */

// Polymer type constants
const PolymerType = {
    GENERIC: 'generic',
    LIPID: 'lipid',
    CARBOHYDRATE: 'carbohydrate',
    PROTEIN: 'protein',
    NUCLEIC_ACID: 'nucleic_acid'
};

// Type colors for visualization
const PolymerColors = {
    generic: { primary: '#8b5cf6', secondary: '#a78bfa' },     // Purple
    lipid: { primary: '#eab308', secondary: '#fde047' },       // Yellow/Gold
    carbohydrate: { primary: '#22c55e', secondary: '#86efac' }, // Green
    protein: { primary: '#3b82f6', secondary: '#93c5fd' },     // Blue
    nucleic_acid: { primary: '#ef4444', secondary: '#fca5a5' }  // Red
};

// Type labels for display
const PolymerLabels = {
    generic: 'Polymer',
    lipid: 'Lipid',
    carbohydrate: 'Carbohydrate',
    protein: 'Protein',
    nucleic_acid: 'Nucleic Acid'
};

class Polymer {
    /**
     * Create a polymer from monomer molecules
     * @param {Molecule[]} monomers - Array of identical monomer molecules forming the chain
     * @param {Object} monomerTemplate - The monomer template all molecules must match
     * @param {string} name - Optional name for this polymer
     */
    constructor(monomers = [], monomerTemplate = null, name = null) {
        this.id = Utils.generateId();
        this.monomers = monomers;       // The monomer units (renamed from 'molecules')
        this.molecules = monomers;       // Backward compatibility alias
        this.name = name;
        this.monomerTemplate = monomerTemplate;

        // Type comes from monomer template, or detect if not provided
        if (monomerTemplate && monomerTemplate.polymerCategory) {
            this.type = monomerTemplate.polymerCategory;
        } else {
            this.type = this._detectType();
        }

        // Link monomers to this polymer
        for (const mon of monomers) {
            mon.proteinId = this.id;  // Using proteinId for backward compatibility
            mon.polymerId = this.id;
        }

        // Polymer properties
        this.activeSites = [];  // Functional regions
        this.folded = false;
        this.foldPattern = null;  // 2D shape after folding

        // Stability and bonding
        this.isSealed = false;        // When true, internal atoms can't bond externally
        this.bondedPolymers = [];     // Polymer-polymer connections
        this.chainLevel = 1;          // How many polymers in this chain
        this.cellRole = null;         // Role in cell: 'membrane', 'structure', 'genetics', etc.

        // Selection state
        this.selected = false;
        this.highlighted = false;

        // Calculate derived properties
        this._updateProperties();

        // Assign cell role from monomer template if available
        if (monomerTemplate?.cellRole) {
            this.cellRole = monomerTemplate.cellRole;
        } else {
            this._assignCellRole();
        }
    }

    /**
     * Check if this polymer is valid (all monomers match the template)
     */
    isValid() {
        if (this.monomers.length < 2) return false;

        // If we have a template, all monomers must match
        if (this.monomerTemplate) {
            return this.monomers.every(m =>
                m.formula === this.monomerTemplate.formula
            );
        }

        // Without template, all monomers must at least have the same formula
        const firstFormula = this.monomers[0]?.formula;
        return this.monomers.every(m => m.formula === firstFormula);
    }

    /**
     * Detect polymer type based on molecule composition
     */
    _detectType() {
        if (this.molecules.length === 0) return PolymerType.GENERIC;

        // Count elements across all molecules
        const elementCounts = { C: 0, H: 0, O: 0, N: 0, P: 0, S: 0 };
        let totalAtoms = 0;

        for (const mol of this.molecules) {
            for (const atom of mol.atoms) {
                const symbol = atom.symbol;
                if (elementCounts[symbol] !== undefined) {
                    elementCounts[symbol]++;
                }
                totalAtoms++;
            }
        }

        // Calculate ratios
        const C = elementCounts.C || 0;
        const H = elementCounts.H || 0;
        const O = elementCounts.O || 0;
        const N = elementCounts.N || 0;
        const P = elementCounts.P || 0;

        // Classification heuristics

        // Nucleic Acid: Has phosphorus and nitrogen (DNA/RNA backbone)
        if (P > 0 && N > 0) {
            return PolymerType.NUCLEIC_ACID;
        }

        // Protein/Amino Acid: Has nitrogen but no phosphorus
        if (N > 0 && P === 0) {
            return PolymerType.PROTEIN;
        }

        // Carbohydrate: C:H:O ratio approximately 1:2:1
        if (C > 0 && H > 0 && O > 0 && N === 0 && P === 0) {
            const hToC = H / C;
            const oToC = O / C;
            if (hToC >= 1.5 && hToC <= 2.5 && oToC >= 0.5 && oToC <= 1.5) {
                return PolymerType.CARBOHYDRATE;
            }
        }

        // Lipid: High C:H ratio, low O, no N (fatty acids)
        if (C > 0 && H > 0 && N === 0 && P === 0) {
            const hToC = H / C;
            const oToC = O / (C || 1);
            if (hToC >= 1.8 && oToC < 0.5) {
                return PolymerType.LIPID;
            }
        }

        return PolymerType.GENERIC;
    }

    /**
     * Seal the polymer - internal atoms can no longer bond externally
     * This prevents the polymer from breaking apart or merging improperly
     */
    seal() {
        this.isSealed = true;

        // Mark all internal atoms as sealed
        for (const mol of this.molecules) {
            for (const atom of mol.atoms) {
                atom.isSealed = true;
            }
        }

        // Set cell role based on type
        this._assignCellRole();

        console.log(`Polymer ${this.name || this.type} sealed`);
    }

    /**
     * Assign cell role based on polymer type
     */
    _assignCellRole() {
        switch (this.type) {
            case PolymerType.LIPID:
                this.cellRole = 'membrane';
                break;
            case PolymerType.PROTEIN:
                this.cellRole = 'structure';
                break;
            case PolymerType.NUCLEIC_ACID:
                this.cellRole = 'genetics';
                break;
            case PolymerType.CARBOHYDRATE:
                this.cellRole = 'energy';
                break;
            default:
                this.cellRole = null;
        }
    }

    /**
     * Check if this polymer can bond with another polymer
     * Same-type polymers can chain, complementary types can combine for cells
     */
    canBondWithPolymer(other) {
        if (!other || other === this) return false;
        if (!this.isSealed || !other.isSealed) return false;

        // Same type polymers can chain
        if (this.type === other.type) return true;

        // Complementary types for cell formation
        return this.isComplementary(other);
    }

    /**
     * Check if another polymer type is complementary for cell formation
     */
    isComplementary(other) {
        const complementaryPairs = [
            [PolymerType.LIPID, PolymerType.PROTEIN],
            [PolymerType.PROTEIN, PolymerType.NUCLEIC_ACID],
            [PolymerType.LIPID, PolymerType.NUCLEIC_ACID]
        ];

        for (const [a, b] of complementaryPairs) {
            if ((this.type === a && other.type === b) ||
                (this.type === b && other.type === a)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Bond this polymer with another polymer
     */
    bondWithPolymer(other) {
        if (!this.canBondWithPolymer(other)) return false;

        if (!this.bondedPolymers.includes(other)) {
            this.bondedPolymers.push(other);
            other.bondedPolymers.push(this);

            // Update chain level
            this.chainLevel += other.chainLevel;
            other.chainLevel = this.chainLevel;

            console.log(`Polymer chain formed: ${this.name || this.type} + ${other.name || other.type} (chain level: ${this.chainLevel})`);
        }
        return true;
    }

    /**
     * Check if polymer chain is ready to form a cell
     * Requires membrane, structure, and genetics
     */
    canFormCell() {
        if (this.chainLevel < 3) return false;

        const roles = new Set([this.cellRole]);
        for (const bonded of this.bondedPolymers) {
            roles.add(bonded.cellRole);
        }

        return roles.has('membrane') && roles.has('structure') && roles.has('genetics');
    }

    /**
     * Update derived properties
     */
    _updateProperties() {
        // Calculate total mass
        this.mass = this.molecules.reduce((sum, mol) => sum + mol.mass, 0);

        // Generate sequence (chain of molecule formulas)
        this.sequence = this.molecules.map(m => m.formula).join('-');

        // Generate unique fingerprint
        this.fingerprint = this._generateFingerprint();
    }

    /**
     * Generate unique fingerprint for this polymer
     */
    _generateFingerprint() {
        const typePrefix = this.type.toUpperCase().substring(0, 3);
        const parts = this.molecules.map(m => m.fingerprint).sort();
        return `${typePrefix}:${parts.join('|')}`;
    }

    /**
     * Get the display color for this polymer's type
     */
    getColor() {
        return PolymerColors[this.type] || PolymerColors.generic;
    }

    /**
     * Get the display label for this polymer's type
     */
    getLabel() {
        return PolymerLabels[this.type] || 'Polymer';
    }

    /**
     * Add a molecule to the chain
     * @param {Molecule} molecule - Molecule to add
     */
    addMolecule(molecule) {
        molecule.proteinId = this.id;
        this.molecules.push(molecule);
        this._updateProperties();
        // Re-detect type with new molecule
        this.type = this._detectType();
    }

    /**
     * Remove a molecule from the chain
     * @param {string} moleculeId - ID of molecule to remove
     */
    removeMolecule(moleculeId) {
        const index = this.molecules.findIndex(m => m.id === moleculeId);
        if (index !== -1) {
            this.molecules[index].proteinId = null;
            this.molecules.splice(index, 1);
            this._updateProperties();
        }
    }

    /**
     * Define an active site on this polymer
     * @param {object} site - Active site definition
     */
    addActiveSite(site) {
        this.activeSites.push({
            id: Utils.generateId(),
            moleculeIndices: site.moleculeIndices || [],
            type: site.type || 'catalytic',
            specificity: site.specificity || [],
            strength: site.strength || 1.0
        });
    }

    /**
     * Fold the polymer into a 2D shape
     */
    fold() {
        if (this.molecules.length < 2) return;

        this.folded = true;
        const center = this.getCenter();
        const numMols = this.molecules.length;
        const spacing = 50;

        this.foldPattern = [];

        for (let i = 0; i < numMols; i++) {
            const angle = i * 0.8;
            const radius = spacing * (1 + i * 0.3);

            this.foldPattern.push({
                moleculeId: this.molecules[i].id,
                relativeX: Math.cos(angle) * radius,
                relativeY: Math.sin(angle) * radius
            });
        }
    }

    /**
     * Unfold the polymer (linearize)
     */
    unfold() {
        this.folded = false;
        this.foldPattern = null;
    }

    /**
     * Get the center position of the polymer
     */
    getCenter() {
        if (this.molecules.length === 0) {
            return new Vector2(0, 0);
        }

        let sumX = 0, sumY = 0;
        for (const mol of this.molecules) {
            const molCenter = mol.getCenter();
            sumX += molCenter.x;
            sumY += molCenter.y;
        }

        return new Vector2(
            sumX / this.molecules.length,
            sumY / this.molecules.length
        );
    }

    /**
     * Check if the polymer is stable
     */
    isStable() {
        if (this.molecules.length < 2) return false;
        return this.molecules.every(m => m.isStable());
    }

    /**
     * Check if this polymer can catalyze a reaction
     */
    canCatalyze(substrates) {
        for (const site of this.activeSites) {
            if (site.type === 'catalytic') {
                const matches = substrates.filter(s =>
                    site.specificity.includes(s.formula) ||
                    site.specificity.includes('*')
                );
                if (matches.length > 0) return true;
            }
        }
        return false;
    }

    /**
     * Apply forces to maintain structure
     */
    applyForces(dt) {
        for (let i = 0; i < this.molecules.length - 1; i++) {
            const mol1 = this.molecules[i];
            const mol2 = this.molecules[i + 1];

            const center1 = mol1.getCenter();
            const center2 = mol2.getCenter();

            const dx = center2.x - center1.x;
            const dy = center2.y - center1.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            const targetDist = 80;
            const stiffness = 0.05;

            if (dist > 0) {
                const forceMag = (dist - targetDist) * stiffness;
                const fx = (dx / dist) * forceMag;
                const fy = (dy / dist) * forceMag;

                for (const atom of mol1.atoms) {
                    atom.velocity.x += fx * dt;
                    atom.velocity.y += fy * dt;
                }
                for (const atom of mol2.atoms) {
                    atom.velocity.x -= fx * dt;
                    atom.velocity.y -= fy * dt;
                }
            }
        }
    }

    /**
     * Update all molecules
     */
    update(dt) {
        this.applyForces(dt);
        for (const mol of this.molecules) {
            mol.update(dt);
        }
    }

    /**
     * Render the polymer
     */
    render(ctx, level, camera) {
        if (this.molecules.length === 0) return;

        const colors = this.getColor();

        if (level <= 1) {
            this._renderChainConnections(ctx, camera, colors);
            for (const mol of this.molecules) {
                mol.render(ctx, level, camera);
            }
        } else if (level === 2) {
            this._renderAsPolymer(ctx, camera, colors);
        } else {
            this._renderAsBlob(ctx, camera, colors);
        }
    }

    /**
     * Render chain connections between molecules
     */
    _renderChainConnections(ctx, camera, colors) {
        if (this.molecules.length < 2) return;

        ctx.save();
        ctx.strokeStyle = this.selected ? '#f59e0b' : colors.primary;
        ctx.lineWidth = 3 / camera.zoom;
        ctx.setLineDash([5, 5]);

        ctx.beginPath();
        for (let i = 0; i < this.molecules.length - 1; i++) {
            const center1 = this.molecules[i].getCenter();
            const center2 = this.molecules[i + 1].getCenter();

            ctx.moveTo((center1.x - camera.x) * camera.zoom, (center1.y - camera.y) * camera.zoom);
            ctx.lineTo((center2.x - camera.x) * camera.zoom, (center2.y - camera.y) * camera.zoom);
        }
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();
    }

    /**
     * Render as polymer structure
     */
    _renderAsPolymer(ctx, camera, colors) {
        const center = this.getCenter();
        const screenX = (center.x - camera.x) * camera.zoom;
        const screenY = (center.y - camera.y) * camera.zoom;

        ctx.save();

        // Draw connections
        ctx.strokeStyle = colors.primary;
        ctx.lineWidth = 4 / camera.zoom;
        ctx.beginPath();

        for (let i = 0; i < this.molecules.length - 1; i++) {
            const c1 = this.molecules[i].getCenter();
            const c2 = this.molecules[i + 1].getCenter();
            ctx.moveTo((c1.x - camera.x) * camera.zoom, (c1.y - camera.y) * camera.zoom);
            ctx.lineTo((c2.x - camera.x) * camera.zoom, (c2.y - camera.y) * camera.zoom);
        }
        ctx.stroke();

        // Draw molecule blobs
        for (const mol of this.molecules) {
            const mc = mol.getCenter();
            const mx = (mc.x - camera.x) * camera.zoom;
            const my = (mc.y - camera.y) * camera.zoom;
            const radius = 20 * camera.zoom;

            ctx.beginPath();
            ctx.arc(mx, my, radius, 0, Math.PI * 2);
            ctx.fillStyle = this.highlighted ? colors.secondary + 'aa' : colors.primary + '66';
            ctx.fill();
            ctx.strokeStyle = this.selected ? '#f59e0b' : colors.primary;
            ctx.stroke();
        }

        // Draw label with type
        const label = this.name || `${this.getLabel()} (${this.molecules.length})`;
        ctx.fillStyle = '#e8e8f0';
        ctx.font = `${12 * camera.zoom}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.fillText(label, screenX, screenY + 40 * camera.zoom);

        ctx.restore();
    }

    /**
     * Render as simplified blob
     */
    _renderAsBlob(ctx, camera, colors) {
        const center = this.getCenter();
        const screenX = (center.x - camera.x) * camera.zoom;
        const screenY = (center.y - camera.y) * camera.zoom;
        const radius = (15 + this.molecules.length * 5) * camera.zoom;

        ctx.save();

        // Outer glow
        const gradient = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, radius);
        gradient.addColorStop(0, colors.primary + 'cc');
        gradient.addColorStop(0.7, colors.primary + '4d');
        gradient.addColorStop(1, colors.primary + '00');

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(screenX, screenY, radius, 0, Math.PI * 2);
        ctx.fill();

        // Core
        ctx.fillStyle = this.highlighted ? colors.secondary : colors.primary;
        ctx.beginPath();
        ctx.arc(screenX, screenY, radius * 0.6, 0, Math.PI * 2);
        ctx.fill();

        if (this.selected) {
            ctx.strokeStyle = '#f59e0b';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        ctx.restore();
    }

    /**
     * Serialize polymer for storage
     */
    serialize() {
        return {
            id: this.id,
            name: this.name,
            type: this.type,
            moleculeIds: this.molecules.map(m => m.id),
            activeSites: this.activeSites,
            folded: this.folded,
            fingerprint: this.fingerprint
        };
    }

    /**
     * Get all atoms in this polymer
     */
    getAllAtoms() {
        const atoms = [];
        for (const mol of this.molecules) {
            atoms.push(...mol.atoms);
        }
        return atoms;
    }

    /**
     * Get all bonds in this polymer
     */
    getAllBonds() {
        const bonds = [];
        for (const mol of this.molecules) {
            bonds.push(...mol.bonds);
        }
        return bonds;
    }
}

/**
 * Create polymers from nearby molecules of the same monomer type
 * NEW: Only molecules with the same formula (same monomer type) can form a polymer
 * @param {Molecule[]} molecules - All molecules
 * @param {number} maxDistance - Max distance for molecules to form a polymer
 * @returns {Polymer[]} New polymers found
 */
function findPotentialPolymers(molecules, maxDistance = 100) {
    const polymers = [];
    const assigned = new Set();

    for (const mol of molecules) {
        if (assigned.has(mol.id) || mol.proteinId || mol.polymerId) continue;
        if (!mol.isStable()) continue;

        // NEW: Only monomers can form polymers
        if (!mol.canPolymerize || !mol.canPolymerize()) continue;

        // Get the monomer type for this molecule
        const monomerFormula = mol.formula;
        const monomerTemplate = mol.monomerTemplate || null;

        // Find nearby molecules of the SAME monomer type
        const chain = [mol];
        assigned.add(mol.id);

        let current = mol;
        let found = true;

        while (found) {
            found = false;

            // Defensive check for getCenter method
            if (!current || typeof current.getCenter !== 'function') break;

            const currentCenter = current.getCenter();

            for (const other of molecules) {
                if (assigned.has(other.id) || other.proteinId || other.polymerId) continue;
                if (!other.isStable || !other.isStable()) continue;
                if (typeof other.getCenter !== 'function') continue;

                // NEW: Must be the same monomer type (same formula)
                if (other.formula !== monomerFormula) continue;

                const otherCenter = other.getCenter();
                const dist = Utils.distance(
                    currentCenter.x, currentCenter.y,
                    otherCenter.x, otherCenter.y
                );

                if (dist < maxDistance) {
                    chain.push(other);
                    assigned.add(other.id);
                    current = other;
                    found = true;
                    break;
                }
            }
        }

        // Only create polymer if we have a chain of 2+ molecules of the same type
        if (chain.length >= 2) {
            const polymer = new Polymer(chain, monomerTemplate, monomerTemplate?.polymerName || null);
            polymers.push(polymer);
            console.log(`Formed polymer: ${chain.length} x ${monomerFormula} ‚Üí ${polymer.name || polymer.type}`);
        }
    }

    return polymers;
}

// Backward compatibility aliases
const Protein = Polymer;
const findPotentialProteins = findPotentialPolymers;

// Make available globally
window.PolymerType = PolymerType;
window.PolymerColors = PolymerColors;
window.PolymerLabels = PolymerLabels;
window.Polymer = Polymer;
window.Protein = Protein;  // Backward compatibility
window.findPotentialPolymers = findPotentialPolymers;
window.findPotentialProteins = findPotentialProteins;  // Backward compatibility


// ==== src/entities/intention.js ====
/**
 * Intention Entity
 * Represents a blueprint intention zone that attracts required components
 * to form molecules, polymers, or cells organically
 */

class Intention {
    /**
     * Create a new intention zone
     * @param {string} type - 'molecule', 'polymer', or 'cell'
     * @param {Object} blueprint - The blueprint to fulfill
     * @param {number} x - X position
     * @param {number} y - Y position
     */
    constructor(type, blueprint, x, y) {
        this.id = Utils.generateId();
        this.type = type;
        this.blueprint = blueprint;
        this.position = new Vector2(x, y);

        // Attraction properties
        this.radius = this._getRadiusByType();
        this.attractionForce = 3.0; // Strong attraction force
        this.repulsionForce = 8.0; // Very strong repulsion to push away unwanted entities quickly

        // Progress tracking
        this.progress = 0;
        this.gatheredComponents = new Set();
        this.fulfilled = false;
        this.createdEntity = null;

        // Timing
        this.age = 0;
        this.maxAge = 10000; // Timeout after 10000 ticks if not fulfilled
        this.createdAt = Date.now(); // Timestamp for when intention was created

        // Exclusion list: molecules that existed before this intention was placed
        // These should be ignored when checking for completion
        this.excludedMoleculeIds = new Set();
        this.exclusionInitialized = false;

        // Visual state
        this.pulsePhase = 0;
        this.selected = false;
    }

    /**
     * Initialize the exclusion list with currently existing molecules
     * Call this once after adding the intention to the environment
     * @param {Environment} environment - The environment to scan
     */
    initializeExclusions(environment) {
        if (this.exclusionInitialized) return;

        // Record all existing molecules that would match our requirements
        if (this.type === 'molecule') {
            const requirements = this.getRequirements();
            if (requirements && requirements.type === 'atoms' && requirements.count) {
                for (const mol of environment.molecules.values()) {
                    // Exclude all molecules that match our atom count requirement
                    if (mol.atoms.length === requirements.count) {
                        this.excludedMoleculeIds.add(mol.id);
                    }
                }
            }
        }

        this.exclusionInitialized = true;
        if (typeof Debug !== 'undefined' && Debug.shouldLog('intentions')) {
            console.log(`Intention ${this.id.substring(0, 8)} initialized with ${this.excludedMoleculeIds.size} excluded molecules`);
        }
    }

    /**
     * Get appropriate radius based on intention type
     * This is the attraction range - entities within this distance will be pulled
     */
    _getRadiusByType() {
        switch (this.type) {
            case 'molecule': return 300;  // Large range to attract atoms
            case 'polymer': return 400;   // Even larger for molecules
            case 'cell': return 500;      // Largest for polymers
            default: return 300;
        }
    }

    /**
     * Get the target element composition for molecule intentions
     * @returns {Object} - Map of element symbol to count, e.g., { C: 2, H: 4 }
     */
    getTargetComposition() {
        if (this.type !== 'molecule') return null;
        
        const composition = {};
        
        if (this.blueprint.atomData) {
            for (const atom of this.blueprint.atomData) {
                composition[atom.symbol] = (composition[atom.symbol] || 0) + 1;
            }
        }
        
        return composition;
    }

    /**
     * Get the element composition for polymer intentions (from monomer template)
     * @returns {Set} - Set of element symbols needed for the monomer
     */
    getMonomerElements() {
        if (this.type !== 'polymer') return null;
        
        const requirements = this.getRequirements();
        const elements = new Set();
        
        // Get elements from monomer template's atomLayout
        if (requirements.monomerTemplate && requirements.monomerTemplate.atomLayout) {
            for (const atom of requirements.monomerTemplate.atomLayout) {
                elements.add(atom.symbol);
            }
        }
        
        // Fallback to requiredElements if no atomLayout
        if (elements.size === 0 && requirements.requiredElements) {
            for (const el of requirements.requiredElements) {
                elements.add(el);
            }
        }
        
        return elements;
    }

    /**
     * Calculate what changes a molecule needs to become the target molecule
     * @param {Molecule} molecule - The molecule to compare
     * @returns {Object} - { needed: { H: 2 }, excess: { O: 1 }, isMatch: false }
     */
    getCompositionDelta(molecule) {
        if (this.type !== 'molecule') return null;
        
        const target = this.getTargetComposition();
        if (!target) return null;
        
        // Get current molecule composition
        const current = {};
        for (const atom of molecule.atoms) {
            current[atom.symbol] = (current[atom.symbol] || 0) + 1;
        }
        
        const needed = {};  // Atoms we need to add
        const excess = {};  // Atoms we need to remove
        
        // Check what's needed (in target but not enough in current)
        for (const [symbol, count] of Object.entries(target)) {
            const have = current[symbol] || 0;
            if (have < count) {
                needed[symbol] = count - have;
            }
        }
        
        // Check what's in excess (in current but not needed or too many)
        for (const [symbol, count] of Object.entries(current)) {
            const want = target[symbol] || 0;
            if (count > want) {
                excess[symbol] = count - want;
            }
        }
        
        const isMatch = Object.keys(needed).length === 0 && Object.keys(excess).length === 0;
        
        return { needed, excess, isMatch };
    }

    /**
     * Get required components based on blueprint
     */
    getRequirements() {
        if (this.type === 'molecule') {
            // For molecules, we need specific atoms
            // Extract elements from atomData if available
            let elements = this.blueprint.requiredElements;
            if (!elements && this.blueprint.atomData) {
                const elementSet = new Set();
                for (const atom of this.blueprint.atomData) {
                    elementSet.add(atom.symbol);
                }
                elements = Array.from(elementSet);
            }
            return {
                type: 'atoms',
                elements: elements || ['C'],
                count: this.blueprint.atomData?.length || 4
            };
        } else if (this.type === 'polymer') {
            // For polymers, we need specific MONOMERS (identical molecules that chain)
            // NEW: Use monomer template system
            const monomerTemplate = this.blueprint.monomerTemplate || null;
            const monomerId = this.blueprint.monomerId || null;

            // Resolve monomer template if we have an ID but no template yet
            let resolvedTemplate = monomerTemplate;
            if (!resolvedTemplate && monomerId && typeof getMonomerTemplate === 'function') {
                resolvedTemplate = getMonomerTemplate(monomerId);
            }

            return {
                type: 'monomers',
                count: this.blueprint.minMonomers || this.blueprint.minMolecules || 3,
                monomerId: monomerId,
                monomerTemplate: resolvedTemplate,
                monomerFormula: resolvedTemplate?.formula || null,
                monomerName: resolvedTemplate?.name || this.blueprint.name || 'Unknown',
                requiredElements: this.blueprint.requiredElements || resolvedTemplate?.requiredElements || []
            };
        } else if (this.type === 'cell') {
            // For cells, we need polymer chains
            return {
                type: 'polymers',
                roles: ['membrane', 'structure', 'genetics']
            };
        }
        return null;
    }

    /**
     * Update intention state
     * @param {Environment} environment - The environment
     * @param {number} dt - Delta time
     */
    update(environment, dt) {
        this.age++;
        this.pulsePhase += 0.05;

        // NOTE: No timeout - intentions persist until fulfilled or manually deleted
        // (Bug #6 fix from AGENTS.md)

        // Find and attract nearby components
        this._attractComponents(environment);

        // Check if requirements are met
        this._checkCompletion(environment);
    }

    /**
     * Attract nearby components toward this intention
     */
    _attractComponents(environment) {
        const requirements = this.getRequirements();
        if (!requirements) return;

        if (requirements.type === 'atoms') {
            const targetComp = this.getTargetComposition();
            const neededElements = targetComp ? new Set(Object.keys(targetComp)) : null;
            
            // Attract free atoms AND atoms in unstable molecules
            for (const atom of environment.atoms.values()) {
                // Check if atom is in a molecule
                if (atom.moleculeId) {
                    const mol = environment.molecules.get(atom.moleculeId);
                    if (mol) {
                        // Skip atoms in stable molecules - they're done
                        if (mol.isStable()) continue;
                        // CRITICAL: Skip atoms in reshaping molecules - don't disturb geometry
                        if (mol.isReshaping) continue;
                    }
                }

                const dist = atom.position.distanceTo(this.position);
                if (dist < this.radius && dist > 5) {
                    const direction = this.position.sub(atom.position).normalize();
                    let forceMagnitude = this.attractionForce * (1 - dist / this.radius);
                    
                    // Smart attraction: attract needed elements, repel unneeded
                    if (neededElements) {
                        if (neededElements.has(atom.symbol)) {
                            // This element is needed - stronger attraction
                            forceMagnitude *= 1.5;
                        } else {
                            // This element is NOT in the target - repel away FAST
                            // Use strong repulsion with minimum force to ensure it works even with overlapping intentions
                            const repelStrength = Math.max(this.repulsionForce * (1 - dist / this.radius), this.repulsionForce * 0.3);
                            const repelForce = direction.mul(-repelStrength);
                            atom.applyForce(repelForce);
                            continue; // Skip normal force application
                        }
                    }
                    
                    const force = direction.mul(forceMagnitude);
                    atom.applyForce(force);
                    // Note: gatheredComponents is now managed in progress calculation
                }
            }

            // Also attract unstable molecules as a whole (moves all their atoms)
            // BUT: Don't move molecules that are currently reshaping - let them finish!
            for (const mol of environment.molecules.values()) {
                // Skip stable molecules - they don't need attraction
                if (mol.isStable()) continue;
                
                // CRITICAL: Skip molecules that are reshaping - moving them will break geometry
                if (mol.isReshaping) continue;

                const center = mol.getCenter ? mol.getCenter() : mol.centerOfMass;
                const dist = center.distanceTo(this.position);
                if (dist < this.radius && dist > 10) {
                    const direction = this.position.sub(center).normalize();
                    // Strong force for unstable molecules - pull them in quickly
                    const force = direction.mul(this.attractionForce * 2.0 * (1 - dist / this.radius));
                    mol.applyForce(force);
                }
            }

            // Repel only fully stable molecules that don't match the target formula
            // Unstable molecules with useful atoms should NOT be repelled - let them transform
            const targetFormula = this.blueprint ? this.blueprint.formula : null;
            for (const mol of environment.molecules.values()) {
                // Skip molecules that are still reshaping (let them finish)
                if (mol.isReshaping) continue;
                
                // If this molecule IS the target formula, don't repel it
                if (targetFormula && mol.formula === targetFormula) continue;
                
                // Only repel STABLE molecules - unstable molecules may still transform
                if (!mol.isStable()) continue;
                
                const center = mol.getCenter ? mol.getCenter() : mol.centerOfMass;
                const dist = center.distanceTo(this.position);
                if (dist < this.radius && dist > 10) {
                    const direction = this.position.sub(center).normalize();
                    // Very strong repulsion for unrelated stable molecules
                    // Use minimum force to ensure repulsion works even with overlapping intentions
                    const repelStrength = Math.max(this.repulsionForce * (1 - dist / this.radius), this.repulsionForce * 0.3);
                    const repelForce = direction.mul(-repelStrength);
                    mol.applyForce(repelForce);
                }
            }
        } else if (requirements.type === 'molecules') {
            // Attract molecules (that aren't in polymers)
            for (const mol of environment.molecules.values()) {
                // Skip molecules already in polymers
                if (mol.polymerId) continue;

                const center = mol.getCenter();
                const dist = center.distanceTo(this.position);
                if (dist < this.radius && dist > 10) {
                    const direction = this.position.sub(center).normalize();
                    const force = direction.mul(this.attractionForce * (1 - dist / this.radius));
                    mol.applyForce(force);
                    // Note: gatheredComponents is now managed in progress calculation
                }
            }
        } else if (requirements.type === 'monomers') {
            // Attract only molecules that match the required monomer formula
            const requiredFormula = requirements.monomerFormula;
            const monomerElements = this.getMonomerElements();

            // Repel free atoms that are not part of the monomer formula
            for (const atom of environment.atoms.values()) {
                // Skip atoms in molecules
                if (atom.moleculeId) continue;
                
                const dist = atom.position.distanceTo(this.position);
                if (dist < this.radius && dist > 5) {
                    const direction = this.position.sub(atom.position).normalize();
                    
                    if (monomerElements && monomerElements.has(atom.symbol)) {
                        // This element is part of the monomer - attract it
                        const force = direction.mul(this.attractionForce * 0.8 * (1 - dist / this.radius));
                        atom.applyForce(force);
                    } else {
                        // This element is NOT part of the monomer - repel it fast
                        const repelStrength = Math.max(this.repulsionForce * (1 - dist / this.radius), this.repulsionForce * 0.3);
                        const repelForce = direction.mul(-repelStrength);
                        atom.applyForce(repelForce);
                    }
                }
            }

            for (const mol of environment.molecules.values()) {
                // Skip molecules already in polymers
                if (mol.polymerId) continue;

                const center = mol.getCenter();
                const dist = center.distanceTo(this.position);
                
                // Check if this is the right monomer type
                const isCorrectMonomer = mol.isMonomer && 
                    (!requiredFormula || mol.formula === requiredFormula);
                
                if (dist < this.radius && dist > 10) {
                    const direction = this.position.sub(center).normalize();
                    
                    if (isCorrectMonomer) {
                        // Attract correct monomers
                        const force = direction.mul(this.attractionForce * (1 - dist / this.radius));
                        mol.applyForce(force);
                    } else if (mol.isStable()) {
                        // Only repel STABLE molecules that are NOT the required monomer
                        // Unstable molecules may still transform into the needed monomer
                        const repelStrength = Math.max(this.repulsionForce * (1 - dist / this.radius), this.repulsionForce * 0.3);
                        const repelForce = direction.mul(-repelStrength);
                        mol.applyForce(repelForce);
                    }
                    // Note: gatheredComponents is now managed in progress calculation
                }
            }
        } else if (requirements.type === 'polymers') {
            // Attract polymers
            for (const polymer of environment.proteins.values()) {
                const center = polymer.getCenter();
                const dist = center.distanceTo(this.position);
                if (dist < this.radius && dist > 20) {
                    const direction = this.position.sub(center).normalize();
                    // Polymers move slower
                    for (const mol of polymer.molecules) {
                        mol.applyForce(direction.mul(this.attractionForce * 0.5));
                    }
                    // Note: gatheredComponents is now managed in progress calculation
                }
            }
        }

        // Update progress based on components in/near the zone
        const requirements2 = this.getRequirements();
        if (requirements2.type === 'atoms' && requirements2.count) {
            // Count only RELEVANT atoms in zone (matching target composition)
            const targetComp = this.getTargetComposition();
            const neededElements = targetComp ? new Set(Object.keys(targetComp)) : null;
            
            let relevantAtomsInZone = 0;
            // Clear and rebuild gatheredComponents each frame
            this.gatheredComponents.clear();
            
            for (const atom of environment.atoms.values()) {
                const dist = atom.position.distanceTo(this.position);
                if (dist < this.radius * 0.6) {
                    // Only count atoms that are relevant to the target molecule
                    if (!neededElements || neededElements.has(atom.symbol)) {
                        relevantAtomsInZone++;
                        this.gatheredComponents.add(atom.id);
                    }
                }
            }
            this.progress = Math.min(1, relevantAtomsInZone / requirements2.count);
        } else if (requirements2.type === 'monomers' && requirements2.count) {
            // Count matching monomers in zone
            let monomersInZone = 0;
            const requiredFormula = requirements2.monomerFormula;
            
            // Clear and rebuild gatheredComponents each frame
            this.gatheredComponents.clear();

            for (const mol of environment.molecules.values()) {
                if (mol.polymerId) continue;
                if (!mol.isMonomer) continue;
                if (requiredFormula && mol.formula !== requiredFormula) continue;

                const dist = mol.getCenter().distanceTo(this.position);
                if (dist < this.radius * 0.6) {
                    monomersInZone++;
                    this.gatheredComponents.add(mol.id);
                }
            }
            this.progress = Math.min(1, monomersInZone / requirements2.count);
        } else if (requirements2.count) {
            // For other types, also rebuild gatheredComponents
            this.gatheredComponents.clear();
            // Progress will be updated by the specific type handler
            this.progress = 0;
        }
    }

    /**
     * Check if intention can be fulfilled
     */
    _checkCompletion(environment) {
        const requirements = this.getRequirements();
        if (!requirements) return;

        if (requirements.type === 'atoms' && requirements.count) {
            // Check if there's a matching molecule in the zone
            // OR if we have enough free atoms to form one

            // First check for existing molecules that match our requirements
            // Skip molecules that existed before this intention was placed
            for (const mol of environment.molecules.values()) {
                if (mol.polymerId) continue;

                // IMPORTANT: Skip molecules that existed before this intention was created
                if (this.excludedMoleculeIds.has(mol.id)) continue;

                // CRITICAL: Skip molecules already claimed by another intention
                // This prevents overlapping intentions from all being fulfilled by the same molecule
                if (mol.claimedByIntentionId && mol.claimedByIntentionId !== this.id) continue;

                // CRITICAL: Molecule must be STABLE before we count it as complete
                // This ensures the molecule has finished reshaping and won't become unstable
                if (!mol.isStable()) continue;

                // CRITICAL: Molecule must not be in the middle of reshaping
                // Wait for it to complete its transformation to the stable form
                if (mol.isReshaping) continue;

                // If geometry is already verified, trust it - don't re-check
                // This prevents constant re-triggering of reshaping
                if (!mol.geometryVerified) {
                    // Only check geometry for molecules that haven't been verified yet
                    if (typeof matchesStableTemplate === 'function' && typeof needsReshaping === 'function') {
                        const template = matchesStableTemplate(mol);
                        if (template && needsReshaping(mol, template)) {
                            // Molecule has wrong geometry - trigger reshaping and wait
                            mol.startReshaping(template);
                            continue;
                        }
                    }
                }

                const center = mol.getCenter ? mol.getCenter() : mol.centerOfMass;
                const dist = center.distanceTo(this.position);
                if (dist < this.radius * 0.6) {
                    // CRITICAL: Validate formula matches blueprint, not just atom count
                    // This prevents unrelated molecules from fulfilling the intention
                    const blueprintFormula = this.blueprint.formula;
                    if (blueprintFormula && mol.formula === blueprintFormula) {
                        // Mark intention as fulfilled - correct stable molecule formed!
                        // CRITICAL: Claim the molecule so other overlapping intentions can't use it
                        mol.claimedByIntentionId = this.id;
                        this.createdEntity = mol;
                        this.fulfilled = true;
                        if (typeof Debug !== 'undefined' && Debug.shouldLog('intentions')) {
                            console.log(`[Intention ${this.id.substring(0, 8)}] Fulfilled: Stable molecule ${mol.formula} matches blueprint`);
                        }
                        return;
                    }
                    // If no formula in blueprint, fall back to atom count check (legacy)
                    else if (!blueprintFormula && mol.atoms.length === requirements.count) {
                        // CRITICAL: Claim the molecule so other overlapping intentions can't use it
                        mol.claimedByIntentionId = this.id;
                        this.createdEntity = mol;
                        this.fulfilled = true;
                        if (typeof Debug !== 'undefined' && Debug.shouldLog('intentions')) {
                            console.log(`[Intention ${this.id.substring(0, 8)}] Fulfilled: New stable molecule ${mol.formula} formed (atom count match)`);
                        }
                        return;
                    }
                }
            }

            // If no matching molecule, check for free atoms
            const nearbyAtoms = [];
            for (const atom of environment.atoms.values()) {
                if (atom.moleculeId) continue;
                const dist = atom.position.distanceTo(this.position);
                if (dist < this.radius * 0.5) {
                    nearbyAtoms.push(atom);
                }
            }

            if (nearbyAtoms.length >= requirements.count) {
                // Form the molecule!
                this._formMolecule(environment, nearbyAtoms.slice(0, requirements.count));
            }
        } else if (requirements.type === 'molecules' && requirements.count) {
            // Check if we have enough molecules nearby
            const nearbyMolecules = [];
            for (const mol of environment.molecules.values()) {
                if (mol.polymerId) continue;
                // CRITICAL: Skip molecules already claimed by another intention
                if (mol.claimedByIntentionId && mol.claimedByIntentionId !== this.id) continue;
                const dist = mol.getCenter().distanceTo(this.position);
                if (dist < this.radius * 0.5) {
                    nearbyMolecules.push(mol);
                }
            }

            if (nearbyMolecules.length >= requirements.count) {
                // Form the polymer!
                this._formPolymer(environment, nearbyMolecules.slice(0, requirements.count));
            }
        } else if (requirements.type === 'monomers' && requirements.count) {
            // NEW: Check for matching monomer molecules
            const requiredFormula = requirements.monomerFormula;
            const nearbyMonomers = [];

            for (const mol of environment.molecules.values()) {
                if (mol.polymerId) continue;
                if (!mol.isMonomer) continue;
                if (requiredFormula && mol.formula !== requiredFormula) continue;
                // CRITICAL: Skip molecules already claimed by another intention
                if (mol.claimedByIntentionId && mol.claimedByIntentionId !== this.id) continue;

                const dist = mol.getCenter().distanceTo(this.position);
                if (dist < this.radius * 0.5) {
                    nearbyMonomers.push(mol);
                }
            }

            if (nearbyMonomers.length >= requirements.count) {
                // Form the polymer from monomers!
                this._formPolymerFromMonomers(environment, nearbyMonomers.slice(0, requirements.count), requirements.monomerTemplate);
            }
        } else if (requirements.type === 'polymers') {
            // Check if we have required polymer types
            const nearbyPolymers = { membrane: null, structure: null, genetics: null };
            for (const polymer of environment.proteins.values()) {
                // CRITICAL: Skip polymers already claimed by another intention
                if (polymer.claimedByIntentionId && polymer.claimedByIntentionId !== this.id) continue;
                const dist = polymer.getCenter().distanceTo(this.position);
                if (dist < this.radius * 0.6) {
                    const role = polymer.cellRole || polymer.type;
                    if (role === 'membrane' || role === 'lipid') nearbyPolymers.membrane = polymer;
                    if (role === 'structure' || role === 'protein') nearbyPolymers.structure = polymer;
                    if (role === 'genetics' || role === 'nucleic_acid') nearbyPolymers.genetics = polymer;
                }
            }

            if (nearbyPolymers.membrane && nearbyPolymers.structure && nearbyPolymers.genetics) {
                // Form the cell!
                this._formCell(environment, Object.values(nearbyPolymers).filter(p => p));
            }
        }
    }

    /**
     * Form a molecule from gathered atoms
     */
    _formMolecule(environment, atoms) {
        // Sort atoms: heavier atoms (C, N, O) first as potential centers
        atoms.sort((a, b) => b.mass - a.mass);

        // Try to bond atoms intelligently
        // For molecules like CH4, bond all H to the central C
        const centralAtom = atoms[0]; // Heaviest atom as center

        for (let i = 1; i < atoms.length; i++) {
            const atom = atoms[i];

            // First try to bond to central atom
            if (centralAtom.availableValence > 0 && atom.availableValence > 0 && !centralAtom.isBondedTo(atom)) {
                const bond = new Bond(centralAtom, atom);
                environment.addBond(bond);
            } else {
                // If central is full, try to bond to previous atoms
                for (let j = 0; j < i; j++) {
                    const other = atoms[j];
                    if (other.availableValence > 0 && atom.availableValence > 0 && !other.isBondedTo(atom)) {
                        const bond = new Bond(other, atom);
                        environment.addBond(bond);
                        break;
                    }
                }
            }
        }

        // Only create molecule from atoms that actually have bonds
        const bondedAtoms = atoms.filter(a => a.bonds.length > 0);

        if (bondedAtoms.length < 2) {
            if (typeof Debug !== 'undefined' && Debug.shouldLog('intentions')) {
                console.log(`[Intention ${this.id.substring(0, 8)}] Not enough bonded atoms to form molecule`);
            }
            return; // Don't fulfill - try again next tick
        }

        // Create molecule from bonded atoms only
        const molecule = new Molecule(bondedAtoms);
        environment.addMolecule(molecule);

        // CRITICAL: Validate the formed molecule matches our blueprint formula
        // If wrong molecule formed, don't fulfill - keep trying
        const blueprintFormula = this.blueprint.formula;
        if (blueprintFormula && molecule.formula !== blueprintFormula) {
            if (typeof Debug !== 'undefined' && Debug.shouldLog('intentions')) {
                console.log(`[Intention ${this.id.substring(0, 8)}] Formed ${molecule.formula} but need ${blueprintFormula}, continuing...`);
            }
            return; // Don't fulfill - wrong molecule formed
        }

        // CRITICAL: Do NOT fulfill here!
        // We just created bonds - the molecule may not be stable yet.
        // The _checkCompletion loop above will verify stability and fulfill.
        // Just log that molecule was formed - completion check will handle the rest.
        if (typeof Debug !== 'undefined' && Debug.shouldLog('intentions')) {
            console.log(`[Intention ${this.id.substring(0, 8)}] Created molecule ${molecule.formula}, waiting for stability...`);
        }
    }

    /**
     * Form a polymer from gathered molecules
     */
    _formPolymer(environment, molecules) {
        // Validate molecules can polymerize - they need available valence (open bonds)
        const polymerizableMolecules = molecules.filter(mol => {
            // Check if any atom in the molecule has available valence
            for (const atom of mol.atoms) {
                if (atom.availableValence > 0) {
                    return true; // This molecule can bind
                }
            }
            if (typeof Debug !== 'undefined' && Debug.shouldLog('intentions')) {
                console.log(`[Intention ${this.id.substring(0, 8)}] Molecule ${mol.formula} cannot polymerize - no available valence`);
            }
            return false;
        });

        if (polymerizableMolecules.length < 2) {
            if (typeof Debug !== 'undefined' && Debug.shouldLog('intentions')) {
                console.log(`[Intention ${this.id.substring(0, 8)}] Cannot form polymer: need at least 2 molecules with available valence`);
            }
            return; // Don't form polymer
        }

        // Mark molecules as part of polymer and claim them
        const polymerId = Utils.generateId();
        polymerizableMolecules.forEach(mol => {
            mol.polymerId = polymerId;
            mol.claimedByIntentionId = this.id;  // Claim so other intentions don't double-count
        });

        // Create polymer
        const polymer = new Polymer(polymerizableMolecules, this.blueprint.type, this.blueprint.name);
        polymer.seal(); // Seal the polymer so internal atoms can't bond externally
        environment.addProtein(polymer);

        this.createdEntity = polymer;
        this.fulfilled = true;

        if (typeof Debug !== 'undefined' && Debug.shouldLog('intentions')) {
            console.log(`[Intention ${this.id.substring(0, 8)}] Fulfilled: Created polymer ${polymer.name || polymer.type}`);
        }
    }

    /**
     * Form a polymer chain from monomer molecules
     * NEW: Uses monomer template system for proper chain creation
     * @param {Environment} environment 
     * @param {Molecule[]} monomers - Identical monomer molecules to chain
     * @param {Object} monomerTemplate - The monomer template defining polymerization
     */
    _formPolymerFromMonomers(environment, monomers, monomerTemplate) {
        if (monomers.length < 2) {
            if (typeof Debug !== 'undefined' && Debug.shouldLog('intentions')) {
                console.log(`[Intention ${this.id.substring(0, 8)}] Cannot form polymer: need at least 2 monomers`);
            }
            return;
        }

        const monomerName = monomerTemplate?.name || monomers[0]?.formula || 'Unknown';
        if (typeof Debug !== 'undefined' && Debug.shouldLog('intentions')) {
            console.log(`[Intention ${this.id.substring(0, 8)}] Forming polymer from ${monomers.length} ${monomerName} monomers`);
        }

        // Create polymer with monomer template
        const polymer = new Polymer(monomers, monomerTemplate, this.blueprint.name);

        // Mark molecules as part of polymer and claim them
        monomers.forEach(mol => {
            mol.polymerId = polymer.id;
            mol.claimedByIntentionId = this.id;  // Claim so other intentions don't double-count
        });

        // Handle polymerization type
        if (monomerTemplate?.polymerizationType === 'condensation') {
            // Condensation polymerization releases water molecules
            const waterCount = monomers.length - 1; // n-1 water released
            if (typeof Debug !== 'undefined' && Debug.shouldLog('intentions')) {
                console.log(`[Intention ${this.id.substring(0, 8)}] Condensation polymerization: ${waterCount} H2O molecules released (conceptually)`);
            }
            // Note: Could actually spawn water molecules here if desired
        } else if (monomerTemplate?.polymerizationType === 'addition') {
            if (typeof Debug !== 'undefined' && Debug.shouldLog('intentions')) {
                console.log(`[Intention ${this.id.substring(0, 8)}] Addition polymerization: double bonds opened to form chain`);
            }
        }

        // Seal polymer to prevent external bonding
        polymer.seal();

        // Add to environment
        environment.addProtein(polymer);

        this.createdEntity = polymer;
        this.fulfilled = true;

        if (typeof Debug !== 'undefined' && Debug.shouldLog('intentions')) {
            console.log(`[Intention ${this.id.substring(0, 8)}] Polymer created: ${polymer.name || polymer.type} from ${monomers.length} ${monomerName} monomers`);
        }
    }

    /**
     * Form a cell from gathered polymers
     */
    _formCell(environment, polymers) {
        // Create cell at this position
        const cell = new Cell(this.position.x, this.position.y);

        // Add polymers to cell and claim them
        for (const polymer of polymers) {
            polymer.claimedByIntentionId = this.id;  // Claim so other intentions don't double-count
            cell.addPolymer(polymer);
            environment.removeProtein(polymer.id);
        }

        environment.addCell(cell);

        this.createdEntity = cell;
        this.fulfilled = true;

        if (typeof Debug !== 'undefined' && Debug.shouldLog('intentions')) {
            console.log(`[Intention ${this.id.substring(0, 8)}] Fulfilled: Created cell from ${polymers.length} polymers`);
        }
    }

    /**
     * Render the intention zone
     */
    render(ctx, scale = 1, offset = { x: 0, y: 0 }) {
        const screenX = (this.position.x + offset.x) * scale;
        const screenY = (this.position.y + offset.y) * scale;
        const screenRadius = this.radius * scale;

        // Pulsing effect
        const pulse = Math.sin(this.pulsePhase) * 0.2 + 0.8;

        // Get color based on type
        const colors = this._getColors();

        // Draw attraction radius (dashed circle)
        ctx.beginPath();
        ctx.arc(screenX, screenY, screenRadius, 0, Math.PI * 2);
        ctx.setLineDash([10, 5]);
        ctx.strokeStyle = colors.border;
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.setLineDash([]);

        // Draw glow effect
        const gradient = ctx.createRadialGradient(
            screenX, screenY, 0,
            screenX, screenY, screenRadius
        );
        gradient.addColorStop(0, colors.glowInner);
        gradient.addColorStop(0.5, colors.glowMid);
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

        ctx.beginPath();
        ctx.arc(screenX, screenY, screenRadius, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.globalAlpha = 0.3 * pulse;
        ctx.fill();
        ctx.globalAlpha = 1;

        // Draw progress ring
        if (this.progress > 0) {
            ctx.beginPath();
            ctx.arc(screenX, screenY, screenRadius * 0.9, -Math.PI / 2, -Math.PI / 2 + this.progress * Math.PI * 2);
            ctx.strokeStyle = colors.progress;
            ctx.lineWidth = 4;
            ctx.stroke();
        }

        // Draw center icon/preview
        this._renderPreview(ctx, screenX, screenY, scale, pulse, colors);

        // Draw label
        ctx.fillStyle = colors.text;
        ctx.font = `bold ${12 * scale}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillText(this.blueprint.name || this.type, screenX, screenY + screenRadius * 0.6);

        // Draw progress percentage
        ctx.font = `${10 * scale}px sans-serif`;
        ctx.fillText(`${Math.round(this.progress * 100)}%`, screenX, screenY + screenRadius * 0.6 + 15);
    }

    /**
     * Render preview of target entity
     */
    _renderPreview(ctx, screenX, screenY, scale, pulse, colors) {
        const previewRadius = 20 * scale * pulse;

        ctx.beginPath();
        ctx.arc(screenX, screenY, previewRadius, 0, Math.PI * 2);
        ctx.fillStyle = colors.preview;
        ctx.globalAlpha = 0.5;
        ctx.fill();
        ctx.globalAlpha = 1;

        // Draw icon based on type
        ctx.fillStyle = '#FFFFFF';
        ctx.font = `${16 * scale}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        const icons = { molecule: '&#9883;', polymer: '&#128279;', cell: '&#9678;' };
        ctx.fillText(this.type === 'molecule' ? 'M' : this.type === 'polymer' ? 'P' : 'C', screenX, screenY);
    }

    /**
     * Get colors based on intention type
     */
    _getColors() {
        switch (this.type) {
            case 'molecule':
                return {
                    border: 'rgba(139, 92, 246, 0.6)',
                    glowInner: 'rgba(139, 92, 246, 0.4)',
                    glowMid: 'rgba(139, 92, 246, 0.2)',
                    progress: '#8b5cf6',
                    preview: 'rgba(139, 92, 246, 0.6)',
                    text: '#a78bfa'
                };
            case 'polymer':
                return {
                    border: 'rgba(34, 197, 94, 0.6)',
                    glowInner: 'rgba(34, 197, 94, 0.4)',
                    glowMid: 'rgba(34, 197, 94, 0.2)',
                    progress: '#22c55e',
                    preview: 'rgba(34, 197, 94, 0.6)',
                    text: '#4ade80'
                };
            case 'cell':
                return {
                    border: 'rgba(59, 130, 246, 0.6)',
                    glowInner: 'rgba(59, 130, 246, 0.4)',
                    glowMid: 'rgba(59, 130, 246, 0.2)',
                    progress: '#3b82f6',
                    preview: 'rgba(59, 130, 246, 0.6)',
                    text: '#60a5fa'
                };
            default:
                return {
                    border: 'rgba(255, 255, 255, 0.4)',
                    glowInner: 'rgba(255, 255, 255, 0.2)',
                    glowMid: 'rgba(255, 255, 255, 0.1)',
                    progress: '#ffffff',
                    preview: 'rgba(255, 255, 255, 0.4)',
                    text: '#ffffff'
                };
        }
    }

    /**
     * Check if point is inside intention zone (for selection)
     * Uses small hitbox around center icon, not the full attraction radius
     */
    containsPoint(x, y, scale = 1, offset = { x: 0, y: 0 }) {
        const screenX = (this.position.x + offset.x) * scale;
        const screenY = (this.position.y + offset.y) * scale;
        // Use small hitbox radius (matches the center icon size) instead of full attraction radius
        const hitboxRadius = 25 * scale;

        const dx = x - screenX;
        const dy = y - screenY;
        return (dx * dx + dy * dy) <= (hitboxRadius * hitboxRadius);
    }
}

// Make available globally
window.Intention = Intention;


// ==== src/systems/atom-spawner.js ====
/**
 * AtomSpawner
 * System that automatically spawns random atoms in a defined zone
 */

class AtomSpawner {
    /**
     * Create a new atom spawner
     * @param {Environment} environment - The environment to spawn atoms in
     */
    constructor(environment) {
        this.environment = environment;
        this.id = Utils.generateId();
        
        // Spawner state
        this.active = false;
        this.tickInterval = 60;  // Ticks between spawns (default: 1 per second at 60fps)
        this.tickCounter = 0;
        
        // Atom pool - which atoms can be spawned
        this.atomPool = ['H', 'C', 'N', 'O'];  // Default pool
        
        // Spawn zone (in world coordinates)
        // Default: center of environment, 400x400 area
        const centerX = environment.width / 2;
        const centerY = environment.height / 2;
        this.zone = {
            x: centerX - 200,
            y: centerY - 200,
            width: 400,
            height: 400
        };
        
        // UI state for zone resizing
        this.resizing = false;
        this.resizeEdge = null;  // 'n', 's', 'e', 'w', 'ne', 'nw', 'se', 'sw'
        this.resizeStartMouse = { x: 0, y: 0 };
        this.resizeStartZone = { x: 0, y: 0, width: 0, height: 0 };
        
        // Visual settings
        this.zoneColor = 'rgba(16, 185, 129, 0.3)';  // Green tint
        this.zoneBorderColor = 'rgba(16, 185, 129, 0.8)';
        this.handleSize = 10;
    }
    
    /**
     * Toggle spawner on/off
     */
    toggle() {
        this.active = !this.active;
        this.tickCounter = 0;
        return this.active;
    }
    
    /**
     * Set spawner active state
     * @param {boolean} active - Whether spawner is active
     */
    setActive(active) {
        this.active = active;
        if (active) {
            this.tickCounter = 0;
        }
    }
    
    /**
     * Set tick interval between spawns
     * @param {number} ticks - Number of ticks between spawns
     */
    setTickInterval(ticks) {
        this.tickInterval = Math.max(1, Math.floor(ticks));
    }
    
    /**
     * Set the atom pool
     * @param {string[]} atoms - Array of element symbols
     */
    setAtomPool(atoms) {
        if (atoms && atoms.length > 0) {
            this.atomPool = atoms.slice();
        }
    }
    
    /**
     * Set the spawn zone
     * @param {number} x - Zone X position
     * @param {number} y - Zone Y position
     * @param {number} width - Zone width
     * @param {number} height - Zone height
     */
    setZone(x, y, width, height) {
        this.zone.x = Math.max(0, x);
        this.zone.y = Math.max(0, y);
        this.zone.width = Math.max(50, width);
        this.zone.height = Math.max(50, height);
        
        // Clamp to environment bounds
        if (this.zone.x + this.zone.width > this.environment.width) {
            this.zone.x = this.environment.width - this.zone.width;
        }
        if (this.zone.y + this.zone.height > this.environment.height) {
            this.zone.y = this.environment.height - this.zone.height;
        }
    }
    
    /**
     * Update spawner - called every simulation tick
     * @param {number} dt - Delta time
     */
    update(dt) {
        if (!this.active) return;
        
        this.tickCounter++;
        
        if (this.tickCounter >= this.tickInterval) {
            this.tickCounter = 0;
            this._spawnAtom();
        }
    }
    
    /**
     * Spawn a random atom in the zone
     */
    _spawnAtom() {
        if (this.atomPool.length === 0) return;
        
        // Pick random atom type
        const symbol = this.atomPool[Math.floor(Math.random() * this.atomPool.length)];
        
        // Pick random position in zone
        const x = this.zone.x + Math.random() * this.zone.width;
        const y = this.zone.y + Math.random() * this.zone.height;
        
        // Create and add atom
        const atom = new Atom(symbol, x, y);
        this.environment.addAtom(atom);
    }
    
    /**
     * Render the spawn zone
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {number} scale - Zoom scale
     * @param {object} offset - Camera offset
     */
    render(ctx, scale, offset) {
        if (!this.active) return;
        
        const screenX = (this.zone.x + offset.x) * scale;
        const screenY = (this.zone.y + offset.y) * scale;
        const screenWidth = this.zone.width * scale;
        const screenHeight = this.zone.height * scale;
        
        // Draw zone fill
        ctx.fillStyle = this.zoneColor;
        ctx.fillRect(screenX, screenY, screenWidth, screenHeight);
        
        // Draw zone border
        ctx.strokeStyle = this.zoneBorderColor;
        ctx.lineWidth = 2;
        ctx.setLineDash([8, 4]);
        ctx.strokeRect(screenX, screenY, screenWidth, screenHeight);
        ctx.setLineDash([]);
        
        // Draw resize handles
        this._renderResizeHandles(ctx, screenX, screenY, screenWidth, screenHeight);
        
        // Draw spawn indicator icon
        this._renderSpawnIcon(ctx, screenX, screenY, screenWidth, screenHeight);
    }
    
    /**
     * Render resize handles at corners and edges
     */
    _renderResizeHandles(ctx, x, y, w, h) {
        const hs = this.handleSize;
        const halfHs = hs / 2;
        
        ctx.fillStyle = this.zoneBorderColor;
        
        // Corner handles
        const corners = [
            { x: x - halfHs, y: y - halfHs, edge: 'nw' },
            { x: x + w - halfHs, y: y - halfHs, edge: 'ne' },
            { x: x - halfHs, y: y + h - halfHs, edge: 'sw' },
            { x: x + w - halfHs, y: y + h - halfHs, edge: 'se' }
        ];
        
        for (const corner of corners) {
            ctx.fillRect(corner.x, corner.y, hs, hs);
        }
        
        // Edge handles (midpoints)
        const edges = [
            { x: x + w / 2 - halfHs, y: y - halfHs, edge: 'n' },
            { x: x + w / 2 - halfHs, y: y + h - halfHs, edge: 's' },
            { x: x - halfHs, y: y + h / 2 - halfHs, edge: 'w' },
            { x: x + w - halfHs, y: y + h / 2 - halfHs, edge: 'e' }
        ];
        
        for (const edge of edges) {
            ctx.fillRect(edge.x, edge.y, hs, hs);
        }
    }
    
    /**
     * Render spawn indicator
     */
    _renderSpawnIcon(ctx, x, y, w, h) {
        const centerX = x + w / 2;
        const centerY = y + 20;
        
        ctx.save();
        ctx.font = '14px sans-serif';
        ctx.fillStyle = this.zoneBorderColor;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('‚öõÔ∏è Spawner Zone', centerX, centerY);
        ctx.restore();
    }
    
    /**
     * Check if a screen point is on a resize handle
     * @param {number} screenX - Screen X
     * @param {number} screenY - Screen Y
     * @param {number} scale - Camera scale
     * @param {object} offset - Camera offset
     * @returns {string|null} - Edge identifier or null
     */
    getResizeHandleAt(screenX, screenY, scale, offset) {
        if (!this.active) return null;
        
        const zx = (this.zone.x + offset.x) * scale;
        const zy = (this.zone.y + offset.y) * scale;
        const zw = this.zone.width * scale;
        const zh = this.zone.height * scale;
        const hs = this.handleSize;
        const halfHs = hs / 2;
        
        // Check corners first (they have priority)
        const corners = [
            { x: zx - halfHs, y: zy - halfHs, edge: 'nw' },
            { x: zx + zw - halfHs, y: zy - halfHs, edge: 'ne' },
            { x: zx - halfHs, y: zy + zh - halfHs, edge: 'sw' },
            { x: zx + zw - halfHs, y: zy + zh - halfHs, edge: 'se' }
        ];
        
        for (const corner of corners) {
            if (screenX >= corner.x && screenX <= corner.x + hs &&
                screenY >= corner.y && screenY <= corner.y + hs) {
                return corner.edge;
            }
        }
        
        // Check edges
        const edges = [
            { x: zx + zw / 2 - halfHs, y: zy - halfHs, edge: 'n' },
            { x: zx + zw / 2 - halfHs, y: zy + zh - halfHs, edge: 's' },
            { x: zx - halfHs, y: zy + zh / 2 - halfHs, edge: 'w' },
            { x: zx + zw - halfHs, y: zy + zh / 2 - halfHs, edge: 'e' }
        ];
        
        for (const edge of edges) {
            if (screenX >= edge.x && screenX <= edge.x + hs &&
                screenY >= edge.y && screenY <= edge.y + hs) {
                return edge.edge;
            }
        }
        
        return null;
    }
    
    /**
     * Check if point is inside the zone (but not on handles)
     * @param {number} screenX - Screen X
     * @param {number} screenY - Screen Y
     * @param {number} scale - Camera scale
     * @param {object} offset - Camera offset
     * @returns {boolean}
     */
    isInsideZone(screenX, screenY, scale, offset) {
        if (!this.active) return false;
        
        const zx = (this.zone.x + offset.x) * scale;
        const zy = (this.zone.y + offset.y) * scale;
        const zw = this.zone.width * scale;
        const zh = this.zone.height * scale;
        
        return screenX >= zx && screenX <= zx + zw &&
               screenY >= zy && screenY <= zy + zh;
    }
    
    /**
     * Start resizing from a handle
     * @param {string} edge - Edge being dragged
     * @param {number} mouseX - Mouse X position
     * @param {number} mouseY - Mouse Y position
     */
    startResize(edge, mouseX, mouseY) {
        this.resizing = true;
        this.resizeEdge = edge;
        this.resizeStartMouse = { x: mouseX, y: mouseY };
        this.resizeStartZone = { ...this.zone };
    }
    
    /**
     * Update resize during drag
     * @param {number} mouseX - Current mouse X
     * @param {number} mouseY - Current mouse Y
     * @param {number} scale - Camera scale
     */
    updateResize(mouseX, mouseY, scale) {
        if (!this.resizing) return;
        
        const dx = (mouseX - this.resizeStartMouse.x) / scale;
        const dy = (mouseY - this.resizeStartMouse.y) / scale;
        
        let newX = this.resizeStartZone.x;
        let newY = this.resizeStartZone.y;
        let newW = this.resizeStartZone.width;
        let newH = this.resizeStartZone.height;
        
        // Handle different edges
        if (this.resizeEdge.includes('n')) {
            newY = this.resizeStartZone.y + dy;
            newH = this.resizeStartZone.height - dy;
        }
        if (this.resizeEdge.includes('s')) {
            newH = this.resizeStartZone.height + dy;
        }
        if (this.resizeEdge.includes('w')) {
            newX = this.resizeStartZone.x + dx;
            newW = this.resizeStartZone.width - dx;
        }
        if (this.resizeEdge.includes('e')) {
            newW = this.resizeStartZone.width + dx;
        }
        
        // Apply with constraints
        this.setZone(newX, newY, newW, newH);
    }
    
    /**
     * End resize operation
     */
    endResize() {
        this.resizing = false;
        this.resizeEdge = null;
    }
    
    /**
     * Get cursor style for edge
     * @param {string} edge - Edge identifier
     * @returns {string} - CSS cursor style
     */
    getCursorForEdge(edge) {
        const cursors = {
            'n': 'ns-resize',
            's': 'ns-resize',
            'e': 'ew-resize',
            'w': 'ew-resize',
            'nw': 'nwse-resize',
            'se': 'nwse-resize',
            'ne': 'nesw-resize',
            'sw': 'nesw-resize'
        };
        return cursors[edge] || 'default';
    }
    
    /**
     * Serialize spawner state
     * @returns {object} - Serialized state
     */
    serialize() {
        return {
            active: this.active,
            tickInterval: this.tickInterval,
            atomPool: this.atomPool.slice(),
            zone: { ...this.zone }
        };
    }
    
    /**
     * Deserialize spawner state
     * @param {object} data - Serialized data
     */
    deserialize(data) {
        if (data.active !== undefined) this.active = data.active;
        if (data.tickInterval !== undefined) this.tickInterval = data.tickInterval;
        if (data.atomPool) this.atomPool = data.atomPool.slice();
        if (data.zone) {
            this.zone = { ...data.zone };
        }
    }
}

// Make available globally
window.AtomSpawner = AtomSpawner;


// ==== src/systems/neural-network.js ====
/**
 * Neural Network
 * Lightweight feed-forward neural network for cell behavior
 * No external dependencies
 */

class NeuralNetwork {
    /**
     * Create a neural network
     * @param {number[]} layers - Layer sizes, e.g., [4, 8, 4] for 4 inputs, 8 hidden, 4 outputs
     * @param {string} activation - Activation function: 'sigmoid', 'relu', 'tanh'
     */
    constructor(layers, activation = 'sigmoid') {
        this.layers = layers;
        this.activation = activation;

        // Initialize weights and biases
        this.weights = [];
        this.biases = [];

        for (let i = 0; i < layers.length - 1; i++) {
            // Weight matrix from layer i to layer i+1
            const weightMatrix = this._createMatrix(layers[i + 1], layers[i]);
            this._randomizeMatrix(weightMatrix);
            this.weights.push(weightMatrix);

            // Bias vector for layer i+1
            const biasVector = new Array(layers[i + 1]).fill(0).map(() => (Math.random() - 0.5) * 0.5);
            this.biases.push(biasVector);
        }
    }

    /**
     * Create a matrix (2D array)
     */
    _createMatrix(rows, cols) {
        return Array.from({ length: rows }, () => new Array(cols).fill(0));
    }

    /**
     * Randomize matrix values (Xavier initialization)
     */
    _randomizeMatrix(matrix) {
        const rows = matrix.length;
        const cols = matrix[0].length;
        const scale = Math.sqrt(2 / (rows + cols));

        for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
                matrix[i][j] = (Math.random() - 0.5) * 2 * scale;
            }
        }
    }

    /**
     * Activation function
     */
    _activate(x) {
        switch (this.activation) {
            case 'sigmoid':
                return 1 / (1 + Math.exp(-x));
            case 'relu':
                return Math.max(0, x);
            case 'tanh':
                return Math.tanh(x);
            default:
                return 1 / (1 + Math.exp(-x));
        }
    }

    /**
     * Forward propagation
     * @param {number[]} inputs - Input values
     * @returns {number[]} Output values
     */
    forward(inputs) {
        if (inputs.length !== this.layers[0]) {
            throw new Error(`Expected ${this.layers[0]} inputs, got ${inputs.length}`);
        }

        let current = inputs.slice();

        for (let i = 0; i < this.weights.length; i++) {
            const weights = this.weights[i];
            const biases = this.biases[i];
            const next = [];

            for (let j = 0; j < weights.length; j++) {
                let sum = biases[j];
                for (let k = 0; k < current.length; k++) {
                    sum += weights[j][k] * current[k];
                }
                next.push(this._activate(sum));
            }

            current = next;
        }

        return current;
    }

    /**
     * Get all weights as a flat array
     * @returns {number[]} Flattened weights and biases
     */
    getWeights() {
        const flat = [];

        for (let i = 0; i < this.weights.length; i++) {
            const weights = this.weights[i];
            for (let j = 0; j < weights.length; j++) {
                for (let k = 0; k < weights[j].length; k++) {
                    flat.push(weights[j][k]);
                }
            }
            for (let j = 0; j < this.biases[i].length; j++) {
                flat.push(this.biases[i][j]);
            }
        }

        return flat;
    }

    /**
     * Set all weights from a flat array
     * @param {number[]} flat - Flattened weights and biases
     */
    setWeights(flat) {
        let index = 0;

        for (let i = 0; i < this.weights.length; i++) {
            const weights = this.weights[i];
            for (let j = 0; j < weights.length; j++) {
                for (let k = 0; k < weights[j].length; k++) {
                    weights[j][k] = flat[index++];
                }
            }
            for (let j = 0; j < this.biases[i].length; j++) {
                this.biases[i][j] = flat[index++];
            }
        }
    }

    /**
     * Get total number of weights
     */
    getWeightCount() {
        let count = 0;
        for (let i = 0; i < this.layers.length - 1; i++) {
            count += this.layers[i] * this.layers[i + 1]; // weights
            count += this.layers[i + 1]; // biases
        }
        return count;
    }

    /**
     * Mutate weights randomly
     * @param {number} rate - Mutation rate (0-1), probability of each weight being mutated
     * @param {number} strength - Mutation strength, max change amount
     */
    mutate(rate = 0.1, strength = 0.5) {
        for (let i = 0; i < this.weights.length; i++) {
            const weights = this.weights[i];
            for (let j = 0; j < weights.length; j++) {
                for (let k = 0; k < weights[j].length; k++) {
                    if (Math.random() < rate) {
                        weights[j][k] += (Math.random() - 0.5) * 2 * strength;
                    }
                }
            }
            for (let j = 0; j < this.biases[i].length; j++) {
                if (Math.random() < rate) {
                    this.biases[i][j] += (Math.random() - 0.5) * 2 * strength;
                }
            }
        }
    }

    /**
     * Create a copy of this neural network
     * @returns {NeuralNetwork} Cloned network
     */
    clone() {
        const clone = new NeuralNetwork(this.layers.slice(), this.activation);
        clone.setWeights(this.getWeights());
        return clone;
    }

    /**
     * Serialize to JSON-compatible object
     */
    serialize() {
        return {
            layers: this.layers,
            activation: this.activation,
            weights: this.getWeights()
        };
    }

    /**
     * Create from serialized data
     * @param {object} data - Serialized network data
     * @returns {NeuralNetwork}
     */
    static deserialize(data) {
        const nn = new NeuralNetwork(data.layers, data.activation);
        nn.setWeights(data.weights);
        return nn;
    }

    /**
     * Create a random neural network with random topology
     * @param {number} inputs - Number of inputs
     * @param {number} outputs - Number of outputs
     * @param {number} hiddenLayers - Number of hidden layers (0-3)
     * @param {number} hiddenSize - Size of hidden layers
     * @returns {NeuralNetwork}
     */
    static random(inputs, outputs, hiddenLayers = 1, hiddenSize = 8) {
        const layers = [inputs];
        for (let i = 0; i < hiddenLayers; i++) {
            layers.push(hiddenSize);
        }
        layers.push(outputs);

        return new NeuralNetwork(layers);
    }
}

// Make available globally
window.NeuralNetwork = NeuralNetwork;


// ==== src/entities/cell-memory.js ====
/**
 * Cell Memory
 * Simple key-value memory with decay for cell learning
 */

class CellMemory {
    constructor() {
        this.memories = new Map();
        this.decayRate = 0.01; // Per tick decay
        this.maxMemories = 20;
    }

    /**
     * Store a memory
     * @param {string} key - Memory key
     * @param {*} value - Memory value
     * @param {number} strength - Initial strength (0-1)
     */
    store(key, value, strength = 1.0) {
        this.memories.set(key, {
            value,
            strength,
            timestamp: Date.now()
        });

        // Limit memory count
        if (this.memories.size > this.maxMemories) {
            this._pruneWeakest();
        }
    }

    /**
     * Retrieve a memory
     * @param {string} key - Memory key
     * @returns {*} Memory value or null
     */
    recall(key) {
        const memory = this.memories.get(key);
        if (!memory) return null;

        // Strengthen on recall
        memory.strength = Math.min(1, memory.strength + 0.1);

        return memory.value;
    }

    /**
     * Check if memory exists and is strong enough
     * @param {string} key - Memory key
     * @param {number} threshold - Minimum strength threshold
     */
    has(key, threshold = 0.1) {
        const memory = this.memories.get(key);
        return memory && memory.strength >= threshold;
    }

    /**
     * Get memory strength
     * @param {string} key - Memory key
     */
    getStrength(key) {
        const memory = this.memories.get(key);
        return memory ? memory.strength : 0;
    }

    /**
     * Update memories (decay over time)
     */
    update() {
        for (const [key, memory] of this.memories) {
            memory.strength -= this.decayRate;

            if (memory.strength <= 0) {
                this.memories.delete(key);
            }
        }
    }

    /**
     * Remove weakest memories
     */
    _pruneWeakest() {
        const sorted = Array.from(this.memories.entries())
            .sort((a, b) => a[1].strength - b[1].strength);

        // Remove weakest half
        const removeCount = Math.floor(sorted.length / 2);
        for (let i = 0; i < removeCount; i++) {
            this.memories.delete(sorted[i][0]);
        }
    }

    /**
     * Get all memories as array
     */
    getAll() {
        return Array.from(this.memories.entries()).map(([key, mem]) => ({
            key,
            value: mem.value,
            strength: mem.strength
        }));
    }

    /**
     * Clear all memories
     */
    clear() {
        this.memories.clear();
    }

    /**
     * Serialize memory
     */
    serialize() {
        return Array.from(this.memories.entries()).map(([key, mem]) => ({
            key,
            value: mem.value,
            strength: mem.strength
        }));
    }

    /**
     * Deserialize memory
     */
    static deserialize(data) {
        const memory = new CellMemory();
        for (const item of data) {
            memory.store(item.key, item.value, item.strength);
        }
        return memory;
    }
}

// Make available globally
window.CellMemory = CellMemory;


// ==== src/entities/cell.js ====
/**
 * Cell
 * Living unit with neural network-based behavior
 */

class Cell {
    /**
     * Create a cell
     * @param {number} x - X position
     * @param {number} y - Y position
     * @param {NeuralNetwork} brain - Neural network for behavior (optional)
     */
    constructor(x, y, brain = null) {
        this.id = Utils.generateId();
        this.position = new Vector2(x, y);
        this.velocity = new Vector2(0, 0);

        // Physical properties
        this.radius = 30;
        this.mass = 1;
        this.maxSpeed = 2;

        // Energy and metabolism
        this.energy = 100;
        this.maxEnergy = 100;
        this.metabolismRate = 0.1; // Energy consumed per tick
        this.movementCost = 0.05; // Extra energy per movement

        // Neural network brain
        // Inputs: [energy, food_dist, food_angle, threat_dist, threat_angle, random]
        // Outputs: [move_forward, turn, eat, reproduce]
        this.brain = brain || new NeuralNetwork([6, 12, 8, 4], 'tanh');

        // Sensor data (updated each tick)
        this.sensorData = {
            nearestFood: null,
            nearestThreat: null,
            energyLevel: 1
        };

        // State
        this.age = 0;
        this.generation = 0;
        this.isAlive = true;
        this.reproductionCooldown = 0;
        this.reproductionCost = 50;
        this.minReproductionEnergy = 70;

        // Visual properties
        this.color = this._generateColor();
        this.hue = Math.random() * 360;

        // Memory (for learning behaviors)
        this.memory = new CellMemory();

        // Component molecules (optional detail)
        this.molecules = [];
    }

    /**
     * Generate a color based on neural network weights
     */
    _generateColor() {
        const weights = this.brain.getWeights();
        const sum = weights.slice(0, 10).reduce((a, b) => a + Math.abs(b), 0);
        const hue = (sum * 50) % 360;
        return `hsl(${hue}, 70%, 50%)`;
    }

    /**
     * Update sensors based on environment
     * @param {Environment} environment
     */
    updateSensors(environment) {
        this.sensorData.energyLevel = this.energy / this.maxEnergy;

        // Find nearest food (free molecules with energy value)
        let nearestFoodDist = Infinity;
        let nearestFood = null;

        for (const molecule of environment.getAllMolecules()) {
            if (molecule.isStable && molecule.isStable()) {
                const dist = this.position.distanceTo(molecule.centerOfMass);
                if (dist < nearestFoodDist && dist < 200) {
                    nearestFoodDist = dist;
                    nearestFood = molecule;
                }
            }
        }

        this.sensorData.nearestFood = nearestFood;
        this.sensorData.nearestFoodDist = nearestFoodDist === Infinity ? 200 : nearestFoodDist;

        // Calculate angle to food
        if (nearestFood) {
            const dx = nearestFood.centerOfMass.x - this.position.x;
            const dy = nearestFood.centerOfMass.y - this.position.y;
            this.sensorData.nearestFoodAngle = Math.atan2(dy, dx);
        } else {
            this.sensorData.nearestFoodAngle = 0;
        }

        // Find nearest threat (other cells with more energy)
        let nearestThreatDist = Infinity;
        let nearestThreat = null;

        if (environment.cells) {
            for (const cell of environment.cells.values()) {
                if (cell.id !== this.id && cell.isAlive) {
                    const dist = this.position.distanceTo(cell.position);
                    if (dist < nearestThreatDist && dist < 200 && cell.energy > this.energy * 1.2) {
                        nearestThreatDist = dist;
                        nearestThreat = cell;
                    }
                }
            }
        }

        this.sensorData.nearestThreat = nearestThreat;
        this.sensorData.nearestThreatDist = nearestThreatDist === Infinity ? 200 : nearestThreatDist;

        // Calculate angle to threat
        if (nearestThreat) {
            const dx = nearestThreat.position.x - this.position.x;
            const dy = nearestThreat.position.y - this.position.y;
            this.sensorData.nearestThreatAngle = Math.atan2(dy, dx);
        } else {
            this.sensorData.nearestThreatAngle = 0;
        }
    }

    /**
     * Process brain and get actions
     * @returns {object} Actions to take
     */
    think() {
        // Prepare inputs (normalized 0-1 or -1 to 1)
        const inputs = [
            this.sensorData.energyLevel,
            1 - (this.sensorData.nearestFoodDist / 200), // Closer = higher
            this.sensorData.nearestFoodAngle / Math.PI, // -1 to 1
            1 - (this.sensorData.nearestThreatDist / 200),
            this.sensorData.nearestThreatAngle / Math.PI,
            Math.random() * 2 - 1 // Random input for exploration
        ];

        // Get outputs from brain
        const outputs = this.brain.forward(inputs);

        return {
            moveForward: outputs[0], // -1 to 1
            turn: outputs[1],        // -1 to 1
            eat: outputs[2] > 0.5,   // boolean
            reproduce: outputs[3] > 0.7 // boolean (higher threshold)
        };
    }

    /**
     * Update cell state
     * @param {Environment} environment
     */
    update(environment) {
        if (!this.isAlive) return;

        this.age++;
        this.reproductionCooldown = Math.max(0, this.reproductionCooldown - 1);

        // Update sensors
        this.updateSensors(environment);

        // Think and get actions
        const actions = this.think();

        // Apply movement
        this._applyMovement(actions, environment);

        // Try to eat
        if (actions.eat) {
            this._tryEat(environment);
        }

        // Try to reproduce
        if (actions.reproduce && this.canReproduce()) {
            this._reproduce(environment);
        }

        // Metabolism
        this.energy -= this.metabolismRate;

        // Check death
        if (this.energy <= 0) {
            this.die(environment);
        }

        // Update visual color based on energy
        this._updateColor();
    }

    /**
     * Apply movement based on actions
     */
    _applyMovement(actions, environment) {
        // Calculate movement direction
        const currentAngle = Math.atan2(this.velocity.y, this.velocity.x);
        const turnAmount = actions.turn * 0.1; // Max turn rate
        const newAngle = currentAngle + turnAmount;

        // Apply forward movement
        const speed = actions.moveForward * this.maxSpeed;
        const dx = Math.cos(newAngle) * speed;
        const dy = Math.sin(newAngle) * speed;

        this.velocity.x = dx;
        this.velocity.y = dy;

        // Update position
        this.position.x += this.velocity.x;
        this.position.y += this.velocity.y;

        // Boundary collision
        const padding = this.radius;
        if (this.position.x < padding) {
            this.position.x = padding;
            this.velocity.x *= -0.5;
        }
        if (this.position.x > environment.width - padding) {
            this.position.x = environment.width - padding;
            this.velocity.x *= -0.5;
        }
        if (this.position.y < padding) {
            this.position.y = padding;
            this.velocity.y *= -0.5;
        }
        if (this.position.y > environment.height - padding) {
            this.position.y = environment.height - padding;
            this.velocity.y *= -0.5;
        }

        // Movement costs energy
        const moveSpeed = Math.sqrt(dx * dx + dy * dy);
        this.energy -= moveSpeed * this.movementCost;
    }

    /**
     * Try to eat nearby food
     */
    _tryEat(environment) {
        const food = this.sensorData.nearestFood;
        if (!food) return;

        const dist = this.position.distanceTo(food.centerOfMass);
        if (dist < this.radius + 20) {
            // Consume the molecule for energy
            const energyGain = food.atoms.length * 5;
            this.energy = Math.min(this.maxEnergy, this.energy + energyGain);

            // Remove the molecule from environment
            for (const atom of food.atoms) {
                environment.removeAtom(atom.id);
            }
            environment.removeMolecule(food.id);

            // Store in memory
            this.memory.store('lastMeal', Date.now());
        }
    }

    /**
     * Check if can reproduce
     */
    canReproduce() {
        return this.energy >= this.minReproductionEnergy &&
            this.reproductionCooldown === 0 &&
            this.age > 100;
    }

    /**
     * Reproduce - create offspring
     */
    _reproduce(environment) {
        if (!this.canReproduce()) return null;

        // Energy cost
        this.energy -= this.reproductionCost;
        this.reproductionCooldown = 200;

        // Create offspring with mutated brain
        const offspringX = this.position.x + (Math.random() - 0.5) * 50;
        const offspringY = this.position.y + (Math.random() - 0.5) * 50;

        const offspringBrain = this.brain.clone();
        offspringBrain.mutate(0.1, 0.3); // 10% mutation rate, 0.3 strength

        const offspring = new Cell(offspringX, offspringY, offspringBrain);
        offspring.generation = this.generation + 1;
        offspring.energy = 40; // Start with some energy

        // Add to environment
        if (environment.addCell) {
            environment.addCell(offspring);
        }

        return offspring;
    }

    /**
     * Cell death
     */
    die(environment) {
        this.isAlive = false;

        // Could spawn molecules as remains
        // For now, just mark as dead
    }

    /**
     * Update color based on energy level
     */
    _updateColor() {
        const energyRatio = this.energy / this.maxEnergy;
        const saturation = 50 + energyRatio * 30;
        const lightness = 30 + energyRatio * 30;
        this.color = `hsl(${this.hue}, ${saturation}%, ${lightness}%)`;
    }

    /**
     * Check if point is inside cell
     */
    containsPoint(x, y, scale = 1, offset = { x: 0, y: 0 }) {
        const screenX = (this.position.x + offset.x) * scale;
        const screenY = (this.position.y + offset.y) * scale;
        const screenRadius = this.radius * scale;

        const dx = x - screenX;
        const dy = y - screenY;

        return dx * dx + dy * dy <= screenRadius * screenRadius;
    }

    /**
     * Render the cell
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} scale
     * @param {object} offset
     * @param {boolean} detailed - Show internal details
     */
    render(ctx, scale = 1, offset = { x: 0, y: 0 }, detailed = false) {
        if (!this.isAlive) return;

        const screenX = (this.position.x + offset.x) * scale;
        const screenY = (this.position.y + offset.y) * scale;
        const screenRadius = this.radius * scale;

        // Cell membrane
        ctx.beginPath();
        ctx.arc(screenX, screenY, screenRadius, 0, Math.PI * 2);

        // Fill with gradient based on energy
        const gradient = ctx.createRadialGradient(
            screenX, screenY, 0,
            screenX, screenY, screenRadius
        );
        gradient.addColorStop(0, this.color);
        gradient.addColorStop(1, `hsla(${this.hue}, 60%, 30%, 0.8)`);

        ctx.fillStyle = gradient;
        ctx.fill();

        // Membrane outline
        ctx.strokeStyle = `hsla(${this.hue}, 80%, 60%, 0.9)`;
        ctx.lineWidth = 2 * scale;
        ctx.stroke();

        // Energy bar
        const barWidth = screenRadius * 1.5;
        const barHeight = 4 * scale;
        const barX = screenX - barWidth / 2;
        const barY = screenY - screenRadius - 10 * scale;

        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(barX, barY, barWidth, barHeight);

        const energyRatio = Math.max(0, this.energy / this.maxEnergy);
        ctx.fillStyle = energyRatio > 0.5 ? '#4ade80' : (energyRatio > 0.2 ? '#fbbf24' : '#ef4444');
        ctx.fillRect(barX, barY, barWidth * energyRatio, barHeight);

        // Detailed view - show nucleus and internal structures
        if (detailed) {
            // Nucleus
            ctx.beginPath();
            ctx.arc(screenX, screenY, screenRadius * 0.3, 0, Math.PI * 2);
            ctx.fillStyle = `hsla(${this.hue}, 50%, 40%, 0.7)`;
            ctx.fill();

            // Generation text
            ctx.fillStyle = 'white';
            ctx.font = `${10 * scale}px monospace`;
            ctx.textAlign = 'center';
            ctx.fillText(`G${this.generation}`, screenX, screenY + 4 * scale);
        }
    }

    /**
     * Serialize cell data
     */
    serialize() {
        return {
            id: this.id,
            x: this.position.x,
            y: this.position.y,
            energy: this.energy,
            age: this.age,
            generation: this.generation,
            brain: this.brain.serialize(),
            hue: this.hue
        };
    }

    /**
     * Deserialize cell data
     */
    static deserialize(data) {
        const brain = NeuralNetwork.deserialize(data.brain);
        const cell = new Cell(data.x, data.y, brain);
        cell.id = data.id;
        cell.energy = data.energy;
        cell.age = data.age;
        cell.generation = data.generation;
        cell.hue = data.hue;
        cell._updateColor();
        return cell;
    }
}

// Make available globally
window.Cell = Cell;


// ==== src/entities/prokaryote.js ====
/**
 * Prokaryote
 * Chemistry-based unicellular organism
 * Level 4 in the abstraction hierarchy (above polymers)
 * 
 * Prokaryotes are simpler than eukaryotes:
 * - No membrane-bound nucleus (nucleoid region instead)
 * - No organelles (ribosomes are free in cytoplasm)
 * - Single circular chromosome
 * 
 * Required components:
 * - Membrane: LIPID polymers forming boundary
 * - Nucleoid: NUCLEIC_ACID polymers (DNA)
 * 
 * Optional components:
 * - Ribosomes: PROTEIN polymers
 * - Plasmids: Additional small NUCLEIC_ACID polymers
 */

class Prokaryote {
    /**
     * Create a prokaryote from polymers
     * @param {object} components - Object containing component arrays
     * @param {Polymer[]} components.membrane - LIPID polymers forming cell boundary
     * @param {Polymer[]} components.nucleoid - NUCLEIC_ACID polymers (genetic material)
     * @param {Polymer[]} components.ribosomes - PROTEIN polymers (optional)
     */
    constructor(components = {}) {
        this.id = Utils.generateId();

        // Core structural components
        this.membrane = components.membrane || [];
        this.nucleoid = components.nucleoid || [];
        this.ribosomes = components.ribosomes || [];

        // Link polymers to this prokaryote
        for (const polymer of [...this.membrane, ...this.nucleoid, ...this.ribosomes]) {
            polymer.prokaryoteId = this.id;
        }

        // Cytoplasm contents
        this.cytoplasm = {
            molecules: [],      // Free molecules inside the cell
            atp: 100,           // Energy currency (arbitrary units)
            maxAtp: 200
        };

        // Physical properties (derived from membrane)
        this._updatePhysicalProperties();

        // State
        this.age = 0;
        this.isAlive = true;
        this.generation = 0;

        // Metabolic rates
        this.baseMetabolism = 0.05;     // ATP consumed per tick
        this.atpPerCarbohydrate = 10;   // ATP gained from digesting carbohydrate

        // Division properties
        this.divisionThreshold = 150;   // ATP needed to divide
        this.divisionCooldown = 0;
        this.divisionCooldownMax = 500; // Ticks between divisions

        // Selection state
        this.selected = false;
        this.highlighted = false;
    }

    /**
     * Update physical properties from membrane polymers
     */
    _updatePhysicalProperties() {
        if (this.membrane.length === 0) {
            // Keep existing position if already set, otherwise default to 0,0
            if (!this.position) {
                this.position = new Vector2(0, 0);
            }
            this.radius = 30;
            return;
        }

        // Calculate center from all membrane polymers
        let sumX = 0, sumY = 0;
        let atomCount = 0;

        for (const polymer of this.membrane) {
            const center = polymer.getCenter();
            sumX += center.x;
            sumY += center.y;
            atomCount++;
        }

        this.position = atomCount > 0
            ? new Vector2(sumX / atomCount, sumY / atomCount)
            : new Vector2(0, 0);

        // Radius based on membrane size
        const totalMass = this.membrane.reduce((sum, p) => sum + (p.mass || 0), 0);
        this.radius = Math.max(30, 20 + Math.sqrt(totalMass) * 2);
    }

    /**
     * Check if prokaryote is valid (has minimum required components)
     */
    isValid() {
        return this.membrane.length > 0 && this.nucleoid.length > 0;
    }

    /**
     * Check if point is inside the cell
     */
    containsPoint(x, y, scale = 1, offset = { x: 0, y: 0 }) {
        const screenX = (this.position.x + offset.x) * scale;
        const screenY = (this.position.y + offset.y) * scale;
        const screenRadius = this.radius * scale;

        const dx = x - screenX;
        const dy = y - screenY;

        return dx * dx + dy * dy <= screenRadius * screenRadius;
    }

    /**
     * Update prokaryote state
     * @param {number} dt - Delta time
     * @param {Environment} environment - Environment reference
     */
    update(dt, environment) {
        if (!this.isAlive) return;

        this.age++;
        this.divisionCooldown = Math.max(0, this.divisionCooldown - 1);

        // Metabolism - consume ATP
        this.cytoplasm.atp -= this.baseMetabolism * dt;

        // Check death
        if (this.cytoplasm.atp <= 0) {
            this.die(environment);
            return;
        }

        // Update physical properties
        this._updatePhysicalProperties();

        // Update component polymers
        for (const polymer of this.membrane) {
            polymer.update(dt);
        }
        for (const polymer of this.nucleoid) {
            polymer.update(dt);
        }
        for (const polymer of this.ribosomes) {
            polymer.update(dt);
        }

        // Try to absorb nearby nutrients
        this._tryAbsorbNutrients(environment);

        // Check binary fission (cell division)
        if (this.canDivide()) {
            this._divide(environment);
        }
    }

    /**
     * Try to absorb nearby carbohydrate polymers as nutrients
     */
    _tryAbsorbNutrients(environment) {
        // Look for nearby carbohydrate polymers (food source)
        if (!environment.polymers) return;

        for (const [polymerId, polymer] of environment.polymers) {
            // Skip polymers already part of a prokaryote
            if (polymer.prokaryoteId) continue;

            // Only absorb carbohydrates
            if (polymer.type !== PolymerType.CARBOHYDRATE) continue;

            const distance = Utils.distance(
                this.position.x, this.position.y,
                polymer.getCenter().x, polymer.getCenter().y
            );

            // Absorb if close enough
            if (distance < this.radius + 20) {
                // Gain ATP from carbohydrate
                const atpGain = this.atpPerCarbohydrate * polymer.molecules.length;
                this.cytoplasm.atp = Math.min(this.cytoplasm.maxAtp, this.cytoplasm.atp + atpGain);

                // Remove the polymer from environment
                environment.removePolymer(polymerId);
                break; // Only absorb one per tick
            }
        }
    }

    /**
     * Check if prokaryote can divide
     */
    canDivide() {
        return this.isAlive &&
            this.cytoplasm.atp >= this.divisionThreshold &&
            this.divisionCooldown === 0 &&
            this.age > 100;
    }

    /**
     * Binary fission - divide into two daughter cells
     */
    _divide(environment) {
        if (!this.canDivide()) return null;

        // Cost of division
        this.cytoplasm.atp -= this.divisionThreshold * 0.7;
        this.divisionCooldown = this.divisionCooldownMax;

        // Create offspring at offset position
        const offsetX = (Math.random() - 0.5) * this.radius * 2;
        const offsetY = (Math.random() - 0.5) * this.radius * 2;

        // For simplicity, create a new prokaryote with empty components
        // In a full simulation, we'd actually duplicate polymers
        const offspring = new Prokaryote({
            membrane: [],
            nucleoid: [],
            ribosomes: []
        });

        offspring.position = new Vector2(
            this.position.x + offsetX,
            this.position.y + offsetY
        );
        offspring.generation = this.generation + 1;
        offspring.cytoplasm.atp = this.divisionThreshold * 0.3;
        offspring.radius = this.radius * 0.8;

        // Add to environment
        if (environment.addProkaryote) {
            environment.addProkaryote(offspring);
        }

        return offspring;
    }

    /**
     * Cell death
     */
    die(environment) {
        this.isAlive = false;

        // Unlink polymers
        for (const polymer of [...this.membrane, ...this.nucleoid, ...this.ribosomes]) {
            polymer.prokaryoteId = null;
        }

        // In future: release polymers back to environment
    }

    /**
     * Get total atom count
     */
    getAtomCount() {
        let count = 0;
        for (const polymer of [...this.membrane, ...this.nucleoid, ...this.ribosomes]) {
            count += polymer.getAllAtoms().length;
        }
        return count;
    }

    /**
     * Get component summary
     */
    getComponentSummary() {
        return {
            membrane: this.membrane.length,
            nucleoid: this.nucleoid.length,
            ribosomes: this.ribosomes.length,
            totalPolymers: this.membrane.length + this.nucleoid.length + this.ribosomes.length
        };
    }

    /**
     * Render the prokaryote
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} scale
     * @param {object} offset
     * @param {boolean} detailed - Show internal details
     */
    render(ctx, scale = 1, offset = { x: 0, y: 0 }, detailed = false) {
        if (!this.isAlive) return;

        const screenX = (this.position.x + offset.x) * scale;
        const screenY = (this.position.y + offset.y) * scale;
        const screenRadius = this.radius * scale;

        ctx.save();

        // Cell membrane (outer boundary)
        ctx.beginPath();
        ctx.arc(screenX, screenY, screenRadius, 0, Math.PI * 2);

        // Fill with gradient
        const gradient = ctx.createRadialGradient(
            screenX, screenY, 0,
            screenX, screenY, screenRadius
        );
        gradient.addColorStop(0, 'rgba(200, 230, 200, 0.7)');
        gradient.addColorStop(0.7, 'rgba(150, 200, 150, 0.5)');
        gradient.addColorStop(1, 'rgba(100, 150, 100, 0.3)');

        ctx.fillStyle = gradient;
        ctx.fill();

        // Membrane outline (lipid bilayer visualization)
        ctx.strokeStyle = this.selected ? '#f59e0b' : '#22c55e';
        ctx.lineWidth = 3 * scale;
        ctx.stroke();

        // Nucleoid region (irregular shape in center)
        ctx.beginPath();
        const nucleoidRadius = screenRadius * 0.4;
        ctx.ellipse(screenX, screenY, nucleoidRadius, nucleoidRadius * 0.7, 0.3, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(239, 68, 68, 0.4)'; // Red for DNA
        ctx.fill();
        ctx.strokeStyle = 'rgba(239, 68, 68, 0.6)';
        ctx.lineWidth = 1 * scale;
        ctx.stroke();

        // Ribosomes (small dots)
        const ribosomeCount = Math.min(this.ribosomes.length * 2, 8);
        ctx.fillStyle = 'rgba(59, 130, 246, 0.6)'; // Blue for proteins
        for (let i = 0; i < ribosomeCount; i++) {
            const angle = (i / ribosomeCount) * Math.PI * 2;
            const dist = screenRadius * 0.6;
            const rx = screenX + Math.cos(angle) * dist;
            const ry = screenY + Math.sin(angle) * dist;
            ctx.beginPath();
            ctx.arc(rx, ry, 3 * scale, 0, Math.PI * 2);
            ctx.fill();
        }

        // ATP bar (energy indicator)
        const barWidth = screenRadius * 1.5;
        const barHeight = 4 * scale;
        const barX = screenX - barWidth / 2;
        const barY = screenY - screenRadius - 10 * scale;

        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(barX, barY, barWidth, barHeight);

        const atpRatio = Math.max(0, this.cytoplasm.atp / this.cytoplasm.maxAtp);
        ctx.fillStyle = atpRatio > 0.5 ? '#4ade80' : (atpRatio > 0.2 ? '#fbbf24' : '#ef4444');
        ctx.fillRect(barX, barY, barWidth * atpRatio, barHeight);

        // Generation label
        if (detailed) {
            ctx.fillStyle = 'white';
            ctx.font = `${10 * scale}px monospace`;
            ctx.textAlign = 'center';
            ctx.fillText(`G${this.generation}`, screenX, screenY + 4 * scale);
        }

        ctx.restore();
    }

    /**
     * Serialize prokaryote data
     */
    serialize() {
        return {
            id: this.id,
            position: { x: this.position.x, y: this.position.y },
            radius: this.radius,
            age: this.age,
            generation: this.generation,
            isAlive: this.isAlive,
            cytoplasm: {
                atp: this.cytoplasm.atp,
                maxAtp: this.cytoplasm.maxAtp
            },
            membraneIds: this.membrane.map(p => p.id),
            nucleoidIds: this.nucleoid.map(p => p.id),
            ribosomeIds: this.ribosomes.map(p => p.id)
        };
    }

    /**
     * Deserialize prokaryote data
     * @param {object} data - Serialized data
     * @param {Map} polymers - Polymer map for looking up by ID
     */
    static deserialize(data, polymers) {
        const getPolymers = (ids) => ids.map(id => polymers.get(id)).filter(p => p);

        const prokaryote = new Prokaryote({
            membrane: getPolymers(data.membraneIds || []),
            nucleoid: getPolymers(data.nucleoidIds || []),
            ribosomes: getPolymers(data.ribosomeIds || [])
        });

        prokaryote.id = data.id;
        prokaryote.position = new Vector2(data.position.x, data.position.y);
        prokaryote.radius = data.radius;
        prokaryote.age = data.age;
        prokaryote.generation = data.generation;
        prokaryote.isAlive = data.isAlive;
        prokaryote.cytoplasm.atp = data.cytoplasm.atp;
        prokaryote.cytoplasm.maxAtp = data.cytoplasm.maxAtp;

        return prokaryote;
    }
}

// Make available globally
window.Prokaryote = Prokaryote;


// ==== src/entities/prokaryote-factory.js ====
/**
 * Prokaryote Factory
 * Factory methods for detecting and creating prokaryotes from polymer combinations
 */

/**
 * Check if a set of polymers can form a valid prokaryote
 * Minimum requirements:
 * - At least 1 LIPID polymer (membrane)
 * - At least 1 NUCLEIC_ACID polymer (genetic material)
 * 
 * @param {Polymer[]} polymers - Array of polymers to check
 * @returns {boolean} True if the polymers can form a prokaryote
 */
function canFormProkaryote(polymers) {
    if (!polymers || polymers.length < 2) return false;

    let hasLipid = false;
    let hasNucleicAcid = false;

    for (const polymer of polymers) {
        if (!polymer || !polymer.type) continue;

        if (polymer.type === PolymerType.LIPID) {
            hasLipid = true;
        }
        if (polymer.type === PolymerType.NUCLEIC_ACID) {
            hasNucleicAcid = true;
        }
    }

    return hasLipid && hasNucleicAcid;
}

/**
 * Categorize polymers by their role in a prokaryote
 * @param {Polymer[]} polymers - Array of polymers
 * @returns {object} Object with categorized polymer arrays
 */
function categorizePolymersForProkaryote(polymers) {
    const result = {
        membrane: [],
        nucleoid: [],
        ribosomes: [],
        other: []
    };

    for (const polymer of polymers) {
        if (!polymer || !polymer.type) continue;

        switch (polymer.type) {
            case PolymerType.LIPID:
                result.membrane.push(polymer);
                break;
            case PolymerType.NUCLEIC_ACID:
                result.nucleoid.push(polymer);
                break;
            case PolymerType.PROTEIN:
                result.ribosomes.push(polymer);
                break;
            default:
                result.other.push(polymer);
        }
    }

    return result;
}

/**
 * Create a prokaryote from a set of polymers
 * @param {Polymer[]} polymers - Array of polymers to combine
 * @returns {Prokaryote|null} New prokaryote or null if invalid
 */
function createProkaryoteFromPolymers(polymers) {
    if (!canFormProkaryote(polymers)) {
        return null;
    }

    const categorized = categorizePolymersForProkaryote(polymers);

    const prokaryote = new Prokaryote({
        membrane: categorized.membrane,
        nucleoid: categorized.nucleoid,
        ribosomes: categorized.ribosomes
    });

    return prokaryote;
}

/**
 * Find groups of nearby polymers that could form prokaryotes
 * @param {Map|Array} polymers - All polymers in environment
 * @param {number} maxDistance - Maximum distance for polymers to be considered nearby
 * @returns {Polymer[][]} Arrays of polymer groups that could form prokaryotes
 */
function findPotentialProkaryoteGroups(polymers, maxDistance = 150) {
    const groups = [];
    const assigned = new Set();

    // Convert to array if Map
    const polymerArray = polymers instanceof Map
        ? Array.from(polymers.values())
        : polymers;

    // Filter out polymers already part of a prokaryote
    const available = polymerArray.filter(p =>
        !p.prokaryoteId && p.isSealed
    );

    for (const startPolymer of available) {
        if (assigned.has(startPolymer.id)) continue;

        // Find all nearby polymers using BFS
        const group = [startPolymer];
        assigned.add(startPolymer.id);

        const queue = [startPolymer];
        while (queue.length > 0) {
            const current = queue.shift();
            const currentCenter = current.getCenter();

            for (const other of available) {
                if (assigned.has(other.id)) continue;

                const otherCenter = other.getCenter();
                const distance = Utils.distance(
                    currentCenter.x, currentCenter.y,
                    otherCenter.x, otherCenter.y
                );

                if (distance < maxDistance) {
                    group.push(other);
                    assigned.add(other.id);
                    queue.push(other);
                }
            }
        }

        // Only include groups that can form prokaryotes
        if (canFormProkaryote(group)) {
            groups.push(group);
        }
    }

    return groups;
}

/**
 * Auto-detect and create prokaryotes from environment polymers
 * @param {Environment} environment - Environment to check
 * @param {number} maxDistance - Maximum distance for nearby polymers
 * @returns {Prokaryote[]} Newly created prokaryotes
 */
function detectAndCreateProkaryotes(environment, maxDistance = 150) {
    if (!environment.polymers) return [];

    const newProkaryotes = [];
    const groups = findPotentialProkaryoteGroups(environment.polymers, maxDistance);

    for (const group of groups) {
        const prokaryote = createProkaryoteFromPolymers(group);
        if (prokaryote) {
            newProkaryotes.push(prokaryote);
        }
    }

    return newProkaryotes;
}

// Make available globally
window.canFormProkaryote = canFormProkaryote;
window.categorizePolymersForProkaryote = categorizePolymersForProkaryote;
window.createProkaryoteFromPolymers = createProkaryoteFromPolymers;
window.findPotentialProkaryoteGroups = findPotentialProkaryoteGroups;
window.detectAndCreateProkaryotes = detectAndCreateProkaryotes;


// ==== src/core/environment.js ====
/**
 * Environment
 * The container for all simulation entities with spatial management
 */

class Environment {
    /**
     * Create a new environment
     * @param {number} width - World width
     * @param {number} height - World height
     */
    constructor(width = 2000, height = 2000) {
        this.width = width;
        this.height = height;

        // Entity storage
        this.atoms = new Map();      // id -> Atom
        this.bonds = new Map();      // id -> Bond
        this.molecules = new Map();  // id -> Molecule
        this.proteins = new Map();   // id -> Protein (polymers)
        this.cells = new Map();      // id -> Cell
        this.prokaryotes = new Map(); // id -> Prokaryote (chemistry-based cells)
        this.organisms = new Map();  // id -> Organism (future)
        this.intentions = new Map(); // id -> Intention (blueprint attraction zones)

        // Spatial partitioning for performance
        this.gridSize = 100;
        this.grid = new Map();  // "x,y" -> Set of entity ids

        // Environment properties
        this.temperature = 300;  // Kelvin
        this.pressure = 1;       // Atmospheres

        this.stats = {
            atomCount: 0,
            moleculeCount: 0,
            proteinCount: 0,
            cellCount: 0,
            prokaryoteCount: 0,
            organismCount: 0,
            intentionCount: 0
        };
    }

    /**
     * Add an atom to the environment
     * @param {Atom} atom - Atom to add
     */
    addAtom(atom) {
        this.atoms.set(atom.id, atom);
        this.updateGridPosition(atom);
        this.stats.atomCount = this.atoms.size;
    }

    /**
     * Remove an atom from the environment
     * @param {string} atomId - Atom ID to remove
     */
    removeAtom(atomId) {
        const atom = this.atoms.get(atomId);
        if (atom) {
            // Remove all bonds
            const bonds = [...atom.bonds];
            bonds.forEach(bond => this.removeBond(bond.id));

            // Remove from grid
            this.removeFromGrid(atom);

            // Remove from storage
            this.atoms.delete(atomId);
            this.stats.atomCount = this.atoms.size;
        }
    }

    /**
     * Add a bond to the environment
     * @param {Bond} bond - Bond to add
     */
    addBond(bond) {
        this.bonds.set(bond.id, bond);
    }

    /**
     * Remove a bond from the environment
     * @param {string} bondId - Bond ID to remove
     */
    removeBond(bondId) {
        const bond = this.bonds.get(bondId);
        if (bond) {
            bond.break();
            this.bonds.delete(bondId);
        }
    }

    /**
     * Synchronize bonds between environment.bonds and atom.bonds
     * This is BIDIRECTIONAL:
     * 1. Adds bonds from atom.bonds that aren't in environment.bonds (e.g., from reshaping)
     * 2. Removes bonds from environment.bonds that atoms no longer have
     */
    syncBonds() {
        // Step 1: Discover NEW bonds that exist in atom.bonds but not in environment.bonds
        // This happens when molecules reshape and create new bonds via Bond constructor
        const knownBondIds = new Set(this.bonds.keys());
        for (const atom of this.atoms.values()) {
            for (const bond of atom.bonds) {
                if (!knownBondIds.has(bond.id)) {
                    // This is a new bond - add it to environment.bonds
                    this.bonds.set(bond.id, bond);
                    knownBondIds.add(bond.id);
                }
            }
        }
        
        // Step 2: Remove broken/orphaned bonds from environment.bonds
        const bondsToRemove = [];
        for (const [bondId, bond] of this.bonds) {
            // Check if bond is orphaned (atoms don't exist in environment)
            const atom1Exists = bond.atom1 && this.atoms.has(bond.atom1.id);
            const atom2Exists = bond.atom2 && this.atoms.has(bond.atom2.id);
            
            if (!atom1Exists || !atom2Exists) {
                bondsToRemove.push(bondId);
                continue;
            }
            
            // Check if bond has been broken (atoms don't have it in their bonds array)
            const atom1HasBond = bond.atom1.bonds.includes(bond);
            const atom2HasBond = bond.atom2.bonds.includes(bond);
            
            if (!atom1HasBond || !atom2HasBond) {
                bondsToRemove.push(bondId);
            }
        }
        
        for (const bondId of bondsToRemove) {
            this.bonds.delete(bondId);
        }
        
        // Step 3: Ensure atom.bonds arrays are consistent with environment.bonds
        // Rebuild atom.bonds from environment.bonds to ensure both sides match
        for (const atom of this.atoms.values()) {
            atom.bonds = [];
        }
        
        for (const bond of this.bonds.values()) {
            if (bond.atom1 && bond.atom2) {
                if (!bond.atom1.bonds.includes(bond)) {
                    bond.atom1.bonds.push(bond);
                }
                if (!bond.atom2.bonds.includes(bond)) {
                    bond.atom2.bonds.push(bond);
                }
            }
        }
    }

    /**
     * Register a molecule
     * @param {Molecule} molecule - Molecule to register
     */
    addMolecule(molecule) {
        this.molecules.set(molecule.id, molecule);
        // Assign moleculeId to all atoms in the molecule
        for (const atom of molecule.atoms) {
            atom.moleculeId = molecule.id;
        }
        this.stats.moleculeCount = this.molecules.size;
    }

    /**
     * Remove a molecule (doesn't remove atoms)
     * @param {string} moleculeId - Molecule ID
     */
    removeMolecule(moleculeId) {
        const molecule = this.molecules.get(moleculeId);
        if (molecule) {
            molecule.atoms.forEach(atom => atom.moleculeId = null);
            this.molecules.delete(moleculeId);
            this.stats.moleculeCount = this.molecules.size;
        }
    }

    /**
     * Register a protein
     * @param {Protein} protein - Protein to register
     */
    addProtein(protein) {
        this.proteins.set(protein.id, protein);
        this.stats.proteinCount = this.proteins.size;
    }

    /**
     * Remove a protein
     * @param {string} proteinId - Protein ID
     */
    removeProtein(proteinId) {
        const protein = this.proteins.get(proteinId);
        if (protein) {
            protein.molecules.forEach(mol => mol.proteinId = null);
            this.proteins.delete(proteinId);
            this.stats.proteinCount = this.proteins.size;
        }
    }

    /**
     * Add a cell to the environment
     * @param {Cell} cell - Cell to add
     */
    addCell(cell) {
        this.cells.set(cell.id, cell);
        this.stats.cellCount = this.cells.size;
    }

    /**
     * Remove a cell from the environment
     * @param {string} cellId - Cell ID to remove
     */
    removeCell(cellId) {
        this.cells.delete(cellId);
        this.stats.cellCount = this.cells.size;
    }

    /**
     * Get all cells as array
     */
    getAllCells() {
        return Array.from(this.cells.values());
    }

    // --- Prokaryote Methods ---

    /**
     * Add a prokaryote to the environment
     * @param {Prokaryote} prokaryote - Prokaryote to add
     */
    addProkaryote(prokaryote) {
        this.prokaryotes.set(prokaryote.id, prokaryote);
        this.stats.prokaryoteCount = this.prokaryotes.size;
    }

    /**
     * Remove a prokaryote from the environment
     * @param {string} prokaryoteId - Prokaryote ID to remove
     */
    removeProkaryote(prokaryoteId) {
        this.prokaryotes.delete(prokaryoteId);
        this.stats.prokaryoteCount = this.prokaryotes.size;
    }

    /**
     * Get all prokaryotes as array
     */
    getAllProkaryotes() {
        return Array.from(this.prokaryotes.values());
    }

    /**
     * Update all prokaryotes
     * @param {number} dt - Delta time
     */
    updateProkaryotes(dt) {
        for (const prokaryote of this.prokaryotes.values()) {
            if (prokaryote.isAlive) {
                prokaryote.update(dt, this);
            }
        }

        // Remove dead prokaryotes
        for (const [id, prokaryote] of this.prokaryotes) {
            if (!prokaryote.isAlive) {
                this.prokaryotes.delete(id);
            }
        }

        this.stats.prokaryoteCount = this.prokaryotes.size;
    }

    /**
     * Alias for proteins Map (polymers) - used by prokaryote factory
     */
    get polymers() {
        return this.proteins;
    }

    /**
     * Remove a polymer from the environment
     * @param {string} polymerId - Polymer ID to remove
     */
    removePolymer(polymerId) {
        this.removeProtein(polymerId);
    }

    /**
     * Add an intention to the environment
     * @param {Intention} intention - Intention zone to add
     * @param {Catalogue} catalogue - Optional catalogue to ensure monomer blueprints exist
     */
    addIntention(intention, catalogue = null) {
        this.intentions.set(intention.id, intention);
        this.stats.intentionCount = this.intentions.size;

        // Initialize exclusion list to ignore molecules that existed before this intention
        // This prevents immediate fulfillment from pre-existing molecules
        if (intention.initializeExclusions) {
            intention.initializeExclusions(this);
        }

        // For polymer intentions, ensure the monomer blueprint exists in the catalogue
        if (intention.type === 'polymer' && intention.blueprint) {
            const cat = catalogue || (typeof window !== 'undefined' ? window.catalogue : null);
            if (cat && typeof cat.ensureMonomerForPolymer === 'function') {
                const monomerBlueprint = cat.ensureMonomerForPolymer(intention.blueprint);
                if (monomerBlueprint) {
                    console.log(`Polymer intention: Monomer blueprint '${monomerBlueprint.name}' ready`);
                } else {
                    console.warn(`Polymer intention: Could not find/create monomer for '${intention.blueprint.name}'`);
                }
            }
        }
    }

    /**
     * Remove an intention from the environment
     * @param {string} intentionId - Intention ID to remove
     */
    removeIntention(intentionId) {
        this.intentions.delete(intentionId);
        this.stats.intentionCount = this.intentions.size;
    }

    /**
     * Get all intentions as array
     */
    getAllIntentions() {
        return Array.from(this.intentions.values());
    }

    /**
     * Get the molecule intention that an atom is inside (if any)
     * @param {Atom} atom - The atom to check
     * @returns {Intention|null} - The intention the atom is inside, or null
     */
    getIntentionForAtom(atom) {
        for (const intention of this.intentions.values()) {
            if (intention.type !== 'molecule') continue;
            if (intention.fulfilled) continue;
            
            const dist = atom.position.distanceTo(intention.position);
            if (dist < intention.radius) {
                return intention;
            }
        }
        return null;
    }

    /**
     * Check if an atom's element is relevant to a molecule intention
     * @param {Atom} atom - The atom to check
     * @param {Intention} intention - The intention to check against
     * @returns {boolean} - True if the atom's element is needed by the intention
     */
    isAtomRelevantToIntention(atom, intention) {
        if (!intention || intention.type !== 'molecule') return false;
        
        const targetComp = intention.getTargetComposition();
        if (!targetComp) return false;
        
        // Check if this atom's element is in the target composition
        return targetComp[atom.symbol] !== undefined && targetComp[atom.symbol] > 0;
    }

    /**
     * Check if an atom would help an unstable molecule inside an intention reach its target
     * @param {Atom} freeAtom - The free atom being considered for bonding
     * @param {Atom} moleculeAtom - An atom that's part of a molecule inside an intention
     * @param {Intention} intention - The intention the molecule is inside
     * @returns {string} - 'needed', 'excess', or 'neutral'
     */
    getAtomBondingPriority(freeAtom, moleculeAtom, intention) {
        if (!intention || intention.type !== 'molecule') return 'neutral';
        if (!moleculeAtom.moleculeId) return 'neutral';
        
        const molecule = this.molecules.get(moleculeAtom.moleculeId);
        if (!molecule) return 'neutral';
        
        // Get the composition delta for this molecule
        const delta = intention.getCompositionDelta(molecule);
        if (!delta) return 'neutral';
        
        // If the molecule already matches the target composition,
        // it should try harder not to bond but can still do so
        if (delta.isMatch) {
            return 'stabilizing';  // Reduced bonding, but not blocked
        }
        
        // Check if the free atom's element is needed
        if (delta.needed[freeAtom.symbol]) {
            return 'needed';
        }
        
        // Check if the free atom's element is already in excess
        if (delta.excess[freeAtom.symbol]) {
            return 'excess';
        }
        
        // Check if adding this atom would create excess
        const targetComp = intention.getTargetComposition();
        if (!targetComp[freeAtom.symbol]) {
            return 'excess';  // Not in target at all
        }
        
        return 'neutral';
    }

    /**
     * Update all intentions - attract components and check completion
     * @param {number} dt - Delta time
     */
    updateIntentions(dt) {
        const fulfilledIds = [];

        for (const intention of this.intentions.values()) {
            intention.update(this, dt);

            if (intention.fulfilled) {
                fulfilledIds.push(intention.id);
            }
        }

        // Remove fulfilled intentions
        for (const id of fulfilledIds) {
            this.removeIntention(id);
        }
    }

    /**
     * Update all cells
     */
    updateCells() {
        for (const cell of this.cells.values()) {
            if (cell.isAlive) {
                cell.update(this);
            }
        }

        // Remove dead cells
        for (const [id, cell] of this.cells) {
            if (!cell.isAlive) {
                this.cells.delete(id);
            }
        }

        this.stats.cellCount = this.cells.size;
    }

    /**
     * Detect and register new polymers from nearby molecules
     */
    updatePolymers() {
        // Only check occasionally for performance
        if (!this._polymerCheckTick) this._polymerCheckTick = 0;
        this._polymerCheckTick++;
        if (this._polymerCheckTick % 30 !== 0) return;

        try {
            // Get molecules that can polymerize (must have free valence to chain)
            // Stable/inert molecules (like H2) are excluded - they have no free bonds
            const freeMolecules = this.getAllMolecules().filter(m =>
                !m.proteinId && m.canPolymerize && m.canPolymerize()
            );

            if (freeMolecules.length < 2) return;

            // Find potential polymer chains
            const newPolymers = findPotentialPolymers(freeMolecules, 120);

            // Register new polymers
            for (const polymer of newPolymers) {
                this.addProtein(polymer);
            }
        } catch (e) {
            console.error('Error in updatePolymers:', e);
        }
    }

    /**
     * Update spatial grid position for an entity
     * @param {Atom} atom - Atom to update
     */
    updateGridPosition(atom) {
        // Remove from old position
        this.removeFromGrid(atom);

        // Add to new position
        const cellX = Math.floor(atom.position.x / this.gridSize);
        const cellY = Math.floor(atom.position.y / this.gridSize);
        const key = `${cellX},${cellY}`;

        if (!this.grid.has(key)) {
            this.grid.set(key, new Set());
        }
        this.grid.get(key).add(atom.id);
        atom._gridKey = key;
    }

    /**
     * Remove entity from grid
     * @param {Atom} atom - Atom to remove
     */
    removeFromGrid(atom) {
        if (atom._gridKey && this.grid.has(atom._gridKey)) {
            this.grid.get(atom._gridKey).delete(atom.id);
        }
    }

    /**
     * Get atoms near a position
     * @param {number} x - X position
     * @param {number} y - Y position
     * @param {number} radius - Search radius
     * @returns {Atom[]}
     */
    getAtomsNear(x, y, radius) {
        const results = [];
        const radiusSq = radius * radius;

        // Check surrounding grid cells
        const minCellX = Math.floor((x - radius) / this.gridSize);
        const maxCellX = Math.floor((x + radius) / this.gridSize);
        const minCellY = Math.floor((y - radius) / this.gridSize);
        const maxCellY = Math.floor((y + radius) / this.gridSize);

        for (let cx = minCellX; cx <= maxCellX; cx++) {
            for (let cy = minCellY; cy <= maxCellY; cy++) {
                const key = `${cx},${cy}`;
                const cell = this.grid.get(key);
                if (!cell) continue;

                for (const atomId of cell) {
                    const atom = this.atoms.get(atomId);
                    if (!atom) continue;

                    const dx = atom.position.x - x;
                    const dy = atom.position.y - y;
                    if (dx * dx + dy * dy <= radiusSq) {
                        results.push(atom);
                    }
                }
            }
        }

        return results;
    }

    /**
     * Get atom at a screen position
     * @param {number} screenX - Screen X coordinate
     * @param {number} screenY - Screen Y coordinate
     * @param {number} scale - Current zoom
     * @param {Vector2} offset - Camera offset
     */
    getAtomAtPosition(screenX, screenY, scale, offset) {
        for (const atom of this.atoms.values()) {
            if (atom.containsPoint(screenX, screenY, scale, offset)) {
                return atom;
            }
        }
        return null;
    }

    /**
     * Apply forces between nearby atoms (repulsion/attraction)
     */
    applyAtomicForces() {
        const atoms = Array.from(this.atoms.values());
        const repulsionStrength = 500;
        const attractionRadius = 80;
        const attractionStrength = 20;

        for (let i = 0; i < atoms.length; i++) {
            const atom1 = atoms[i];

            // Get nearby atoms from grid
            const nearby = this.getAtomsNear(
                atom1.position.x,
                atom1.position.y,
                100
            );

            for (const atom2 of nearby) {
                if (atom1 === atom2) continue;

                const delta = atom1.position.sub(atom2.position);
                const distSq = delta.lengthSquared();
                const minDist = atom1.radius + atom2.radius;
                const minDistSq = minDist * minDist;

                if (distSq === 0) continue;
                const dist = Math.sqrt(distSq);

                // Repulsion when overlapping
                if (distSq < minDistSq) {
                    const overlap = minDist - dist;
                    const force = delta.normalize().mul(repulsionStrength * overlap);
                    atom1.applyForce(force);
                }
                // Molecule repulsion: push atoms away from molecules they were released from
                else if (atom2.moleculeId && atom1.isRepelledFrom(atom2.moleculeId)) {
                    // Strong repulsion force away from the molecule's atoms
                    const repelRadius = 150;
                    if (dist < repelRadius) {
                        const factor = 1 - dist / repelRadius;
                        const force = delta.normalize().mul(repulsionStrength * factor * 1.5);
                        atom1.applyForce(force);
                    }
                }
                // Slight attraction for non-bonded atoms with available valence
                else if (dist < attractionRadius &&
                    !atom1.isBondedTo(atom2) &&
                    atom1.availableValence > 0 &&
                    atom2.availableValence > 0) {
                    const factor = 1 - dist / attractionRadius;
                    const force = delta.normalize().mul(-attractionStrength * factor);
                    atom1.applyForce(force);
                }
            }
        }
    }

    /**
     * Try to form bonds between nearby eligible atoms
     */
    tryFormBonds() {
        const bondingRadius = 40;
        const atoms = Array.from(this.atoms.values());

        for (const atom1 of atoms) {
            if (atom1.availableValence === 0) continue;

            const nearby = this.getAtomsNear(
                atom1.position.x,
                atom1.position.y,
                bondingRadius
            );

            for (const atom2 of nearby) {
                if (atom1 === atom2) continue;
                if (atom1.isBondedTo(atom2)) continue;
                if (atom2.availableValence === 0) continue;
                
                // Check for active repulsion (used by molecule decay to prevent rebonding)
                // Repulsion map stores molecule IDs that released this atom
                if (atom1.repulsions && atom2.moleculeId && atom1.repulsions.has(atom2.moleculeId)) continue;
                if (atom2.repulsions && atom1.moleculeId && atom2.repulsions.has(atom1.moleculeId)) continue;

                const dist = atom1.position.distanceTo(atom2.position);
                const bondDist = (atom1.radius + atom2.radius) * 1.5;

                if (dist < bondDist) {
                    // Base probability increases as atoms get closer
                    let prob = 1 - (dist / bondDist);
                    
                    // Check if either atom is inside a molecule intention
                    const intention1 = this.getIntentionForAtom(atom1);
                    const intention2 = this.getIntentionForAtom(atom2);
                    
                    // If atoms are in different intentions, heavily reduce bonding
                    if (intention1 && intention2 && intention1.id !== intention2.id) {
                        prob *= 0.05; // 95% reduction for cross-intention bonds
                    }
                    // If one or both atoms are in an intention
                    else if (intention1 || intention2) {
                        const intention = intention1 || intention2;
                        
                        // Check if one atom is in a molecule - use smart priority
                        const atom1InMolecule = atom1.moleculeId && this.molecules.has(atom1.moleculeId);
                        const atom2InMolecule = atom2.moleculeId && this.molecules.has(atom2.moleculeId);
                        
                        if (atom1InMolecule || atom2InMolecule) {
                            // One atom is in a molecule, the other is potentially free
                            const moleculeAtom = atom1InMolecule ? atom1 : atom2;
                            const freeAtom = atom1InMolecule ? atom2 : atom1;
                            
                            const priority = this.getAtomBondingPriority(freeAtom, moleculeAtom, intention);
                            
                            if (priority === 'needed') {
                                // This atom is needed by the molecule to reach target - boost!
                                prob *= 2.0;
                            } else if (priority === 'excess') {
                                // This atom would make the molecule further from target - reduce
                                prob *= 0.05;
                            } else if (priority === 'stabilizing') {
                                // Molecule has right composition, trying to stabilize - reduce but allow
                                prob *= 0.15;
                            }
                            // 'neutral' keeps normal probability
                        } else {
                            // Neither in a molecule yet - use simple relevance check
                            const atom1Relevant = this.isAtomRelevantToIntention(atom1, intention);
                            const atom2Relevant = this.isAtomRelevantToIntention(atom2, intention);
                            
                            if (atom1Relevant && atom2Relevant) {
                                prob *= 1.5;
                            } else if (!atom1Relevant || !atom2Relevant) {
                                prob *= 0.1;
                            }
                        }
                    }
                    
                    if (Math.random() < prob * 0.3) {
                        const bond = tryFormBond(atom1, atom2, 1);
                        if (bond) {
                            this.addBond(bond);
                        }
                    }
                }
            }
        }
    }

    /**
     * Detect and register new molecules, merge connected groups
     * Simple logic: Find bond-connected groups, each group = one molecule
     */
    updateMolecules() {
        // Step 1: Get all atoms that have at least one bond
        const bondedAtoms = Array.from(this.atoms.values())
            .filter(a => a.bonds.length > 0);

        if (bondedAtoms.length === 0) {
            // Clear all molecules and reset assignments
            for (const atom of this.atoms.values()) {
                atom.moleculeId = null;
            }
            this.molecules.clear();
            this.stats.moleculeCount = 0;
            return;
        }

        // Step 2: Find all connected groups using BFS via bonds
        const groups = this._findAllConnectedGroups(bondedAtoms);

        // Step 3: Build a fingerprint for each group (sorted atom IDs)
        const groupFingerprints = new Map(); // fingerprint -> group
        for (const group of groups) {
            if (group.length < 2) continue;
            const fingerprint = group.map(a => a.id).sort().join(',');
            groupFingerprints.set(fingerprint, group);
        }

        // Step 4: Find existing molecules that match groups (same atoms)
        const existingMoleculesByFingerprint = new Map();
        for (const molecule of this.molecules.values()) {
            const fingerprint = molecule.atoms.map(a => a.id).sort().join(',');
            existingMoleculesByFingerprint.set(fingerprint, molecule);
        }

        // Step 5: Build new molecules map, preserving existing molecules
        const newMolecules = new Map();
        const atomsToUpdate = new Set();

        for (const [fingerprint, group] of groupFingerprints) {
            const existingMolecule = existingMoleculesByFingerprint.get(fingerprint);

            if (existingMolecule) {
                // Molecule still exists with same atoms - preserve it
                // Update the atoms array to ensure it matches the current group
                existingMolecule.atoms = group;
                newMolecules.set(existingMolecule.id, existingMolecule);
                // Ensure atom references are up to date
                for (const atom of group) {
                    atom.moleculeId = existingMolecule.id;
                }
            } else {
                // New group - create new molecule
                const molecule = new Molecule(group);
                newMolecules.set(molecule.id, molecule);
                for (const atom of group) {
                    atom.moleculeId = molecule.id;
                    atomsToUpdate.add(atom.id);
                }
            }
        }

        // Step 6: Clear molecule ID from atoms not in any molecule
        // Also clear atoms that claim a moleculeId but aren't in that molecule's atom list
        for (const atom of this.atoms.values()) {
            if (atom.bonds.length === 0) {
                atom.moleculeId = null;
            } else if (atom.moleculeId) {
                // Verify the atom is actually in the molecule it claims
                const molecule = newMolecules.get(atom.moleculeId);
                if (!molecule || !molecule.atoms.includes(atom)) {
                    atom.moleculeId = null;
                }
            }
        }

        // Step 7: Replace molecules map
        this.molecules = newMolecules;
        this.stats.moleculeCount = this.molecules.size;
        
        // Step 8: Final validation - ensure all atoms in each molecule have correct moleculeId
        for (const molecule of this.molecules.values()) {
            for (const atom of molecule.atoms) {
                if (atom.moleculeId !== molecule.id) {
                    atom.moleculeId = molecule.id;
                }
            }
        }
    }

    /**
     * Find all connected groups of atoms using BFS
     * @param {Atom[]} atoms - Atoms to group
     */
    _findAllConnectedGroups(atoms) {
        const atomSet = new Set(atoms);
        const visited = new Set();
        const groups = [];

        for (const startAtom of atoms) {
            if (visited.has(startAtom.id)) continue;

            const group = [];
            const queue = [startAtom];

            while (queue.length > 0) {
                const atom = queue.shift();
                if (visited.has(atom.id)) continue;

                visited.add(atom.id);
                group.push(atom);

                // Follow all bonds to connected atoms
                for (const bond of atom.bonds) {
                    const other = bond.getOther(atom);
                    if (!visited.has(other.id)) {
                        queue.push(other);
                    }
                }
            }

            if (group.length > 0) {
                groups.push(group);
            }
        }

        return groups;
    }

    /**
     * Apply boundary constraints
     */
    applyBoundaries() {
        const padding = 50;
        const bounceForce = 100;

        for (const atom of this.atoms.values()) {
            const pos = atom.position;

            if (pos.x < padding) {
                atom.applyForce(new Vector2(bounceForce, 0));
            }
            if (pos.x > this.width - padding) {
                atom.applyForce(new Vector2(-bounceForce, 0));
            }
            if (pos.y < padding) {
                atom.applyForce(new Vector2(0, bounceForce));
            }
            if (pos.y > this.height - padding) {
                atom.applyForce(new Vector2(0, -bounceForce));
            }
        }
    }

    /**
     * Update all entities
     * @param {number} dt - Delta time
     */
    update(dt) {
        // Synchronize bonds first - clean up any broken/stale bonds
        this.syncBonds();
        
        // Apply forces
        this.applyBoundaries();
        this.applyAtomicForces();

        // Update intention zones (attract components toward blueprints)
        this.updateIntentions(dt);

        // Apply bond spring forces
        for (const bond of this.bonds.values()) {
            bond.applySpringForce(0.6);
        }

        // Update atoms
        for (const atom of this.atoms.values()) {
            const oldKey = atom._gridKey;
            atom.update(dt);

            // Update grid if moved significantly
            const newCellX = Math.floor(atom.position.x / this.gridSize);
            const newCellY = Math.floor(atom.position.y / this.gridSize);
            const newKey = `${newCellX},${newCellY}`;

            if (oldKey !== newKey) {
                this.updateGridPosition(atom);
            }
        }

        // Try to form new bonds
        this.tryFormBonds();

        // Update molecules (handles decay for unstable molecules)
        for (const molecule of this.molecules.values()) {
            molecule.update(dt, this);
        }

        // Update molecule registry (detects new molecules, cleans broken ones)
        this.updateMolecules();

        // Try to form polymers from nearby stable molecules
        this.updatePolymers();

        // Update cells
        this.updateCells();

        // Update prokaryotes (chemistry-based cells)
        this.updateProkaryotes(dt);
    }

    /**
     * Get all atoms as array
     */
    getAllAtoms() {
        return Array.from(this.atoms.values());
    }

    /**
     * Get all bonds as array
     */
    getAllBonds() {
        return Array.from(this.bonds.values());
    }

    /**
     * Get all molecules as array
     */
    getAllMolecules() {
        return Array.from(this.molecules.values());
    }

    /**
     * Get all proteins as array
     */
    getAllProteins() {
        return Array.from(this.proteins.values());
    }

    /**
     * Clear the environment
     */
    clear() {
        this.atoms.clear();
        this.bonds.clear();
        this.molecules.clear();
        this.proteins.clear();
        this.cells.clear();
        this.prokaryotes.clear();
        this.organisms.clear();
        this.intentions.clear();
        this.grid.clear();
        this.stats = {
            atomCount: 0,
            moleculeCount: 0,
            proteinCount: 0,
            cellCount: 0,
            prokaryoteCount: 0,
            organismCount: 0,
            intentionCount: 0
        };
    }

    /**
     * Serialize environment state
     */
    serialize() {
        return {
            width: this.width,
            height: this.height,
            temperature: this.temperature,
            pressure: this.pressure,
            atoms: Array.from(this.atoms.values()).map(a => a.serialize()),
            bonds: Array.from(this.bonds.values()).map(b => b.serialize()),
            molecules: Array.from(this.molecules.values()).map(m => ({
                id: m.id,
                name: m.name,
                atomIds: m.atoms.map(a => a.id)
            }))
        };
    }

    /**
     * Load environment from serialized data
     */
    deserialize(data) {
        this.clear();

        this.width = data.width;
        this.height = data.height;
        this.temperature = data.temperature;
        this.pressure = data.pressure;

        // Load atoms
        const atomMap = new Map();
        for (const atomData of data.atoms) {
            const atom = Atom.deserialize(atomData);
            atomMap.set(atom.id, atom);
            this.addAtom(atom);
        }

        // Load bonds
        for (const bondData of data.bonds) {
            const bond = Bond.deserialize(bondData, atomMap);
            this.addBond(bond);
        }

        // Load molecules
        for (const molData of data.molecules) {
            const atoms = molData.atomIds.map(id => atomMap.get(id));
            const molecule = new Molecule(atoms);
            molecule.id = molData.id;
            molecule.name = molData.name;
            this.addMolecule(molecule);
        }
    }
}

// Make available globally
window.Environment = Environment;



// ==== src/core/simulation.js ====
/**
 * Simulation Engine
 * Main loop and timing control
 */

class Simulation {
    /**
     * Create a new simulation
     * @param {Environment} environment - The environment to simulate
     */
    constructor(environment) {
        this.environment = environment;

        // Timing
        this.running = false;
        this.tick = 0;
        this.speed = 1.0;  // Simulation speed multiplier
        this.targetFPS = 60;
        this.actualFPS = 0;
        this.lastTime = 0;
        this.accumulator = 0;
        this.fixedDt = 1 / 60;  // Fixed timestep

        // Animation frame request
        this.frameId = null;

        // Callbacks
        this.onTick = null;
        this.onUpdate = null;

        // Bound update for requestAnimationFrame
        this._update = this._update.bind(this);
    }

    /**
     * Start the simulation
     */
    start() {
        if (this.running) return;

        this.running = true;
        this.lastTime = performance.now();
        this.frameId = requestAnimationFrame(this._update);
    }

    /**
     * Pause the simulation
     */
    pause() {
        this.running = false;
        if (this.frameId) {
            cancelAnimationFrame(this.frameId);
            this.frameId = null;
        }
    }

    /**
     * Toggle running state
     */
    toggle() {
        if (this.running) {
            this.pause();
        } else {
            this.start();
        }
    }

    /**
     * Advance one step
     */
    step() {
        this._simulationStep(this.fixedDt);
    }

    /**
     * Set simulation speed
     * @param {number} speed - Speed multiplier (0.1 to 10)
     */
    setSpeed(speed) {
        this.speed = Utils.clamp(speed, 0.1, 10);
    }

    /**
     * Main update loop
     * @param {number} currentTime - Current timestamp
     */
    _update(currentTime) {
        if (!this.running) return;

        // Calculate delta time
        const deltaTime = Math.min((currentTime - this.lastTime) / 1000, 0.1);
        this.lastTime = currentTime;

        // Track FPS
        this.actualFPS = 1 / deltaTime;

        // Accumulator for fixed timestep
        this.accumulator += deltaTime * this.speed;

        // Run simulation steps
        while (this.accumulator >= this.fixedDt) {
            this._simulationStep(this.fixedDt);
            this.accumulator -= this.fixedDt;
        }

        // Call update callback (for rendering)
        if (this.onUpdate) {
            this.onUpdate(deltaTime);
        }

        // Continue loop
        this.frameId = requestAnimationFrame(this._update);
    }

    /**
     * Single simulation step
     * @param {number} dt - Fixed delta time
     */
    _simulationStep(dt) {
        this.tick++;

        // Update environment
        this.environment.update(dt);

        // Call tick callback
        if (this.onTick) {
            this.onTick(this.tick);
        }
    }

    /**
     * Reset simulation
     */
    reset() {
        this.pause();
        this.tick = 0;
        this.environment.clear();
    }

    /**
     * Get statistics
     */
    getStats() {
        return {
            tick: this.tick,
            fps: Math.round(this.actualFPS),
            running: this.running,
            speed: this.speed,
            ...this.environment.stats
        };
    }
}

// Make available globally
window.Simulation = Simulation;


// ==== src/catalogue/blueprint.js ====
/**
 * Blueprint Classes
 * Templates for spawning entities from the catalogue
 */

/**
 * Base Blueprint class
 */
class Blueprint {
    constructor(type, name) {
        this.id = Utils.generateId();
        this.type = type;
        this.name = name;
        this.createdAt = Date.now();
        this.description = '';
        this.tags = [];
    }

    /**
     * Generate a preview rendering
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {number} x - Center X
     * @param {number} y - Center Y
     * @param {number} size - Preview size
     */
    renderPreview(ctx, x, y, size) {
        // Override in subclasses
        ctx.fillStyle = '#6366f1';
        ctx.fillRect(x - size / 2, y - size / 2, size, size);
    }

    /**
     * Serialize to plain object
     */
    serialize() {
        return {
            id: this.id,
            type: this.type,
            name: this.name,
            createdAt: this.createdAt,
            description: this.description,
            tags: this.tags
        };
    }
}

/**
 * Molecule Blueprint
 */
class MoleculeBlueprint extends Blueprint {
    /**
     * Create from an existing molecule
     * @param {Molecule} molecule - Source molecule
     * @param {string} name - Blueprint name
     */
    constructor(molecule, name = null) {
        super('molecule', name || molecule.formula);

        this.formula = molecule.formula;
        this.fingerprint = molecule.fingerprint;

        // Store relative positions from center of mass
        const center = molecule.centerOfMass;
        this.atomData = molecule.atoms.map((atom, index) => ({
            index,
            symbol: atom.symbol,
            relX: atom.position.x - center.x,
            relY: atom.position.y - center.y
        }));

        // Store bonds by atom indices
        this.bondData = molecule.bonds.map(bond => ({
            atom1Index: molecule.atoms.indexOf(bond.atom1),
            atom2Index: molecule.atoms.indexOf(bond.atom2),
            order: bond.order
        }));

        this.mass = molecule.mass;
        this.isStable = molecule.isStable();
    }

    /**
     * Instantiate this blueprint at a position
     * @param {number} x - X position
     * @param {number} y - Y position
     * @returns {Molecule} New molecule instance
     */
    instantiate(x, y) {
        // Create atoms at relative positions (preserves molecule shape)
        const atoms = this.atomData.map(data =>
            new Atom(data.symbol, x + data.relX, y + data.relY)
        );

        // Create bonds
        for (const bondData of this.bondData) {
            const atom1 = atoms[bondData.atom1Index];
            const atom2 = atoms[bondData.atom2Index];
            new Bond(atom1, atom2, bondData.order);
        }

        // Create molecule with blueprint reference for reconstruction
        const molecule = new Molecule(atoms);
        molecule.name = this.name;
        molecule.blueprintRef = this; // Link to blueprint for shape reconstruction
        molecule.abstracted = true;   // Start as abstracted since shape is from blueprint

        return molecule;
    }

    /**
     * Render preview
     */
    renderPreview(ctx, x, y, size) {
        const scale = size / 100;

        // Draw bonds
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 1;

        for (const bondData of this.bondData) {
            const a1 = this.atomData[bondData.atom1Index];
            const a2 = this.atomData[bondData.atom2Index];

            ctx.beginPath();
            ctx.moveTo(x + a1.relX * scale, y + a1.relY * scale);
            ctx.lineTo(x + a2.relX * scale, y + a2.relY * scale);
            ctx.stroke();
        }

        // Draw atoms
        for (const atomData of this.atomData) {
            const element = getElement(atomData.symbol);
            const ax = x + atomData.relX * scale;
            const ay = y + atomData.relY * scale;
            const radius = Math.max(4, element.radius * scale * 0.3);

            ctx.beginPath();
            ctx.arc(ax, ay, radius, 0, Math.PI * 2);
            ctx.fillStyle = element.color;
            ctx.fill();
        }
    }

    serialize() {
        return {
            ...super.serialize(),
            formula: this.formula,
            fingerprint: this.fingerprint,
            atomData: this.atomData,
            bondData: this.bondData,
            mass: this.mass,
            isStable: this.isStable
        };
    }

    static deserialize(data) {
        const blueprint = Object.assign(
            Object.create(MoleculeBlueprint.prototype),
            data
        );
        return blueprint;
    }
}

/**
 * Protein Blueprint
 */
class ProteinBlueprint extends Blueprint {
    /**
     * Create from an existing protein
     * @param {Protein} protein - Source protein
     * @param {string} name - Blueprint name
     */
    constructor(protein, name = null) {
        super('protein', name || `Protein-${protein.molecules.length}`);

        this.sequence = protein.sequence;
        this.fingerprint = protein.fingerprint;
        this.moleculeCount = protein.molecules.length;

        // Store molecule blueprints
        this.moleculeBlueprints = protein.molecules.map(mol =>
            new MoleculeBlueprint(mol)
        );

        // Store relative positions
        const center = protein.getCenter();
        this.moleculePositions = protein.molecules.map(mol => {
            const molCenter = mol.getCenter();
            return {
                relX: molCenter.x - center.x,
                relY: molCenter.y - center.y
            };
        });

        this.activeSites = protein.activeSites;
        this.mass = protein.mass;
        this.isStable = protein.isStable();
    }

    /**
     * Instantiate this blueprint at a position
     * @param {number} x - X position
     * @param {number} y - Y position
     * @returns {Protein} New protein instance
     */
    instantiate(x, y) {
        const molecules = [];

        for (let i = 0; i < this.moleculeBlueprints.length; i++) {
            const bp = this.moleculeBlueprints[i];
            const pos = this.moleculePositions[i];
            const mol = bp.instantiate(x + pos.relX, y + pos.relY);
            molecules.push(mol);
        }

        const protein = new Protein(molecules, this.name);

        // Restore active sites
        for (const site of this.activeSites) {
            protein.addActiveSite(site);
        }

        return protein;
    }

    /**
     * Render preview
     */
    renderPreview(ctx, x, y, size) {
        const scale = size / 150;

        // Draw chain connections
        ctx.strokeStyle = '#8b5cf6';
        ctx.lineWidth = 2;
        ctx.beginPath();

        for (let i = 0; i < this.moleculePositions.length - 1; i++) {
            const p1 = this.moleculePositions[i];
            const p2 = this.moleculePositions[i + 1];
            ctx.moveTo(x + p1.relX * scale, y + p1.relY * scale);
            ctx.lineTo(x + p2.relX * scale, y + p2.relY * scale);
        }
        ctx.stroke();

        // Draw molecule blobs
        for (const pos of this.moleculePositions) {
            ctx.beginPath();
            ctx.arc(x + pos.relX * scale, y + pos.relY * scale, 5, 0, Math.PI * 2);
            ctx.fillStyle = '#a78bfa';
            ctx.fill();
        }
    }

    serialize() {
        return {
            ...super.serialize(),
            sequence: this.sequence,
            fingerprint: this.fingerprint,
            moleculeCount: this.moleculeCount,
            moleculeBlueprints: this.moleculeBlueprints.map(bp => bp.serialize()),
            moleculePositions: this.moleculePositions,
            activeSites: this.activeSites,
            mass: this.mass,
            isStable: this.isStable
        };
    }

    static deserialize(data) {
        const blueprint = Object.assign(
            Object.create(ProteinBlueprint.prototype),
            data
        );
        blueprint.moleculeBlueprints = data.moleculeBlueprints.map(d =>
            MoleculeBlueprint.deserialize(d)
        );
        return blueprint;
    }
}

/**
 * Cell Blueprint (placeholder for Phase 2)
 */
class CellBlueprint extends Blueprint {
    constructor(name) {
        super('cell', name);
        this.molecules = [];
        this.proteins = [];  // Can also contain proteins
        this.behavior = null;
        this.genome = null;
    }

    instantiate(x, y) {
        // TODO: Implement in Phase 2
        console.warn('CellBlueprint.instantiate not yet implemented');
        return null;
    }
}

/**
 * Organism Blueprint (placeholder for Phase 3)
 */
class OrganismBlueprint extends Blueprint {
    constructor(name) {
        super('organism', name);
        this.cells = [];
        this.genome = null;
        this.phenotype = null;
    }

    instantiate(x, y) {
        // TODO: Implement in Phase 3
        console.warn('OrganismBlueprint.instantiate not yet implemented');
        return null;
    }
}

// Make available globally
window.Blueprint = Blueprint;
window.MoleculeBlueprint = MoleculeBlueprint;
window.ProteinBlueprint = ProteinBlueprint;
window.CellBlueprint = CellBlueprint;
window.OrganismBlueprint = OrganismBlueprint;


// ==== src/catalogue/monomer-templates.js ====
/**
 * Monomer Templates
 * Pre-defined molecules that can polymerize into polymers
 * 
 * A monomer is a stable molecule that can chain with identical copies
 * to form a polymer. This matches real chemistry:
 * - Ethylene (C2H4) ‚Üí Polyethylene
 * - Glucose (C6H12O6) ‚Üí Starch/Cellulose
 * - Amino acids ‚Üí Proteins
 * - Nucleotides ‚Üí DNA/RNA
 */

// Polymerization types
const PolymerizationType = {
    ADDITION: 'addition',       // Double bond opens, monomers link (e.g., polyethylene)
    CONDENSATION: 'condensation' // Functional groups react, small molecule released (e.g., proteins)
};

/**
 * Monomer Template definitions
 * Each template defines a molecule that can be used to form polymers
 */
const MONOMER_TEMPLATES = {
    // ===== SIMPLE SYNTHETIC POLYMERS =====

    ETHYLENE: {
        id: 'ethylene',
        name: 'Ethylene',
        formula: 'C2H4',
        polymerizationType: PolymerizationType.ADDITION,
        polymerName: 'Polyethylene',
        polymerCategory: 'generic',
        description: 'Simplest alkene, forms polyethylene plastic',
        minMonomersForPolymer: 3,
        // Atom layout for blueprint (relative positions)
        atomLayout: [
            { symbol: 'C', relX: -15, relY: 0 },
            { symbol: 'C', relX: 15, relY: 0 },
            { symbol: 'H', relX: -30, relY: -15 },
            { symbol: 'H', relX: -30, relY: 15 },
            { symbol: 'H', relX: 30, relY: -15 },
            { symbol: 'H', relX: 30, relY: 15 }
        ],
        // Bond layout (indices into atomLayout)
        bondLayout: [
            { atom1: 0, atom2: 1, order: 2 },  // C=C double bond
            { atom1: 0, atom2: 2, order: 1 },  // C-H
            { atom1: 0, atom2: 3, order: 1 },  // C-H
            { atom1: 1, atom2: 4, order: 1 },  // C-H
            { atom1: 1, atom2: 5, order: 1 }   // C-H
        ]
    },

    // ===== BIOLOGICAL MONOMERS - CARBOHYDRATES =====

    GLUCOSE: {
        id: 'glucose',
        name: 'Glucose',
        formula: 'C6H12O6',
        polymerizationType: PolymerizationType.CONDENSATION,
        polymerName: 'Polysaccharide',
        polymerCategory: 'carbohydrate',
        description: 'Sugar monomer, forms starch and cellulose',
        minMonomersForPolymer: 2,
        condensationByproduct: 'H2O',
        cellRole: 'energy',
        // Simplified ring structure
        atomLayout: [
            // Ring carbons
            { symbol: 'C', relX: 0, relY: 0 },
            { symbol: 'C', relX: 20, relY: -10 },
            { symbol: 'C', relX: 40, relY: 0 },
            { symbol: 'C', relX: 40, relY: 20 },
            { symbol: 'C', relX: 20, relY: 30 },
            { symbol: 'O', relX: 0, relY: 20 },  // Ring oxygen
            // CH2OH group
            { symbol: 'C', relX: -20, relY: -10 },
            { symbol: 'O', relX: -35, relY: -20 },
            { symbol: 'H', relX: -45, relY: -30 },
            // OH groups (simplified)
            { symbol: 'O', relX: 20, relY: -25 },
            { symbol: 'O', relX: 55, relY: 0 },
            { symbol: 'O', relX: 55, relY: 20 },
            // Hydrogens
            { symbol: 'H', relX: 25, relY: -35 },
            { symbol: 'H', relX: 65, relY: 0 },
            { symbol: 'H', relX: 65, relY: 20 },
            { symbol: 'H', relX: -25, relY: 0 },
            { symbol: 'H', relX: 25, relY: 40 },
            { symbol: 'H', relX: -10, relY: -20 }
        ],
        bondLayout: [
            // Ring bonds
            { atom1: 0, atom2: 1, order: 1 },
            { atom1: 1, atom2: 2, order: 1 },
            { atom1: 2, atom2: 3, order: 1 },
            { atom1: 3, atom2: 4, order: 1 },
            { atom1: 4, atom2: 5, order: 1 },
            { atom1: 5, atom2: 0, order: 1 },
            // CH2OH
            { atom1: 0, atom2: 6, order: 1 },
            { atom1: 6, atom2: 7, order: 1 },
            { atom1: 7, atom2: 8, order: 1 },
            // OH groups
            { atom1: 1, atom2: 9, order: 1 },
            { atom1: 2, atom2: 10, order: 1 },
            { atom1: 3, atom2: 11, order: 1 },
            // H bonds
            { atom1: 9, atom2: 12, order: 1 },
            { atom1: 10, atom2: 13, order: 1 },
            { atom1: 11, atom2: 14, order: 1 },
            { atom1: 6, atom2: 15, order: 1 },
            { atom1: 4, atom2: 16, order: 1 },
            { atom1: 6, atom2: 17, order: 1 }
        ]
    },

    // ===== BIOLOGICAL MONOMERS - AMINO ACIDS =====

    GLYCINE: {
        id: 'glycine',
        name: 'Glycine',
        formula: 'C2H5NO2',
        polymerizationType: PolymerizationType.CONDENSATION,
        polymerName: 'Protein',
        polymerCategory: 'protein',
        description: 'Simplest amino acid, forms proteins via peptide bonds',
        minMonomersForPolymer: 2,
        condensationByproduct: 'H2O',
        cellRole: 'structure',
        // H2N-CH2-COOH structure
        atomLayout: [
            { symbol: 'N', relX: -30, relY: 0 },    // Amino nitrogen
            { symbol: 'C', relX: 0, relY: 0 },      // Alpha carbon
            { symbol: 'C', relX: 30, relY: 0 },     // Carboxyl carbon
            { symbol: 'O', relX: 45, relY: -15 },   // Carboxyl O (double bond)
            { symbol: 'O', relX: 45, relY: 15 },    // Carboxyl OH
            { symbol: 'H', relX: -45, relY: -10 },  // NH2 hydrogen
            { symbol: 'H', relX: -45, relY: 10 },   // NH2 hydrogen
            { symbol: 'H', relX: 0, relY: -20 },    // CH2 hydrogen
            { symbol: 'H', relX: 0, relY: 20 },     // CH2 hydrogen
            { symbol: 'H', relX: 60, relY: 20 }     // OH hydrogen
        ],
        bondLayout: [
            { atom1: 0, atom2: 1, order: 1 },  // N-C
            { atom1: 1, atom2: 2, order: 1 },  // C-C
            { atom1: 2, atom2: 3, order: 2 },  // C=O
            { atom1: 2, atom2: 4, order: 1 },  // C-O
            { atom1: 0, atom2: 5, order: 1 },  // N-H
            { atom1: 0, atom2: 6, order: 1 },  // N-H
            { atom1: 1, atom2: 7, order: 1 },  // C-H
            { atom1: 1, atom2: 8, order: 1 },  // C-H
            { atom1: 4, atom2: 9, order: 1 }   // O-H
        ]
    },

    // ===== BIOLOGICAL MONOMERS - NUCLEOTIDES =====

    ADENINE_NUCLEOTIDE: {
        id: 'adenine_nucleotide',
        name: 'Adenine Nucleotide',
        formula: 'C10H14N5O6P',  // Simplified AMP
        polymerizationType: PolymerizationType.CONDENSATION,
        polymerName: 'Nucleic Acid',
        polymerCategory: 'nucleic_acid',
        description: 'DNA/RNA building block with adenine base',
        minMonomersForPolymer: 2,
        condensationByproduct: 'H2O',
        cellRole: 'genetics',
        // Simplified structure (base + sugar + phosphate)
        atomLayout: [
            // Phosphate group
            { symbol: 'P', relX: -40, relY: 0 },
            { symbol: 'O', relX: -55, relY: -15 },
            { symbol: 'O', relX: -55, relY: 15 },
            { symbol: 'O', relX: -40, relY: -25 },
            { symbol: 'O', relX: -25, relY: 0 },
            // Ribose sugar (simplified)
            { symbol: 'C', relX: -5, relY: 0 },
            { symbol: 'C', relX: 10, relY: -15 },
            { symbol: 'C', relX: 25, relY: -5 },
            { symbol: 'O', relX: 15, relY: 10 },
            // Adenine base (simplified)
            { symbol: 'N', relX: 40, relY: -10 },
            { symbol: 'C', relX: 55, relY: -20 },
            { symbol: 'N', relX: 70, relY: -10 },
            { symbol: 'C', relX: 70, relY: 10 },
            { symbol: 'C', relX: 55, relY: 20 },
            { symbol: 'N', relX: 40, relY: 10 },
            // Hydrogens (representative)
            { symbol: 'H', relX: -60, relY: -25 },
            { symbol: 'H', relX: -60, relY: 25 },
            { symbol: 'H', relX: 55, relY: -35 },
            { symbol: 'H', relX: 85, relY: -15 },
            { symbol: 'H', relX: 55, relY: 35 }
        ],
        bondLayout: [
            // Phosphate
            { atom1: 0, atom2: 1, order: 2 },
            { atom1: 0, atom2: 2, order: 1 },
            { atom1: 0, atom2: 3, order: 1 },
            { atom1: 0, atom2: 4, order: 1 },
            // Phosphate to sugar
            { atom1: 4, atom2: 5, order: 1 },
            // Sugar ring
            { atom1: 5, atom2: 6, order: 1 },
            { atom1: 6, atom2: 7, order: 1 },
            { atom1: 7, atom2: 8, order: 1 },
            { atom1: 8, atom2: 5, order: 1 },
            // Sugar to base
            { atom1: 7, atom2: 9, order: 1 },
            // Adenine base
            { atom1: 9, atom2: 10, order: 1 },
            { atom1: 10, atom2: 11, order: 2 },
            { atom1: 11, atom2: 12, order: 1 },
            { atom1: 12, atom2: 13, order: 2 },
            { atom1: 13, atom2: 14, order: 1 },
            { atom1: 14, atom2: 9, order: 1 },
            // Hydrogens
            { atom1: 1, atom2: 15, order: 1 },
            { atom1: 2, atom2: 16, order: 1 },
            { atom1: 10, atom2: 17, order: 1 },
            { atom1: 11, atom2: 18, order: 1 },
            { atom1: 13, atom2: 19, order: 1 }
        ]
    },

    // ===== BIOLOGICAL MONOMERS - LIPIDS =====

    FATTY_ACID: {
        id: 'fatty_acid',
        name: 'Fatty Acid',
        formula: 'C4H8O2',  // Butyric acid (simplified)
        polymerizationType: PolymerizationType.CONDENSATION,
        polymerName: 'Lipid Chain',
        polymerCategory: 'lipid',
        description: 'Short-chain fatty acid, forms lipid membranes',
        minMonomersForPolymer: 2,
        condensationByproduct: 'H2O',
        cellRole: 'membrane',
        // CH3-CH2-CH2-COOH structure
        atomLayout: [
            { symbol: 'C', relX: -45, relY: 0 },   // Methyl C
            { symbol: 'C', relX: -15, relY: 0 },   // CH2
            { symbol: 'C', relX: 15, relY: 0 },    // CH2
            { symbol: 'C', relX: 45, relY: 0 },    // Carboxyl C
            { symbol: 'O', relX: 60, relY: -15 },  // C=O
            { symbol: 'O', relX: 60, relY: 15 },   // C-OH
            { symbol: 'H', relX: -55, relY: -12 },
            { symbol: 'H', relX: -55, relY: 12 },
            { symbol: 'H', relX: -55, relY: 0 },   // Extra H for CH3
            { symbol: 'H', relX: -15, relY: -15 },
            { symbol: 'H', relX: -15, relY: 15 },
            { symbol: 'H', relX: 15, relY: -15 },
            { symbol: 'H', relX: 15, relY: 15 },
            { symbol: 'H', relX: 75, relY: 20 }    // OH hydrogen
        ],
        bondLayout: [
            { atom1: 0, atom2: 1, order: 1 },
            { atom1: 1, atom2: 2, order: 1 },
            { atom1: 2, atom2: 3, order: 1 },
            { atom1: 3, atom2: 4, order: 2 },
            { atom1: 3, atom2: 5, order: 1 },
            { atom1: 0, atom2: 6, order: 1 },
            { atom1: 0, atom2: 7, order: 1 },
            { atom1: 0, atom2: 8, order: 1 },
            { atom1: 1, atom2: 9, order: 1 },
            { atom1: 1, atom2: 10, order: 1 },
            { atom1: 2, atom2: 11, order: 1 },
            { atom1: 2, atom2: 12, order: 1 },
            { atom1: 5, atom2: 13, order: 1 }
        ]
    }
};

/**
 * Get a monomer template by ID
 * @param {string} id - Template ID
 * @returns {Object|null} Monomer template
 */
function getMonomerTemplate(id) {
    return MONOMER_TEMPLATES[id.toUpperCase()] || null;
}

/**
 * Get all monomer templates
 * @returns {Object[]} Array of all templates
 */
function getAllMonomerTemplates() {
    return Object.values(MONOMER_TEMPLATES);
}

/**
 * Get monomer templates by polymer category
 * @param {string} category - Polymer category (protein, carbohydrate, etc.)
 * @returns {Object[]} Matching templates
 */
function getMonomersByCategory(category) {
    return Object.values(MONOMER_TEMPLATES).filter(t =>
        t.polymerCategory === category
    );
}

/**
 * Find a monomer template that matches a molecule's formula
 * @param {string} formula - Molecule formula
 * @returns {Object|null} Matching template or null
 */
function findMonomerByFormula(formula) {
    return Object.values(MONOMER_TEMPLATES).find(t =>
        t.formula === formula
    ) || null;
}

/**
 * Check if a formula matches any known monomer
 * @param {string} formula - Molecule formula
 * @returns {boolean}
 */
function isKnownMonomer(formula) {
    return findMonomerByFormula(formula) !== null;
}

/**
 * Create a MoleculeBlueprint from a monomer template
 * This allows monomer templates to be used in the catalogue like discovered molecules
 * @param {Object} template - Monomer template from MONOMER_TEMPLATES
 * @returns {Object} A blueprint-like object compatible with MoleculeBlueprint
 */
function createMonomerBlueprint(template) {
    if (!template || !template.atomLayout) {
        console.warn('createMonomerBlueprint: Invalid template', template);
        return null;
    }

    // Build atomData in blueprint format (with indices)
    const atomData = template.atomLayout.map((atom, index) => ({
        index,
        symbol: atom.symbol,
        relX: atom.relX,
        relY: atom.relY
    }));

    // Build bondData in blueprint format
    const bondData = (template.bondLayout || []).map(bond => ({
        atom1Index: bond.atom1,
        atom2Index: bond.atom2,
        order: bond.order || 1
    }));

    // Calculate mass from atoms
    let mass = 0;
    for (const atom of atomData) {
        const element = typeof getElement === 'function' ? getElement(atom.symbol) : null;
        if (element) {
            mass += element.mass;
        }
    }

    // Generate a fingerprint based on the template
    const fingerprint = `monomer:${template.id}:${template.formula}`;

    // Create a blueprint-compatible object
    const blueprint = {
        id: template.id,
        type: 'molecule',
        name: template.name,
        formula: template.formula,
        fingerprint: fingerprint,
        atomData: atomData,
        bondData: bondData,
        mass: mass,
        isStable: true, // Monomers are stable molecules
        createdAt: Date.now(),
        description: template.description || `Monomer for ${template.polymerName}`,
        tags: ['monomer', template.polymerCategory || 'generic'],
        isMonomer: true,
        monomerId: template.id,
        polymerCategory: template.polymerCategory,
        polymerName: template.polymerName,
        cellRole: template.cellRole || null,

        // Implement instantiate method to create actual molecules
        instantiate: function(x, y) {
            // Create atoms at relative positions
            const atoms = this.atomData.map(data =>
                new Atom(data.symbol, x + data.relX, y + data.relY)
            );

            // Create bonds
            for (const bondInfo of this.bondData) {
                const atom1 = atoms[bondInfo.atom1Index];
                const atom2 = atoms[bondInfo.atom2Index];
                if (atom1 && atom2) {
                    new Bond(atom1, atom2, bondInfo.order);
                }
            }

            // Create molecule
            const molecule = new Molecule(atoms);
            molecule.name = this.name;
            molecule.isMonomer = true;
            molecule.monomerId = this.monomerId;
            molecule.blueprintRef = this;

            return molecule;
        },

        // Implement serialize for persistence
        serialize: function() {
            return {
                id: this.id,
                type: this.type,
                name: this.name,
                formula: this.formula,
                fingerprint: this.fingerprint,
                atomData: this.atomData,
                bondData: this.bondData,
                mass: this.mass,
                isStable: this.isStable,
                createdAt: this.createdAt,
                description: this.description,
                tags: this.tags,
                isMonomer: this.isMonomer,
                monomerId: this.monomerId,
                polymerCategory: this.polymerCategory,
                polymerName: this.polymerName,
                cellRole: this.cellRole
            };
        },

        // Render preview for catalogue UI
        renderPreview: function(ctx, x, y, size) {
            const scale = size / 100;

            // Draw bonds
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 1;

            for (const bondInfo of this.bondData) {
                const a1 = this.atomData[bondInfo.atom1Index];
                const a2 = this.atomData[bondInfo.atom2Index];
                if (!a1 || !a2) continue;

                ctx.beginPath();
                ctx.moveTo(x + a1.relX * scale, y + a1.relY * scale);
                ctx.lineTo(x + a2.relX * scale, y + a2.relY * scale);
                ctx.stroke();
            }

            // Draw atoms
            for (const atomInfo of this.atomData) {
                const element = typeof getElement === 'function' ? getElement(atomInfo.symbol) : null;
                const ax = x + atomInfo.relX * scale;
                const ay = y + atomInfo.relY * scale;
                const radius = Math.max(3, (element?.radius || 10) * scale * 0.25);

                ctx.beginPath();
                ctx.arc(ax, ay, radius, 0, Math.PI * 2);
                ctx.fillStyle = element?.color || '#888';
                ctx.fill();
            }
        }
    };

    return blueprint;
}

/**
 * Get all monomer templates as MoleculeBlueprints
 * @returns {Object[]} Array of blueprint objects
 */
function getAllMonomerBlueprints() {
    const blueprints = [];
    for (const template of Object.values(MONOMER_TEMPLATES)) {
        const bp = createMonomerBlueprint(template);
        if (bp) {
            blueprints.push(bp);
        }
    }
    return blueprints;
}

/**
 * Get a monomer blueprint by monomer ID
 * @param {string} monomerId - The monomer template ID
 * @returns {Object|null} Blueprint or null
 */
function getMonomerBlueprint(monomerId) {
    const template = getMonomerTemplate(monomerId);
    if (!template) return null;
    return createMonomerBlueprint(template);
}

// Make available globally
window.PolymerizationType = PolymerizationType;
window.MONOMER_TEMPLATES = MONOMER_TEMPLATES;
window.getMonomerTemplate = getMonomerTemplate;
window.getAllMonomerTemplates = getAllMonomerTemplates;
window.getMonomersByCategory = getMonomersByCategory;
window.findMonomerByFormula = findMonomerByFormula;
window.isKnownMonomer = isKnownMonomer;
window.createMonomerBlueprint = createMonomerBlueprint;
window.getAllMonomerBlueprints = getAllMonomerBlueprints;
window.getMonomerBlueprint = getMonomerBlueprint;


// ==== src/catalogue/polymer-blueprints.js ====
/**
 * Polymer Blueprints
 * Pre-defined templates for cell-essential polymers
 * Now linked to specific monomer templates from monomer-templates.js
 */

// Essential polymer templates for cell formation
// NEW: Each polymer now references a specific monomer template
const CELL_ESSENTIAL_POLYMERS = {
    // Membrane Components (Lipids)
    // Monomer: Fatty Acid (C4H8O2) ‚Üí Lipid Chain
    PHOSPHOLIPID: {
        id: 'phospholipid',
        name: 'Phospholipid Bilayer',
        type: 'lipid',
        description: 'Forms the cell membrane bilayer from fatty acid monomers',
        monomerId: 'FATTY_ACID',        // Reference to MONOMER_TEMPLATES
        minMonomers: 3,                  // Renamed from minMolecules
        essential: true,
        cellRole: 'membrane'
    },
    FATTY_ACID_CHAIN: {
        id: 'fatty_acid_chain',
        name: 'Fatty Acid Chain',
        type: 'lipid',
        description: 'Chain of fatty acid monomers for energy storage',
        monomerId: 'FATTY_ACID',
        minMonomers: 2,
        essential: false,
        cellRole: 'membrane'
    },

    // Structural Components (Proteins)
    // Monomer: Glycine (C2H5NO2) ‚Üí Protein
    STRUCTURAL_PROTEIN: {
        id: 'structural_protein',
        name: 'Structural Protein',
        type: 'protein',
        description: 'Provides cell structure from glycine amino acid monomers',
        monomerId: 'GLYCINE',
        minMonomers: 4,
        essential: true,
        cellRole: 'structure'
    },
    ENZYME: {
        id: 'enzyme',
        name: 'Enzyme',
        type: 'protein',
        description: 'Catalyzes chemical reactions',
        monomerId: 'GLYCINE',
        minMonomers: 3,
        essential: false,
        cellRole: 'metabolism'
    },
    TRANSPORT_PROTEIN: {
        id: 'transport_protein',
        name: 'Transport Protein',
        type: 'protein',
        description: 'Moves molecules across membrane',
        monomerId: 'GLYCINE',
        minMonomers: 3,
        essential: false,
        cellRole: 'transport'
    },

    // Genetic Material (Nucleic Acids)
    // Monomer: Adenine Nucleotide ‚Üí DNA/RNA
    DNA_STRAND: {
        id: 'dna_strand',
        name: 'DNA Strand',
        type: 'nucleic_acid',
        description: 'Stores genetic information from nucleotide monomers',
        monomerId: 'ADENINE_NUCLEOTIDE',
        minMonomers: 4,
        essential: true,
        cellRole: 'genetics'
    },
    RNA_STRAND: {
        id: 'rna_strand',
        name: 'RNA Strand',
        type: 'nucleic_acid',
        description: 'Carries genetic messages for protein synthesis',
        monomerId: 'ADENINE_NUCLEOTIDE',
        minMonomers: 3,
        essential: false,
        cellRole: 'genetics'
    },

    // Energy Storage (Carbohydrates)
    // Monomer: Glucose (C6H12O6) ‚Üí Polysaccharide
    GLYCOGEN: {
        id: 'glycogen',
        name: 'Glycogen',
        type: 'carbohydrate',
        description: 'Energy storage from glucose monomers',
        monomerId: 'GLUCOSE',
        minMonomers: 3,
        essential: false,
        cellRole: 'energy'
    },
    CELLULOSE: {
        id: 'cellulose',
        name: 'Cellulose',
        type: 'carbohydrate',
        description: 'Structural carbohydrate (cell wall) from glucose monomers',
        monomerId: 'GLUCOSE',
        minMonomers: 4,
        essential: false,
        cellRole: 'structure'
    },

    // ===== SIMPLE PROOF-OF-CONCEPT POLYMER =====
    POLYETHYLENE: {
        id: 'polyethylene',
        name: 'Polyethylene',
        type: 'generic',
        description: 'Simple plastic polymer from ethylene monomers',
        monomerId: 'ETHYLENE',
        minMonomers: 3,
        essential: false,
        cellRole: null
    }
};

// Minimum requirements for a viable cell
const CELL_REQUIREMENTS = {
    membrane: { count: 1, polymers: ['PHOSPHOLIPID', 'FATTY_ACID'] },
    structure: { count: 1, polymers: ['STRUCTURAL_PROTEIN', 'CELLULOSE'] },
    genetics: { count: 1, polymers: ['DNA_STRAND', 'RNA_STRAND'] },
    metabolism: { count: 0, polymers: ['ENZYME'] },  // Optional but helpful
    energy: { count: 0, polymers: ['GLYCOGEN'] },    // Optional
    transport: { count: 0, polymers: ['TRANSPORT_PROTEIN'] }  // Optional
};

/**
 * PolymerBlueprint - Template for creating polymers from monomers
 * NEW: Now references monomer templates instead of element ratios
 */
class PolymerBlueprint {
    constructor(template) {
        this.id = template.id;
        this.name = template.name;
        this.type = template.type;
        this.description = template.description;
        this.essential = template.essential || false;
        this.cellRole = template.cellRole;

        // NEW: Monomer-based properties
        this.monomerId = template.monomerId;              // Reference to MONOMER_TEMPLATES key
        this.minMonomers = template.minMonomers || template.minMolecules || 2;

        // Resolve the actual monomer template
        this.monomerTemplate = null;
        if (typeof getMonomerTemplate === 'function' && this.monomerId) {
            this.monomerTemplate = getMonomerTemplate(this.monomerId);
        }

        // Legacy support - generate requiredElements from monomer if not provided
        if (template.requiredElements) {
            this.requiredElements = template.requiredElements;
        } else if (this.monomerTemplate?.atomLayout) {
            const elements = new Set(this.monomerTemplate.atomLayout.map(a => a.symbol));
            this.requiredElements = Array.from(elements);
        } else {
            this.requiredElements = [];
        }

        // Generate fingerprint for this blueprint
        this.fingerprint = this._generateFingerprint();

        // Track discovery
        this.discovered = false;
        this.discoveredAt = null;
    }

    /**
     * Generate unique fingerprint for this blueprint
     */
    _generateFingerprint() {
        return JSON.stringify({
            type: this.type,
            monomerId: this.monomerId,
            minMonomers: this.minMonomers
        });
    }

    /**
     * Check if a polymer matches this blueprint
     * NEW: Validates that all monomers match the expected formula
     */
    matches(polymer) {
        if (!polymer || !polymer.monomers || polymer.monomers.length < this.minMonomers) {
            return false;
        }

        // Check type
        if (polymer.type !== this.type) {
            return false;
        }

        // NEW: Check that all monomers match our template formula
        if (this.monomerTemplate) {
            const expectedFormula = this.monomerTemplate.formula;
            for (const monomer of polymer.monomers) {
                if (monomer.formula !== expectedFormula) {
                    return false;
                }
            }
        }

        return true;
    }

    /**
     * Create a polymer instance at the given position
     */
    instantiate(x, y, catalogue) {
        console.log(`Instantiating polymer: ${this.name} at (${x}, ${y})`);

        // Get molecules needed for this polymer
        const molecules = [];
        const spacing = 80;

        // If we have molecule data from a discovered polymer, use it
        if (this.moleculeData && this.moleculeData.length >= this.minMolecules) {
            for (let i = 0; i < this.minMolecules; i++) {
                const molData = this.moleculeData[i % this.moleculeData.length];
                const offsetX = (i - this.minMolecules / 2) * spacing;

                // Try to instantiate from catalogue
                if (catalogue && catalogue.getMolecule(molData.fingerprint)) {
                    const mol = catalogue.instantiateMolecule(molData.fingerprint, x + offsetX, y);
                    if (mol) molecules.push(mol);
                }
            }
        }

        // If we couldn't get real molecules, create simple molecules based on required elements
        if (molecules.length < this.minMolecules) {
            console.log(`Creating ${this.minMolecules - molecules.length} placeholder molecules`);

            for (let i = molecules.length; i < this.minMolecules; i++) {
                const offsetX = (i - this.minMolecules / 2) * spacing;

                // Create atoms for this molecule
                const atomSpacing = 20;
                const elementsToAdd = this.requiredElements.slice(0, 4); // Max 4 elements
                const atoms = [];

                for (let j = 0; j < elementsToAdd.length; j++) {
                    const element = elementsToAdd[j];
                    const atomX = x + offsetX + (j - elementsToAdd.length / 2) * atomSpacing;
                    const atomY = y + (Math.random() - 0.5) * 10;
                    const atom = new Atom(element, atomX, atomY);
                    atoms.push(atom);
                }

                // Create bonds between adjacent atoms
                for (let j = 0; j < atoms.length - 1; j++) {
                    const atom1 = atoms[j];
                    const atom2 = atoms[j + 1];
                    if (atom1.availableValence > 0 && atom2.availableValence > 0) {
                        new Bond(atom1, atom2);  // Bond constructor links atoms
                    }
                }

                // Only create molecule from atoms that have bonds
                const bondedAtoms = atoms.filter(a => a.bonds.length > 0);
                if (bondedAtoms.length >= 2) {
                    const molecule = new Molecule(bondedAtoms);
                    molecules.push(molecule);
                } else {
                    console.warn(`Polymer instantiation: skipping molecule with ${bondedAtoms.length} bonded atoms`);
                }
            }
        }

        console.log(`Created polymer with ${molecules.length} molecules`);

        // Create polymer from molecules
        const polymer = new Polymer(molecules, this.type, this.name);
        return polymer;
    }

    /**
     * Serialize for storage
     */
    serialize() {
        return {
            id: this.id,
            name: this.name,
            type: this.type,
            description: this.description,
            minMolecules: this.minMolecules,
            requiredElements: this.requiredElements,
            elementRatios: this.elementRatios,
            essential: this.essential,
            cellRole: this.cellRole,
            moleculeData: this.moleculeData,
            fingerprint: this.fingerprint,
            discovered: this.discovered,
            discoveredAt: this.discoveredAt
        };
    }

    /**
     * Deserialize from storage
     */
    static deserialize(data) {
        const blueprint = new PolymerBlueprint(data);
        blueprint.moleculeData = data.moleculeData;
        blueprint.fingerprint = data.fingerprint;
        blueprint.discovered = data.discovered;
        blueprint.discoveredAt = data.discoveredAt;
        return blueprint;
    }
}

/**
 * Check if a polymer is useful for cell formation
 */
function isPolymerUseful(polymer) {
    for (const templateKey in CELL_ESSENTIAL_POLYMERS) {
        const template = CELL_ESSENTIAL_POLYMERS[templateKey];
        const blueprint = new PolymerBlueprint(template);
        if (blueprint.matches(polymer)) {
            return {
                useful: true,
                template: templateKey,
                role: template.cellRole,
                essential: template.essential
            };
        }
    }
    return { useful: false, template: null, role: null, essential: false };
}

/**
 * Get all essential polymer templates
 */
function getEssentialPolymerTemplates() {
    return Object.entries(CELL_ESSENTIAL_POLYMERS)
        .filter(([_, t]) => t.essential)
        .map(([key, template]) => new PolymerBlueprint(template));
}

/**
 * Get all polymer templates
 */
function getAllPolymerTemplates() {
    return Object.entries(CELL_ESSENTIAL_POLYMERS)
        .map(([key, template]) => new PolymerBlueprint(template));
}

/**
 * Check if polymers meet cell requirements
 */
function checkCellViability(polymers) {
    const roleCounts = {
        membrane: 0,
        structure: 0,
        genetics: 0,
        metabolism: 0,
        energy: 0,
        transport: 0
    };

    for (const polymer of polymers) {
        const result = isPolymerUseful(polymer);
        if (result.useful && result.role) {
            roleCounts[result.role]++;
        }
    }

    const missing = [];
    for (const [role, req] of Object.entries(CELL_REQUIREMENTS)) {
        if (roleCounts[role] < req.count) {
            missing.push({ role, needed: req.count - roleCounts[role], options: req.polymers });
        }
    }

    return {
        viable: missing.filter(m => CELL_REQUIREMENTS[m.role].count > 0).length === 0,
        roleCounts,
        missing
    };
}

// Make available globally
window.CELL_ESSENTIAL_POLYMERS = CELL_ESSENTIAL_POLYMERS;
window.CELL_REQUIREMENTS = CELL_REQUIREMENTS;
window.PolymerBlueprint = PolymerBlueprint;
window.isPolymerUseful = isPolymerUseful;
window.getEssentialPolymerTemplates = getEssentialPolymerTemplates;
window.getAllPolymerTemplates = getAllPolymerTemplates;
window.checkCellViability = checkCellViability;


// ==== src/catalogue/catalogue.js ====
/**
 * Catalogue
 * Central storage for blueprints with IndexedDB persistence
 */

class Catalogue {
    constructor() {
        this.molecules = new Map();  // fingerprint -> MoleculeBlueprint
        this.polymers = new Map();   // fingerprint -> PolymerBlueprint
        this.cells = new Map();      // id -> CellBlueprint
        this.organisms = new Map();  // id -> OrganismBlueprint

        // IndexedDB connection
        this.db = null;
        this.dbName = 'CellSimulatorCatalogue';
        this.dbVersion = 1;

        // Auto-discovery settings
        this.autoRegisterStable = true;
        this.knownFingerprints = new Set();

        // Event callbacks
        this.onBlueprintAdded = null;

        // Load pre-defined polymer templates
        this._loadPolymerTemplates();

        // Load monomer blueprints (molecule blueprints for monomers)
        this._loadMonomerBlueprints();
    }

    /**
     * Load pre-defined polymer templates
     */
    _loadPolymerTemplates() {
        if (typeof getAllPolymerTemplates === 'function') {
            const templates = getAllPolymerTemplates();
            for (const template of templates) {
                this.polymers.set(template.fingerprint, template);
            }
            console.log(`Loaded ${templates.length} polymer templates`);
        }
    }

    /**
     * Load monomer blueprints into the molecule catalogue
     * These are pre-defined molecules that can be used as monomers for polymers
     */
    _loadMonomerBlueprints() {
        if (typeof getAllMonomerBlueprints === 'function') {
            const blueprints = getAllMonomerBlueprints();
            for (const blueprint of blueprints) {
                // Don't overwrite if already exists (e.g., from IndexedDB)
                if (!this.molecules.has(blueprint.fingerprint)) {
                    this.molecules.set(blueprint.fingerprint, blueprint);
                    this.knownFingerprints.add(blueprint.fingerprint);
                }
            }
            console.log(`Loaded ${blueprints.length} monomer blueprints`);
        }
    }

    /**
     * Initialize IndexedDB connection
     */
    async init() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, this.dbVersion);

            request.onerror = () => reject(request.error);

            request.onsuccess = () => {
                this.db = request.result;
                this._loadFromDB().then(resolve);
            };

            request.onupgradeneeded = (event) => {
                const db = event.target.result;

                // Create object stores
                if (!db.objectStoreNames.contains('molecules')) {
                    db.createObjectStore('molecules', { keyPath: 'fingerprint' });
                }
                if (!db.objectStoreNames.contains('cells')) {
                    db.createObjectStore('cells', { keyPath: 'id' });
                }
                if (!db.objectStoreNames.contains('organisms')) {
                    db.createObjectStore('organisms', { keyPath: 'id' });
                }
            };
        });
    }

    /**
     * Load all blueprints from IndexedDB
     */
    async _loadFromDB() {
        if (!this.db) return;

        // Load molecules
        const moleculeStore = this.db
            .transaction('molecules', 'readonly')
            .objectStore('molecules');

        return new Promise((resolve) => {
            const request = moleculeStore.getAll();

            request.onsuccess = () => {
                for (const data of request.result) {
                    const blueprint = MoleculeBlueprint.deserialize(data);
                    this.molecules.set(data.fingerprint, blueprint);
                    this.knownFingerprints.add(data.fingerprint);
                }
                console.log(`Loaded ${this.molecules.size} molecule blueprints`);

                // Clean up duplicates and invalid entries
                this._cleanupCatalogue();

                resolve();
            };

            request.onerror = () => {
                console.error('Failed to load molecules:', request.error);
                resolve();
            };
        });
    }

    /**
     * Clean up the catalogue - remove duplicates and invalid entries
     */
    async _cleanupCatalogue() {
        const seenFormulas = new Map(); // formula -> fingerprint
        const toRemove = [];

        for (const [fingerprint, blueprint] of this.molecules) {
            // Check if this is a valid stable molecule
            const isValid = this._isBlueprintValid(blueprint);

            if (!isValid) {
                toRemove.push(fingerprint);
                console.log(`Removing invalid blueprint: ${blueprint.formula}`);
                continue;
            }

            // Check for duplicates (same formula, different fingerprint)
            if (seenFormulas.has(blueprint.formula)) {
                // Keep the newer one (higher createdAt)
                const existingFp = seenFormulas.get(blueprint.formula);
                const existing = this.molecules.get(existingFp);
                if (existing && blueprint.createdAt > existing.createdAt) {
                    toRemove.push(existingFp);
                    seenFormulas.set(blueprint.formula, fingerprint);
                } else {
                    toRemove.push(fingerprint);
                }
                console.log(`Removing duplicate blueprint: ${blueprint.formula}`);
            } else {
                seenFormulas.set(blueprint.formula, fingerprint);
            }
        }

        // Remove invalid/duplicate entries
        for (const fp of toRemove) {
            this.molecules.delete(fp);
            this.knownFingerprints.delete(fp);
            this._deleteMoleculeFromDB(fp);
        }

        if (toRemove.length > 0) {
            console.log(`Cleaned up ${toRemove.length} invalid/duplicate blueprints`);
        }
    }

    /**
     * Check if a blueprint is valid (stable molecule with proper structure)
     */
    _isBlueprintValid(bp) {
        if (!bp.atomData || bp.atomData.length < 2) return false;
        if (!bp.bondData || bp.bondData.length < 1) return false;

        // Calculate valence usage for each atom
        const atomValences = {};
        for (const atom of bp.atomData) {
            const element = getElement(atom.symbol);
            if (!element) return false;
            atomValences[atom.index] = { max: element.valence, used: 0 };
        }

        // Count bonds for each atom
        for (const bond of bp.bondData) {
            const order = bond.order || 1;
            if (atomValences[bond.atom1Index]) {
                atomValences[bond.atom1Index].used += order;
            }
            if (atomValences[bond.atom2Index]) {
                atomValences[bond.atom2Index].used += order;
            }
        }

        // Check all atoms have filled valence
        for (const idx in atomValences) {
            const v = atomValences[idx];
            if (v.used !== v.max) return false;
        }
        return true;
    }

    /**
     * Delete a molecule from IndexedDB
     */
    async _deleteMoleculeFromDB(fingerprint) {
        if (!this.db) return;

        try {
            const transaction = this.db.transaction('molecules', 'readwrite');
            const store = transaction.objectStore('molecules');
            store.delete(fingerprint);
        } catch (e) {
            console.error('Failed to delete molecule from DB:', e);
        }
    }

    /**
     * Save a molecule blueprint to IndexedDB
     */
    async _saveMolecule(blueprint) {
        if (!this.db) return;

        return new Promise((resolve) => {
            const transaction = this.db.transaction('molecules', 'readwrite');
            const store = transaction.objectStore('molecules');

            const data = {
                ...blueprint.serialize(),
                fingerprint: blueprint.fingerprint
            };

            const request = store.put(data);
            request.onsuccess = () => resolve(true);
            request.onerror = () => {
                console.error('Failed to save molecule:', request.error);
                resolve(false);
            };
        });
    }

    /**
     * Register a new molecule blueprint
     * @param {Molecule} molecule - The molecule to register
     * @param {string} name - Optional custom name
     * @returns {MoleculeBlueprint|null} The created blueprint or null if already exists
     */
    registerMolecule(molecule, name = null) {
        if (this.hasMolecule(molecule.fingerprint)) {
            return null;  // Already registered
        }

        const blueprint = new MoleculeBlueprint(molecule, name);
        this.molecules.set(blueprint.fingerprint, blueprint);
        this.knownFingerprints.add(blueprint.fingerprint);

        // Persist
        this._saveMolecule(blueprint);

        // Callback
        if (this.onBlueprintAdded) {
            this.onBlueprintAdded(blueprint);
        }

        console.log(`Registered new molecule: ${blueprint.name}`);
        return blueprint;
    }

    /**
     * Check if molecule fingerprint is already registered
     */
    hasMolecule(fingerprint) {
        return this.molecules.has(fingerprint);
    }

    /**
     * Get molecule blueprint by fingerprint
     */
    getMolecule(fingerprint) {
        return this.molecules.get(fingerprint) || null;
    }

    /**
     * Get all molecule blueprints
     */
    getAllMolecules() {
        return Array.from(this.molecules.values());
    }

    /**
     * Get a monomer blueprint by monomer ID
     * If not already loaded, creates it from the monomer template
     * @param {string} monomerId - The monomer template ID (e.g., 'ETHYLENE', 'GLYCINE')
     * @returns {Object|null} The monomer blueprint or null
     */
    getMonomerById(monomerId) {
        if (!monomerId) return null;

        // Check if already in catalogue by looking for fingerprint pattern
        const expectedFingerprint = `monomer:${monomerId.toLowerCase()}:`;
        for (const [fp, blueprint] of this.molecules) {
            if (fp.startsWith(expectedFingerprint) || blueprint.monomerId === monomerId.toLowerCase()) {
                return blueprint;
            }
        }

        // Not found - try to create from template
        if (typeof getMonomerBlueprint === 'function') {
            const blueprint = getMonomerBlueprint(monomerId);
            if (blueprint) {
                this.molecules.set(blueprint.fingerprint, blueprint);
                this.knownFingerprints.add(blueprint.fingerprint);
                console.log(`Created monomer blueprint on-demand: ${blueprint.name}`);
                return blueprint;
            }
        }

        return null;
    }

    /**
     * Ensure a monomer blueprint exists for a polymer blueprint
     * Call this when placing a polymer intention to make sure the monomer is available
     * @param {Object} polymerBlueprint - The polymer blueprint
     * @returns {Object|null} The monomer blueprint or null
     */
    ensureMonomerForPolymer(polymerBlueprint) {
        if (!polymerBlueprint) return null;

        const monomerId = polymerBlueprint.monomerId;
        if (!monomerId) {
            console.warn('Polymer blueprint has no monomerId:', polymerBlueprint.name);
            return null;
        }

        return this.getMonomerById(monomerId);
    }

    // ============ Polymer Methods ============

    /**
     * Register a discovered polymer blueprint
     * @param {Polymer} polymer - The polymer to register
     * @param {string} name - Optional custom name
     * @returns {PolymerBlueprint|null}
     */
    registerPolymer(polymer, name = null) {
        // Check if polymer is useful
        const usefulness = isPolymerUseful(polymer);

        // Create a template from the polymer
        const template = {
            id: polymer.id,
            name: name || polymer.name || usefulness.template || `Polymer-${polymer.molecules.length}`,
            type: polymer.type,
            description: usefulness.useful ? `Useful for ${usefulness.role}` : 'Unknown function',
            minMolecules: polymer.molecules.length,
            requiredElements: [...new Set(polymer.getAllAtoms().map(a => a.symbol))],
            elementRatios: {},
            essential: usefulness.essential,
            cellRole: usefulness.role
        };

        const blueprint = new PolymerBlueprint(template, polymer.molecules);
        blueprint.discovered = true;
        blueprint.discoveredAt = Date.now();

        // Check if already registered
        if (this.polymers.has(blueprint.fingerprint)) {
            return null;
        }

        this.polymers.set(blueprint.fingerprint, blueprint);
        console.log(`Registered polymer: ${blueprint.name} (${blueprint.type})`);

        if (this.onBlueprintAdded) {
            this.onBlueprintAdded('polymer', blueprint);
        }

        return blueprint;
    }

    /**
     * Check if polymer fingerprint is already registered
     */
    hasPolymer(fingerprint) {
        return this.polymers.has(fingerprint);
    }

    /**
     * Get polymer blueprint by fingerprint
     */
    getPolymer(fingerprint) {
        return this.polymers.get(fingerprint) || null;
    }

    /**
     * Get all polymer blueprints
     */
    getAllPolymers() {
        return Array.from(this.polymers.values());
    }

    /**
     * Get only essential polymer templates (needed for cells)
     */
    getEssentialPolymers() {
        return this.getAllPolymers().filter(p => p.essential);
    }

    /**
     * Get polymers by type
     */
    getPolymersByType(type) {
        return this.getAllPolymers().filter(p => p.type === type);
    }

    /**
     * Get polymers by cell role
     */
    getPolymersByRole(role) {
        return this.getAllPolymers().filter(p => p.cellRole === role);
    }

    /**
     * Instantiate a polymer at a position
     * @param {string} fingerprint - Blueprint fingerprint
     * @param {number} x - X position
     * @param {number} y - Y position
     * @returns {Polymer|null}
     */
    instantiatePolymer(fingerprint, x, y) {
        const blueprint = this.getPolymer(fingerprint);
        if (!blueprint) return null;
        return blueprint.instantiate(x, y, this);
    }

    /**
     * Search blueprints by name/formula
     * @param {string} query - Search query
     * @returns {Blueprint[]} Matching blueprints
     */
    search(query) {
        const q = query.toLowerCase();
        const results = [];

        for (const blueprint of this.molecules.values()) {
            if (blueprint.name.toLowerCase().includes(q) ||
                blueprint.formula.toLowerCase().includes(q)) {
                results.push(blueprint);
            }
        }

        return results;
    }

    /**
     * Auto-discover and register stable molecules
     * @param {Molecule[]} molecules - Molecules to check
     */
    autoDiscover(molecules) {
        if (!this.autoRegisterStable) return;

        for (const molecule of molecules) {
            if (molecule.isStable() && !this.hasMolecule(molecule.fingerprint)) {
                this.registerMolecule(molecule);
            }
        }
    }

    /**
     * Instantiate a blueprint at a position
     * @param {string} fingerprint - Blueprint fingerprint
     * @param {number} x - X position
     * @param {number} y - Y position
     * @returns {Molecule|null}
     */
    instantiateMolecule(fingerprint, x, y) {
        const blueprint = this.molecules.get(fingerprint);
        if (!blueprint) return null;

        return blueprint.instantiate(x, y);
    }

    /**
     * Delete a molecule blueprint
     * @param {string} fingerprint - Blueprint fingerprint
     */
    async deleteMolecule(fingerprint) {
        if (!this.molecules.has(fingerprint)) return;

        this.molecules.delete(fingerprint);
        this.knownFingerprints.delete(fingerprint);

        if (this.db) {
            const transaction = this.db.transaction('molecules', 'readwrite');
            const store = transaction.objectStore('molecules');
            store.delete(fingerprint);
        }
    }

    /**
     * Export catalogue to JSON
     */
    export() {
        return JSON.stringify({
            molecules: Array.from(this.molecules.values()).map(b => b.serialize()),
            cells: Array.from(this.cells.values()).map(b => b.serialize()),
            organisms: Array.from(this.organisms.values()).map(b => b.serialize())
        }, null, 2);
    }

    /**
     * Import catalogue from JSON
     * @param {string} json - JSON string
     */
    import(json) {
        const data = JSON.parse(json);

        if (data.molecules) {
            for (const molData of data.molecules) {
                const blueprint = MoleculeBlueprint.deserialize(molData);
                if (!this.molecules.has(blueprint.fingerprint)) {
                    this.molecules.set(blueprint.fingerprint, blueprint);
                    this.knownFingerprints.add(blueprint.fingerprint);
                    this._saveMolecule(blueprint);
                }
            }
        }

        console.log(`Imported ${data.molecules?.length || 0} molecules`);
    }

    /**
     * Clear all blueprints
     */
    async clear() {
        this.molecules.clear();
        this.polymers.clear();
        this.cells.clear();
        this.organisms.clear();
        this.knownFingerprints.clear();

        // Reload polymer templates
        this._loadPolymerTemplates();

        if (this.db) {
            const transaction = this.db.transaction(
                ['molecules', 'cells', 'organisms'],
                'readwrite'
            );
            transaction.objectStore('molecules').clear();
            transaction.objectStore('cells').clear();
            transaction.objectStore('organisms').clear();
        }
    }
}

// Make available globally
window.Catalogue = Catalogue;


// ==== src/viewer/viewer.js ====
/**
 * Viewer
 * Multi-level renderer for the simulation
 */

// Abstraction levels (6 levels)
const AbstractionLevel = {
    ATOM: 0,
    MOLECULE: 1,
    PROTEIN: 2,
    CELL: 3,
    ORGANISM: 4,
    POPULATION: 5
};

const LEVEL_NAMES = ['Atoms', 'Molecules', 'Proteins', 'Cells', 'Organisms', 'Populations'];

class Viewer {
    /**
     * Create a new viewer
     * @param {HTMLCanvasElement} canvas - Canvas element
     * @param {Environment} environment - Environment to render
     */
    constructor(canvas, environment) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.environment = environment;

        // Camera
        this.camera = {
            x: 0,
            y: 0,
            zoom: 1,
            minZoom: 0.1,
            maxZoom: 5
        };

        // Abstraction level
        this.level = AbstractionLevel.ATOM;

        // Selection
        this.selectedAtom = null;
        this.selectedMolecule = null;
        this.selectedCell = null;
        this.hoveredAtom = null;
        this.hoveredMolecule = null;
        this.hoveredCell = null;

        // Performance
        this.lastRenderTime = 0;

        // Grid settings
        this.showGrid = true;
        this.gridSpacing = 100;

        // Callbacks
        this.onRender = null;

        // Resize handler
        this._resizeHandler = this._handleResize.bind(this);
        window.addEventListener('resize', this._resizeHandler);
        this._handleResize();
    }

    /**
     * Handle window resize
     */
    _handleResize() {
        const rect = this.canvas.parentElement.getBoundingClientRect();
        this.canvas.width = rect.width;
        this.canvas.height = rect.height;
    }

    /**
     * Set abstraction level
     * @param {number} level - Level from AbstractionLevel enum
     */
    setLevel(level) {
        this.level = Utils.clamp(level, 0, 5);
        this.clearSelection();
    }

    /**
     * Clear all selections
     */
    clearSelection() {
        if (this.selectedAtom) {
            this.selectedAtom.selected = false;
            this.selectedAtom = null;
        }
        if (this.selectedMolecule) {
            this.selectedMolecule.selected = false;
            this.selectedMolecule = null;
        }
    }

    /**
     * Get camera offset
     */
    getOffset() {
        return {
            x: this.canvas.width / (2 * this.camera.zoom) - this.camera.x,
            y: this.canvas.height / (2 * this.camera.zoom) - this.camera.y
        };
    }

    /**
     * Screen to world coordinates
     * @param {number} screenX - Screen X
     * @param {number} screenY - Screen Y
     */
    screenToWorld(screenX, screenY) {
        const offset = this.getOffset();
        return {
            x: screenX / this.camera.zoom - offset.x,
            y: screenY / this.camera.zoom - offset.y
        };
    }

    /**
     * World to screen coordinates
     * @param {number} worldX - World X
     * @param {number} worldY - World Y
     */
    worldToScreen(worldX, worldY) {
        const offset = this.getOffset();
        return {
            x: (worldX + offset.x) * this.camera.zoom,
            y: (worldY + offset.y) * this.camera.zoom
        };
    }

    /**
     * Pan the camera
     * @param {number} dx - Delta X in screen space
     * @param {number} dy - Delta Y in screen space
     */
    pan(dx, dy) {
        this.camera.x -= dx / this.camera.zoom;
        this.camera.y -= dy / this.camera.zoom;
    }

    /**
     * Zoom the camera
     * @param {number} delta - Zoom delta
     * @param {number} centerX - Zoom center X (screen)
     * @param {number} centerY - Zoom center Y (screen)
     */
    zoom(delta, centerX, centerY) {
        const oldZoom = this.camera.zoom;
        const newZoom = Utils.clamp(
            oldZoom * (1 + delta * 0.1),
            this.camera.minZoom,
            this.camera.maxZoom
        );

        // Zoom towards cursor
        const worldBefore = this.screenToWorld(centerX, centerY);
        this.camera.zoom = newZoom;
        const worldAfter = this.screenToWorld(centerX, centerY);

        this.camera.x += worldBefore.x - worldAfter.x;
        this.camera.y += worldBefore.y - worldAfter.y;
    }

    /**
     * Center camera on environment
     */
    centerCamera() {
        this.camera.x = this.environment.width / 2;
        this.camera.y = this.environment.height / 2;
    }

    /**
     * Render the simulation
     */
    render() {
        const ctx = this.ctx;
        const startTime = performance.now();

        // Clear
        ctx.fillStyle = '#0a0a0f';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw based on level
        switch (this.level) {
            case AbstractionLevel.ATOM:
                this._renderAtomLevel();
                break;
            case AbstractionLevel.MOLECULE:
                this._renderMoleculeLevel();
                break;
            case AbstractionLevel.PROTEIN:
                this._renderProteinLevel();
                break;
            case AbstractionLevel.CELL:
                this._renderCellLevel();
                break;
            case AbstractionLevel.ORGANISM:
                this._renderOrganismLevel();
                break;
            case AbstractionLevel.POPULATION:
                this._renderPopulationLevel();
                break;
        }

        // Render intention zones (blueprint attraction zones)
        this._renderIntentions();

        // Render atom spawner zone
        this._renderSpawnerZone();

        // Draw environment bounds
        this._renderBounds();

        // Draw grid (optional)
        if (this.showGrid && this.camera.zoom > 0.3) {
            this._renderGrid();
        }

        this.lastRenderTime = performance.now() - startTime;

        // Trigger callback
        if (this.onRender) {
            this.onRender();
        }
    }

    /**
     * Render intention zones
     */
    _renderIntentions() {
        const scale = this.camera.zoom;
        const offset = this.getOffset();

        const intentions = this.environment.getAllIntentions ? this.environment.getAllIntentions() : [];
        for (const intention of intentions) {
            // Only show intentions relevant to current level
            // Molecule intentions: levels 0-1 (atom and molecule levels)
            // Polymer intentions: levels 1-2 (molecule and polymer levels)
            // Cell intentions: levels 2-3 (polymer and cell levels)
            let shouldRender = false;
            if (intention.type === 'molecule' && this.level <= 1) {
                shouldRender = true;
            } else if (intention.type === 'polymer' && this.level >= 1 && this.level <= 2) {
                shouldRender = true;
            } else if (intention.type === 'cell' && this.level >= 2 && this.level <= 3) {
                shouldRender = true;
            }

            if (shouldRender) {
                intention.render(this.ctx, scale, offset);
            }
        }
    }

    /**
     * Render atom spawner zone
     */
    _renderSpawnerZone() {
        // Get spawner from global app instance
        const spawner = window.cellApp?.atomSpawner;
        if (!spawner || !spawner.active) return;

        const scale = this.camera.zoom;
        const offset = this.getOffset();

        spawner.render(this.ctx, scale, offset);
    }

    /**
     * Render at atom level
     */
    _renderAtomLevel() {
        const scale = this.camera.zoom;
        const offset = this.getOffset();

        // Render polymer chain connections first (behind everything)
        const polymers = this.environment.getAllProteins ? this.environment.getAllProteins() : [];
        for (const polymer of polymers) {
            this._renderPolymerConnections(polymer, scale, offset);
        }

        // Render bonds first
        for (const bond of this.environment.getAllBonds()) {
            bond.render(this.ctx, scale, offset);
        }

        // Render atoms
        for (const atom of this.environment.getAllAtoms()) {
            atom.render(this.ctx, scale, offset);
        }
    }

    /**
     * Render at molecule level
     */
    _renderMoleculeLevel() {
        const scale = this.camera.zoom;
        const offset = this.getOffset();

        // Render polymer chain connections first (behind molecules)
        const polymers = this.environment.getAllProteins ? this.environment.getAllProteins() : [];
        for (const polymer of polymers) {
            this._renderPolymerConnections(polymer, scale, offset);
        }

        // Render molecules as simplified blobs
        for (const molecule of this.environment.getAllMolecules()) {
            molecule.renderSimplified(this.ctx, scale, offset);
        }

        // Render free atoms (not in molecules)
        for (const atom of this.environment.getAllAtoms()) {
            if (!atom.moleculeId) {
                atom.render(this.ctx, scale, offset);
            }
        }
    }

    /**
     * Render at protein level
     */
    _renderProteinLevel() {
        const scale = this.camera.zoom;
        const offset = this.getOffset();

        // Render proteins
        const proteins = this.environment.getAllProteins ? this.environment.getAllProteins() : [];
        for (const protein of proteins) {
            protein.render(this.ctx, 2, { x: -offset.x, y: -offset.y, zoom: scale });
        }

        // Render molecules not in proteins
        for (const molecule of this.environment.getAllMolecules()) {
            if (!molecule.proteinId) {
                molecule.renderSimplified(this.ctx, scale, offset);
            }
        }

        // Render free atoms
        for (const atom of this.environment.getAllAtoms()) {
            if (!atom.moleculeId) {
                atom.render(this.ctx, scale, offset);
            }
        }
    }

    /**
     * Render polymer chain connections between molecules
     * @param {Polymer} polymer - The polymer to render connections for
     * @param {number} scale - Zoom scale
     * @param {object} offset - Camera offset
     */
    _renderPolymerConnections(polymer, scale, offset) {
        if (!polymer.molecules || polymer.molecules.length < 2) return;

        this.ctx.save();
        this.ctx.strokeStyle = polymer.selected ? '#f59e0b' : '#f97316'; // Orange color for polymer bonds
        this.ctx.lineWidth = 3;
        this.ctx.setLineDash([8, 4]);

        this.ctx.beginPath();
        for (let i = 0; i < polymer.molecules.length - 1; i++) {
            const mol1 = polymer.molecules[i];
            const mol2 = polymer.molecules[i + 1];

            const center1 = mol1.getCenter ? mol1.getCenter() : mol1.centerOfMass;
            const center2 = mol2.getCenter ? mol2.getCenter() : mol2.centerOfMass;

            const x1 = (center1.x + offset.x) * scale;
            const y1 = (center1.y + offset.y) * scale;
            const x2 = (center2.x + offset.x) * scale;
            const y2 = (center2.y + offset.y) * scale;

            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
        }
        this.ctx.stroke();
        this.ctx.setLineDash([]);
        this.ctx.restore();
    }

    /**
     * Render at cell level
     */
    _renderCellLevel() {
        const scale = this.camera.zoom;
        const offset = this.getOffset();

        // Render prokaryotes
        const prokaryotes = this.environment.getAllProkaryotes ? this.environment.getAllProkaryotes() : [];
        for (const prokaryote of prokaryotes) {
            if (prokaryote.isAlive) {
                const isSelected = this.selectedCell && this.selectedCell.id === prokaryote.id;
                prokaryote.render(this.ctx, scale, offset, isSelected);
            }
        }

        // Render molecules as small dots (simplified view)
        for (const molecule of this.environment.getAllMolecules()) {
            const center = molecule.centerOfMass;
            const screenX = (center.x + offset.x) * scale;
            const screenY = (center.y + offset.y) * scale;

            this.ctx.beginPath();
            this.ctx.arc(screenX, screenY, 4 * scale, 0, Math.PI * 2);
            this.ctx.fillStyle = 'rgba(100, 200, 255, 0.5)';
            this.ctx.fill();
        }

        // Show message if no prokaryotes
        if (prokaryotes.length === 0) {
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            this.ctx.font = '18px sans-serif';
            this.ctx.textAlign = 'center';
            this.ctx.fillText(
                'No prokaryotes yet - Click to spawn one',
                this.canvas.width / 2,
                this.canvas.height / 2
            );
        }
    }

    /**
     * Render at organism level (placeholder)
     */
    _renderOrganismLevel() {
        const ctx = this.ctx;
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.font = '24px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(
            'Organism level - Coming in Phase 3',
            this.canvas.width / 2,
            this.canvas.height / 2
        );
    }

    /**
     * Render at population level (placeholder)
     */
    _renderPopulationLevel() {
        const ctx = this.ctx;
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.font = '24px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(
            'Population level - Coming in Phase 4',
            this.canvas.width / 2,
            this.canvas.height / 2
        );
    }

    /**
     * Render environment bounds
     */
    _renderBounds() {
        const ctx = this.ctx;
        const scale = this.camera.zoom;
        const offset = this.getOffset();

        ctx.strokeStyle = 'rgba(99, 102, 241, 0.3)';
        ctx.lineWidth = 2;
        ctx.strokeRect(
            offset.x * scale,
            offset.y * scale,
            this.environment.width * scale,
            this.environment.height * scale
        );
    }

    /**
     * Render grid
     */
    _renderGrid() {
        const ctx = this.ctx;
        const scale = this.camera.zoom;
        const offset = this.getOffset();

        ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
        ctx.lineWidth = 1;

        const startX = Math.floor(-offset.x / this.gridSpacing) * this.gridSpacing;
        const endX = this.environment.width;
        const startY = Math.floor(-offset.y / this.gridSpacing) * this.gridSpacing;
        const endY = this.environment.height;

        // Vertical lines
        for (let x = startX; x <= endX; x += this.gridSpacing) {
            const screenX = (x + offset.x) * scale;
            ctx.beginPath();
            ctx.moveTo(screenX, 0);
            ctx.lineTo(screenX, this.canvas.height);
            ctx.stroke();
        }

        // Horizontal lines
        for (let y = startY; y <= endY; y += this.gridSpacing) {
            const screenY = (y + offset.y) * scale;
            ctx.beginPath();
            ctx.moveTo(0, screenY);
            ctx.lineTo(this.canvas.width, screenY);
            ctx.stroke();
        }
    }

    /**
     * Find entity at screen position
     * @param {number} screenX - Screen X
     * @param {number} screenY - Screen Y
     */
    getEntityAt(screenX, screenY) {
        const scale = this.camera.zoom;
        const offset = this.getOffset();

        // Check intentions first (highest priority for selection)
        const intentions = this.environment.getAllIntentions ? this.environment.getAllIntentions() : [];
        for (const intention of intentions) {
            if (intention.containsPoint(screenX, screenY, scale, offset)) {
                return { type: 'intention', entity: intention };
            }
        }

        // At cell level or higher, prioritize prokaryotes
        if (this.level >= 3) {
            const prokaryotes = this.environment.getAllProkaryotes ? this.environment.getAllProkaryotes() : [];
            for (const prokaryote of prokaryotes) {
                if (prokaryote.isAlive && prokaryote.containsPoint(screenX, screenY, scale, offset)) {
                    return { type: 'prokaryote', entity: prokaryote };
                }
            }
        }

        // At protein/polymer level, check polymers
        if (this.level >= 2) {
            const polymers = this.environment.getAllProteins ? this.environment.getAllProteins() : [];
            for (const polymer of polymers) {
                // Check if click is near polymer center
                const center = polymer.getCenter();
                const screenCX = (center.x + offset.x) * scale;
                const screenCY = (center.y + offset.y) * scale;
                const radius = (15 + polymer.molecules.length * 5) * scale;

                const dx = screenX - screenCX;
                const dy = screenY - screenCY;
                if (dx * dx + dy * dy <= radius * radius) {
                    return { type: 'polymer', entity: polymer };
                }
            }
        }

        // At molecule level or higher, check molecules
        if (this.level >= 1) {
            // Check molecules first
            for (const molecule of this.environment.getAllMolecules()) {
                if (molecule.containsPoint(screenX, screenY, scale, offset)) {
                    return { type: 'molecule', entity: molecule };
                }
            }
            // Then check free atoms (not in molecules)
            for (const atom of this.environment.getAllAtoms()) {
                if (!atom.moleculeId && atom.containsPoint(screenX, screenY, scale, offset)) {
                    return { type: 'atom', entity: atom };
                }
            }
        } else {
            // At atom level, prioritize atoms
            for (const atom of this.environment.getAllAtoms()) {
                if (atom.containsPoint(screenX, screenY, scale, offset)) {
                    return { type: 'atom', entity: atom };
                }
            }
            // Then check molecules
            for (const molecule of this.environment.getAllMolecules()) {
                if (molecule.containsPoint(screenX, screenY, scale, offset)) {
                    return { type: 'molecule', entity: molecule };
                }
            }
        }

        return null;
    }

    /**
     * Cleanup
     */
    destroy() {
        window.removeEventListener('resize', this._resizeHandler);
    }
}

// Make available globally
window.AbstractionLevel = AbstractionLevel;
window.LEVEL_NAMES = LEVEL_NAMES;
window.Viewer = Viewer;


// ==== src/viewer/controls.js ====
/**
 * Controls
 * User interaction handling
 */

class Controls {
    /**
     * Create controls handler
     * @param {Viewer} viewer - The viewer instance
     * @param {Simulation} simulation - The simulation instance
     * @param {Catalogue} catalogue - The catalogue instance
     */
    constructor(viewer, simulation, catalogue) {
        this.viewer = viewer;
        this.simulation = simulation;
        this.catalogue = catalogue;
        this.environment = simulation.environment;

        // Current tool
        this.tool = 'place';  // 'select', 'place', 'delete'
        this.selectedElement = 'C';  // Currently selected atom type for placement

        // Mouse state
        this.mouse = {
            x: 0,
            y: 0,
            down: false,
            dragging: false,
            dragStartX: 0,
            dragStartY: 0
        };

        // Selected blueprint for placement
        this.selectedBlueprint = null;
        this.selectedPolymerTemplate = null;

        // Key states
        this.keys = new Set();

        // Bind event handlers
        this._bindEvents();
    }

    /**
     * Bind all event listeners
     */
    _bindEvents() {
        const canvas = this.viewer.canvas;

        // Mouse events
        canvas.addEventListener('mousedown', this._onMouseDown.bind(this));
        canvas.addEventListener('mousemove', this._onMouseMove.bind(this));
        canvas.addEventListener('mouseup', this._onMouseUp.bind(this));
        canvas.addEventListener('wheel', this._onWheel.bind(this));
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            // Right-click cancels placement mode and returns to select
            if (this.tool === 'place' || this.selectedBlueprint || this.selectedPolymerTemplate) {
                this.selectedBlueprint = null;
                this.selectedPolymerTemplate = null;
                this.selectedElement = 'C'; // Reset to default element
                this.setTool('select');
            }
        });

        // Keyboard events
        document.addEventListener('keydown', this._onKeyDown.bind(this));
        document.addEventListener('keyup', this._onKeyUp.bind(this));
    }

    /**
     * Set current tool
     * @param {string} tool - Tool name
     */
    setTool(tool) {
        this.tool = tool;
        this.viewer.canvas.style.cursor = this._getCursorForTool(tool);

        // Update tool button visual state
        document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.tool === tool);
        });
    }

    /**
     * Get cursor style for tool
     */
    _getCursorForTool(tool) {
        switch (tool) {
            case 'select': return 'default';
            case 'place': return 'crosshair';
            case 'delete': return 'not-allowed';
            default: return 'default';
        }
    }

    /**
     * Set selected element for placement
     * @param {string} symbol - Element symbol
     */
    setSelectedElement(symbol) {
        this.selectedElement = symbol;
        this.selectedBlueprint = null;
    }

    /**
     * Set selected blueprint for placement
     * @param {Blueprint} blueprint - Blueprint to place
     */
    setSelectedBlueprint(blueprint) {
        this.selectedBlueprint = blueprint;
    }

    /**
     * Handle mouse down
     */
    _onMouseDown(event) {
        const rect = this.viewer.canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;

        this.mouse.down = true;
        this.mouse.dragStartX = x;
        this.mouse.dragStartY = y;

        // Right-click or middle-click for panning
        if (event.button === 1 || event.button === 2) {
            this.mouse.dragging = true;
            this.viewer.canvas.style.cursor = 'grabbing';
            return;
        }

        // Check for spawner zone resize handles first
        const spawner = window.cellApp?.atomSpawner;
        if (spawner && spawner.active) {
            const scale = this.viewer.camera.zoom;
            const offset = this.viewer.getOffset();
            const resizeEdge = spawner.getResizeHandleAt(x, y, scale, offset);

            if (resizeEdge) {
                spawner.startResize(resizeEdge, x, y);
                this.viewer.canvas.style.cursor = spawner.getCursorForEdge(resizeEdge);
                return;
            }
        }

        // Left-click actions based on tool
        switch (this.tool) {
            case 'place':
                this._handlePlace(x, y);
                break;
            case 'select':
                this._handleSelect(x, y);
                break;
            case 'delete':
                this._handleDelete(x, y);
                break;
        }
    }

    /**
     * Handle mouse move
     */
    _onMouseMove(event) {
        const rect = this.viewer.canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;

        this.mouse.x = x;
        this.mouse.y = y;

        // Check for spawner zone resizing
        const spawner = window.cellApp?.atomSpawner;
        if (spawner && spawner.resizing) {
            const scale = this.viewer.camera.zoom;
            spawner.updateResize(x, y, scale);
            this.viewer.render();
            return;
        }

        // Panning
        if (this.mouse.dragging && this.mouse.down) {
            const dx = x - this.mouse.dragStartX;
            const dy = y - this.mouse.dragStartY;

            this.viewer.pan(dx, dy);

            this.mouse.dragStartX = x;
            this.mouse.dragStartY = y;

            // Render immediately so view updates even when paused
            this.viewer.render();
        }

        // Check for spawner resize handle hover
        if (spawner && spawner.active) {
            const scale = this.viewer.camera.zoom;
            const offset = this.viewer.getOffset();
            const resizeEdge = spawner.getResizeHandleAt(x, y, scale, offset);

            if (resizeEdge) {
                this.viewer.canvas.style.cursor = spawner.getCursorForEdge(resizeEdge);
                return;
            }
        }

        // Hover effects
        this._updateHover(x, y);
    }

    /**
     * Handle mouse up
     */
    _onMouseUp(event) {
        // End spawner resize if active
        const spawner = window.cellApp?.atomSpawner;
        if (spawner && spawner.resizing) {
            spawner.endResize();

            // Update modal inputs if open
            const widthInput = document.getElementById('zoneWidth');
            const heightInput = document.getElementById('zoneHeight');
            if (widthInput) widthInput.value = Math.round(spawner.zone.width);
            if (heightInput) heightInput.value = Math.round(spawner.zone.height);
        }

        this.mouse.down = false;
        this.mouse.dragging = false;

        this.viewer.canvas.style.cursor = this._getCursorForTool(this.tool);
    }

    /**
     * Handle mouse wheel (zoom)
     */
    _onWheel(event) {
        event.preventDefault();

        const rect = this.viewer.canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;

        const delta = -Math.sign(event.deltaY);
        this.viewer.zoom(delta, x, y);

        // Render immediately so view updates even when paused
        this.viewer.render();
    }

    /**
     * Handle key down
     */
    _onKeyDown(event) {
        // Ignore keyboard shortcuts when typing in input fields
        const activeElement = document.activeElement;
        const isTyping = activeElement && (
            activeElement.tagName === 'INPUT' ||
            activeElement.tagName === 'TEXTAREA' ||
            activeElement.isContentEditable
        );
        if (isTyping) {
            return;
        }

        this.keys.add(event.key);

        // Number keys for abstraction level
        if (event.key >= '1' && event.key <= '5') {
            this.viewer.setLevel(parseInt(event.key) - 1);
            this._updateLevelButtons();
        }

        // Space to toggle simulation
        if (event.key === ' ') {
            event.preventDefault();
            this.simulation.toggle();
            this._updatePlayButton();
        }

        // S for step
        if (event.key === 's' || event.key === 'S') {
            this.simulation.step();
        }

        // Delete/Backspace to delete selected
        if (event.key === 'Delete' || event.key === 'Backspace') {
            this._deleteSelected();
        }

        // Escape to clear selection
        if (event.key === 'Escape') {
            this.viewer.clearSelection();
            this.selectedBlueprint = null;
        }
    }

    /**
     * Handle key up
     */
    _onKeyUp(event) {
        this.keys.delete(event.key);
    }

    /**
     * Handle place action
     */
    _handlePlace(screenX, screenY) {
        const worldPos = this.viewer.screenToWorld(screenX, screenY);

        // Check bounds
        if (worldPos.x < 0 || worldPos.x > this.environment.width ||
            worldPos.y < 0 || worldPos.y > this.environment.height) {
            return;
        }

        // At cell level (3+), place prokaryotes
        if (this.viewer.level >= 3) {
            const prokaryote = new Prokaryote({});
            prokaryote.position = new Vector2(worldPos.x, worldPos.y);
            prokaryote.cytoplasm.atp = 100;  // Start with some energy
            this.environment.addProkaryote(prokaryote);
        }
        // At polymer level (2), create polymer intention (attract molecules)
        else if (this.viewer.level === 2) {
            if (this.selectedPolymerTemplate) {
                // Create polymer intention zone
                const intention = new Intention('polymer', this.selectedPolymerTemplate, worldPos.x, worldPos.y);
                this.environment.addIntention(intention);
                console.log(`Placed polymer intention: ${this.selectedPolymerTemplate.name}`);
            } else if (this.selectedBlueprint) {
                // Fall back to molecule intention
                const intention = new Intention('molecule', this.selectedBlueprint, worldPos.x, worldPos.y);
                this.environment.addIntention(intention);
                console.log(`Placed molecule intention: ${this.selectedBlueprint.name || this.selectedBlueprint.formula}`);
            }
        }
        // At molecule level (1), create molecule intention (attract atoms)
        else if (this.viewer.level === 1) {
            if (this.selectedBlueprint) {
                // Create molecule intention zone
                const intention = new Intention('molecule', this.selectedBlueprint, worldPos.x, worldPos.y);
                this.environment.addIntention(intention);
                console.log(`Placed molecule intention: ${this.selectedBlueprint.name || this.selectedBlueprint.formula}`);
            }
            // Don't place atoms at molecule level - require blueprint selection
        }
        // At atom level (0), place single atoms
        else {
            const atom = new Atom(this.selectedElement, worldPos.x, worldPos.y);
            this.environment.addAtom(atom);
        }

        // Immediate render so entity appears even when paused
        this.viewer.render();
    }

    /**
     * Handle select action
     */
    _handleSelect(screenX, screenY) {
        const result = this.viewer.getEntityAt(screenX, screenY);

        this.viewer.clearSelection();

        if (result) {
            if (result.type === 'atom') {
                result.entity.selected = true;
                this.viewer.selectedAtom = result.entity;
            } else if (result.type === 'molecule') {
                result.entity.selected = true;
                this.viewer.selectedMolecule = result.entity;
            } else if (result.type === 'prokaryote') {
                this.viewer.selectedCell = result.entity;
            } else if (result.type === 'polymer') {
                result.entity.selected = true;
            } else if (result.type === 'intention') {
                result.entity.selected = true;
                this.viewer.selectedIntention = result.entity;
            }

            this._updateInspector(result);
            this._switchToInspectorTab();
        }
    }

    /**
     * Switch to inspector tab
     */
    _switchToInspectorTab() {
        // Update tab buttons
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.tab === 'inspector');
        });

        // Update tab content
        document.querySelectorAll('.tab-content').forEach(content => {
            content.classList.toggle('active', content.id === 'inspectorTab');
        });
    }

    /**
     * Handle delete action
     */
    _handleDelete(screenX, screenY) {
        const worldPos = this.viewer.screenToWorld(screenX, screenY);
        const scale = this.viewer.camera.zoom;
        const offset = this.viewer.getOffset();

        // First check for intentions (highest priority for deletion)
        const intentions = this.environment.getAllIntentions ? this.environment.getAllIntentions() : [];
        for (const intention of intentions) {
            if (intention.containsPoint(screenX, screenY, scale, offset)) {
                // Remove the intention - gathered components are automatically freed
                this.environment.removeIntention(intention.id);
                console.log(`Deleted intention: ${intention.blueprint?.name || intention.type}`);
                this.viewer.render();
                return;
            }
        }

        // Then check for regular entities
        const result = this.viewer.getEntityAt(screenX, screenY);
        if (!result) return;

        // At cell level (3) or higher, delete prokaryotes
        if (this.viewer.level >= 3 && result.type === 'prokaryote') {
            this.environment.removeProkaryote(result.entity.id);
        }
        // At molecule level (1) or higher, delete entire molecules
        else if (this.viewer.level >= 1 && result.type === 'molecule') {
            const atoms = [...result.entity.atoms];
            for (const atom of atoms) {
                this.environment.removeAtom(atom.id);
            }
            this.environment.removeMolecule(result.entity.id);
        } else if (result.type === 'atom') {
            this.environment.removeAtom(result.entity.id);
        } else if (result.type === 'molecule') {
            // Fallback: delete molecule at any level
            const atoms = [...result.entity.atoms];
            for (const atom of atoms) {
                this.environment.removeAtom(atom.id);
            }
            this.environment.removeMolecule(result.entity.id);
        }

        // Immediate render to show deletion
        this.viewer.render();
    }

    /**
     * Delete currently selected entity
     */
    _deleteSelected() {
        if (this.viewer.selectedAtom) {
            this.environment.removeAtom(this.viewer.selectedAtom.id);
            this.viewer.selectedAtom = null;
        }
        if (this.viewer.selectedMolecule) {
            // Delete all atoms in molecule
            const atoms = [...this.viewer.selectedMolecule.atoms];
            for (const atom of atoms) {
                this.environment.removeAtom(atom.id);
            }
            this.environment.removeMolecule(this.viewer.selectedMolecule.id);
            this.viewer.selectedMolecule = null;
        }
    }

    /**
     * Update hover effects
     */
    _updateHover(screenX, screenY) {
        // Clear previous hover
        if (this.viewer.hoveredAtom) {
            this.viewer.hoveredAtom.highlighted = false;
            this.viewer.hoveredAtom = null;
        }
        if (this.viewer.hoveredMolecule) {
            this.viewer.hoveredMolecule.highlighted = false;
            this.viewer.hoveredMolecule = null;
        }

        // Find new hover
        const result = this.viewer.getEntityAt(screenX, screenY);

        if (result) {
            result.entity.highlighted = true;
            if (result.type === 'atom') {
                this.viewer.hoveredAtom = result.entity;
            } else {
                this.viewer.hoveredMolecule = result.entity;
            }
        }
    }

    /**
     * Update level buttons UI
     */
    _updateLevelButtons() {
        const buttons = document.querySelectorAll('.level-btn');
        buttons.forEach((btn, i) => {
            btn.classList.toggle('active', i === this.viewer.level);
        });
    }

    /**
     * Update play button UI
     */
    _updatePlayButton() {
        const btn = document.getElementById('playPauseBtn');
        if (btn) {
            btn.textContent = this.simulation.running ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Play';
        }
    }

    /**
     * Update inspector panel
     */
    _updateInspector(result) {
        const content = document.getElementById('inspectorContent');
        if (!content) return;

        if (result.type === 'atom') {
            const atom = result.entity;
            // Get polymer ID through molecule
            let polymerIdStr = '';
            if (atom.moleculeId && this.environment) {
                const mol = this.environment.molecules.get(atom.moleculeId);
                if (mol && mol.polymerId) {
                    polymerIdStr = `<p>Polymer ID: ${mol.polymerId}</p>`;
                }
            }
            content.innerHTML = `
                <div class="inspector-item">
                    <h3>${atom.element.name} (${atom.symbol})</h3>
                    <p>Atomic Number: ${atom.element.number}</p>
                    <p>Mass: ${atom.mass.toFixed(3)} u</p>
                    <p>Valence: ${atom.bondCount}/${atom.maxBonds}</p>
                    <p>Bonds: ${atom.bonds.length}</p>
                    <p>Position: (${atom.position.x.toFixed(1)}, ${atom.position.y.toFixed(1)})</p>
                    ${atom.moleculeId ? `<p>Molecule ID: ${atom.moleculeId}</p>` : ''}
                    ${polymerIdStr}
                </div>
            `;
        } else if (result.type === 'molecule') {
            const mol = result.entity;
            const isInCatalogue = window.cellApp?.catalogue?.hasMolecule?.(mol.fingerprint);
            const catalogueBtn = mol.isStable()
                ? (isInCatalogue
                    ? '<p style="color: #4ade80;">&#10003; In Catalogue</p>'
                    : '<button class="tool-btn" onclick="window.cellApp.registerMolecule()">Add to Catalogue</button>')
                : '';

            // Generate unique canvas ID
            const canvasId = 'inspector-mol-preview-' + mol.id.substring(0, 8);

            content.innerHTML = `
                <div class="inspector-item">
                    <h3>${mol.name || mol.formula}</h3>
                    <div class="inspector-shape-preview">
                        <canvas id="${canvasId}" width="120" height="120"></canvas>
                    </div>
                    <p>Molecule ID: ${mol.id}</p>
                    <p>Formula: ${mol.formula}</p>
                    <p>Mass: ${mol.mass.toFixed(3)} u</p>
                    <p>Atoms: ${mol.atoms.length}</p>
                    <p>Bonds: ${mol.bonds.length}</p>
                    <p>Stable: ${mol.isStable() ? 'Yes &#10003;' : 'No'}</p>
                    ${mol.isReshaping ? '<p style="color: #4ade80;">Reshaping...</p>' : ''}
                    ${mol.polymerId ? `<p>Polymer ID: ${mol.polymerId}</p>` : ''}
                    ${catalogueBtn}
                </div>
            `;

            // Render molecule shape preview after DOM update
            setTimeout(() => {
                this._renderMoleculePreview(canvasId, mol);
            }, 0);
        } else if (result.type === 'prokaryote') {
            const prok = result.entity;
            const components = prok.getComponentSummary();
            content.innerHTML = `
                <div class="inspector-item">
                    <h3>Prokaryote (Gen ${prok.generation})</h3>
                    <p>ATP: ${prok.cytoplasm.atp.toFixed(1)} / ${prok.cytoplasm.maxAtp}</p>
                    <p>Age: ${prok.age} ticks</p>
                    <p>Position: (${prok.position.x.toFixed(1)}, ${prok.position.y.toFixed(1)})</p>
                    <p>Membrane: ${components.membrane} polymers</p>
                    <p>Nucleoid: ${components.nucleoid} polymers</p>
                    <p>Ribosomes: ${components.ribosomes} polymers</p>
                    <p>Alive: ${prok.isAlive ? 'Yes &#10003;' : 'No'}</p>
                </div>
            `;
        } else if (result.type === 'polymer') {
            const poly = result.entity;
            const typeLabel = poly.getLabel ? poly.getLabel() : 'Polymer';
            content.innerHTML = `
                <div class="inspector-item">
                    <h3>${poly.name || typeLabel}</h3>
                    <p>Polymer ID: ${poly.id}</p>
                    <p>Type: ${typeLabel}</p>
                    <p>Molecules: ${poly.molecules.length}</p>
                    <p>Sequence: ${poly.sequence.substring(0, 30)}${poly.sequence.length > 30 ? '...' : ''}</p>
                    <p>Mass: ${poly.mass.toFixed(3)} u</p>
                    <p>Stable: ${poly.isStable() ? 'Yes &#10003;' : 'No'}</p>
                    ${poly.cellRole ? `<p>Cell Role: ${poly.cellRole}</p>` : ''}
                </div>
            `;
        } else if (result.type === 'intention') {
            const intention = result.entity;
            const bpName = intention.blueprint?.name || intention.blueprint?.formula || 'Unknown';
            const requirements = intention.getRequirements();
            const reqCount = requirements?.count || '?';
            const reqType = requirements?.type || 'components';

            // Build requirements details based on type
            let reqDetails = '';
            if (requirements?.type === 'atoms') {
                const elements = requirements.elements?.join(', ') || 'Various';
                reqDetails = `<p><strong>Needs:</strong> ${reqCount} atoms</p><p>Elements: ${elements}</p>`;
            } else if (requirements?.type === 'monomers') {
                // NEW: Monomer-based polymer requirements
                const monomerName = requirements.monomerName || 'Unknown';
                const monomerFormula = requirements.monomerFormula;

                if (monomerFormula) {
                    // We know the exact monomer needed
                    reqDetails = `
                        <p><strong>Needs:</strong> ${reqCount}+ monomers</p>
                        <p><strong>Monomer:</strong> ${monomerName}</p>
                        <p style="color: #4ade80; font-weight: bold;">${monomerFormula}</p>
                        <p style="color: #94a3b8; font-size: 0.9em;"><em>Create ${reqCount}+ ${monomerFormula} molecules to form this polymer</em></p>
                    `;
                } else {
                    // Fallback for legacy blueprints without monomer template
                    const elements = requirements.requiredElements?.join(', ') || 'Various';
                    reqDetails = `<p><strong>Needs:</strong> ${reqCount} molecules</p><p><strong>With elements:</strong> ${elements}</p>`;
                }
            } else if (requirements?.type === 'molecules') {
                // Legacy support for old polymer blueprints
                const elements = requirements.requiredElements?.join(', ') || 'Various';
                reqDetails = `<p><strong>Needs:</strong> ${reqCount} molecules</p><p>With elements: ${elements}</p>`;
            } else if (requirements?.type === 'polymers') {
                const roles = requirements.roles?.join(', ') || 'Various';
                reqDetails = `<p><strong>Needs polymers with roles:</strong></p><p>${roles}</p>`;
            }

            content.innerHTML = `
                <div class="inspector-item">
                    <h3>Intention: ${bpName}</h3>
                    <p>Type: ${intention.type}</p>
                    <p>Target: ${bpName}</p>
                    <hr style="border-color: #444; margin: 8px 0;">
                    ${reqDetails}
                    <hr style="border-color: #444; margin: 8px 0;">
                    <p>Progress: ${Math.round(intention.progress * 100)}%</p>
                    <p>Gathered: ${intention.gatheredComponents.size} / ${reqCount}</p>
                    <p>Radius: ${intention.radius} units</p>
                    <p>Position: (${intention.position.x.toFixed(0)}, ${intention.position.y.toFixed(0)})</p>
                    <p>Fulfilled: ${intention.fulfilled ? 'Yes &#10003;' : 'No'}</p>
                    <button class="tool-btn" onclick="window.cellApp.deleteIntention('${intention.id}')">Delete Intention</button>
                </div>
            `;
        }
    }

    /**
     * Render a molecule shape preview on a canvas
     * @param {string} canvasId - ID of the canvas element
     * @param {Molecule} mol - The molecule to render
     */
    _renderMoleculePreview(canvasId, mol) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;

        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        const centerX = width / 2;
        const centerY = height / 2;

        // Clear canvas
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, width, height);

        if (!mol.atoms || mol.atoms.length === 0) return;

        // Calculate bounds of molecule
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        const molCenter = mol.centerOfMass;

        for (const atom of mol.atoms) {
            const relX = atom.position.x - molCenter.x;
            const relY = atom.position.y - molCenter.y;
            minX = Math.min(minX, relX);
            minY = Math.min(minY, relY);
            maxX = Math.max(maxX, relX);
            maxY = Math.max(maxY, relY);
        }

        // Calculate scale to fit in canvas with padding
        const padding = 15;
        const molWidth = maxX - minX + 40;
        const molHeight = maxY - minY + 40;
        const scale = Math.min(
            (width - padding * 2) / molWidth,
            (height - padding * 2) / molHeight,
            2 // Max scale
        );

        // Draw bonds first
        for (const bond of mol.bonds) {
            const x1 = centerX + (bond.atom1.position.x - molCenter.x) * scale;
            const y1 = centerY + (bond.atom1.position.y - molCenter.y) * scale;
            const x2 = centerX + (bond.atom2.position.x - molCenter.x) * scale;
            const y2 = centerY + (bond.atom2.position.y - molCenter.y) * scale;

            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;

            if (bond.order === 1) {
                // Single bond - one line
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            } else if (bond.order === 2) {
                // Double bond - two parallel lines
                const dx = x2 - x1;
                const dy = y2 - y1;
                const len = Math.sqrt(dx * dx + dy * dy);
                const offsetX = (-dy / len) * 3;
                const offsetY = (dx / len) * 3;

                ctx.beginPath();
                ctx.moveTo(x1 + offsetX, y1 + offsetY);
                ctx.lineTo(x2 + offsetX, y2 + offsetY);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(x1 - offsetX, y1 - offsetY);
                ctx.lineTo(x2 - offsetX, y2 - offsetY);
                ctx.stroke();
            } else if (bond.order === 3) {
                // Triple bond - three parallel lines
                const dx = x2 - x1;
                const dy = y2 - y1;
                const len = Math.sqrt(dx * dx + dy * dy);
                const offsetX = (-dy / len) * 4;
                const offsetY = (dx / len) * 4;

                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(x1 + offsetX, y1 + offsetY);
                ctx.lineTo(x2 + offsetX, y2 + offsetY);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(x1 - offsetX, y1 - offsetY);
                ctx.lineTo(x2 - offsetX, y2 - offsetY);
                ctx.stroke();
            }
        }

        // Draw atoms
        for (const atom of mol.atoms) {
            const x = centerX + (atom.position.x - molCenter.x) * scale;
            const y = centerY + (atom.position.y - molCenter.y) * scale;
            const radius = Math.max(8, (atom.radius || 10) * scale * 0.5);

            // Atom circle with element color
            const element = getElement(atom.symbol);
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fillStyle = element?.color || '#888';
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Element symbol
            ctx.fillStyle = '#fff';
            ctx.font = `bold ${Math.max(8, radius * 0.9)}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(atom.symbol, x, y);
        }

        // Draw border
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        ctx.strokeRect(0, 0, width, height);
    }

    /**
     * Update inspector with polymer template data (before placing intention)
     * @param {Object} template - Polymer blueprint template
     */
    updateInspectorWithPolymerTemplate(template) {
        const content = document.getElementById('inspectorContent');
        if (!content || !template) return;

        // Switch to inspector tab
        this._switchToInspectorTab();

        // Get monomer info
        let monomerInfo = '';
        if (template.monomerId) {
            const monomerTemplate = typeof getMonomerTemplate === 'function'
                ? getMonomerTemplate(template.monomerId)
                : null;
            if (monomerTemplate) {
                monomerInfo = `
                    <hr style="border-color: #444; margin: 8px 0;">
                    <p><strong>Monomer Required:</strong></p>
                    <p>${monomerTemplate.name}</p>
                    <p style="color: #4ade80; font-weight: bold;">${monomerTemplate.formula}</p>
                    <p style="color: #94a3b8; font-size: 0.9em;"><em>Create ${template.minMonomers || 2}+ of these molecules</em></p>
                `;
            }
        }

        // Get type color
        const typeColors = {
            'lipid': '#f59e0b',
            'protein': '#22c55e',
            'nucleic_acid': '#3b82f6',
            'carbohydrate': '#ec4899',
            'generic': '#8b5cf6'
        };
        const typeColor = typeColors[template.type] || '#8b5cf6';

        content.innerHTML = `
            <div class="inspector-item">
                <h3 style="color: ${typeColor};">${template.name}</h3>
                <p><strong>Type:</strong> ${template.type}</p>
                <p>${template.description || ''}</p>
                ${template.essential ? '<p style="color: #4ade80;">&#9733; Essential for cells</p>' : ''}
                ${template.cellRole ? `<p><strong>Cell Role:</strong> ${template.cellRole}</p>` : ''}
                <hr style="border-color: #444; margin: 8px 0;">
                <p><strong>Min Monomers:</strong> ${template.minMonomers || template.minMolecules || 2}</p>
                ${monomerInfo}
                <hr style="border-color: #444; margin: 8px 0;">
                <p style="color: #94a3b8;"><em>Click in the view to place this polymer intention</em></p>
            </div>
        `;
    }
}

// Make available globally
window.Controls = Controls;



// ==== src/viewer/catalogue-ui.js ====
/**
 * Catalogue UI
 * User interface for the catalogue panel
 */

class CatalogueUI {
    /**
     * Create catalogue UI
     * @param {Catalogue} catalogue - The catalogue instance
     * @param {Controls} controls - The controls instance
     */
    constructor(catalogue, controls) {
        this.catalogue = catalogue;
        this.controls = controls;

        // DOM elements
        this.listContainer = document.getElementById('catalogueList');
        this.searchInput = document.getElementById('catalogueSearch');

        // Set up callbacks
        this.catalogue.onBlueprintAdded = this._onBlueprintAdded.bind(this);

        // Bind events
        this._bindEvents();

        // Initial render
        this.render();
    }

    /**
     * Bind event listeners
     */
    _bindEvents() {
        if (this.searchInput) {
            this.searchInput.addEventListener('input', Utils.debounce(() => {
                this.render(this.searchInput.value);
            }, 200));
        }
    }

    /**
     * Callback when new blueprint is added
     */
    _onBlueprintAdded(blueprint) {
        this.render();
    }

    /**
     * Render the catalogue list
     * @param {string} filter - Optional search filter
     */
    render(filter = '') {
        if (!this.listContainer) return;

        // Helper: calculate if blueprint is truly stable from its data
        const isBlueprintStable = (bp) => {
            if (!bp.atomData || bp.atomData.length < 2) return false;
            if (!bp.bondData || bp.bondData.length < 1) return false;

            // Calculate valence usage for each atom
            const atomValences = {};
            for (const atom of bp.atomData) {
                const element = getElement(atom.symbol);
                if (!element) return false;
                atomValences[atom.index] = { max: element.valence, used: 0 };
            }

            // Count bonds for each atom
            for (const bond of bp.bondData) {
                const order = bond.order || 1;
                if (atomValences[bond.atom1Index]) {
                    atomValences[bond.atom1Index].used += order;
                }
                if (atomValences[bond.atom2Index]) {
                    atomValences[bond.atom2Index].used += order;
                }
            }

            // Check all atoms have filled valence
            for (const idx in atomValences) {
                const v = atomValences[idx];
                if (v.used !== v.max) return false;
            }
            return true;
        };

        let html = '';
        const filterLower = filter.toLowerCase();

        // Section 1: Atoms
        const commonAtoms = ['H', 'C', 'N', 'O', 'P', 'S', 'Cl', 'Na', 'K', 'Ca', 'Fe'];
        const matchingAtoms = filter
            ? commonAtoms.filter(s => s.toLowerCase().includes(filterLower) || getElement(s)?.name.toLowerCase().includes(filterLower))
            : commonAtoms;

        if (matchingAtoms.length > 0) {
            html += '<div class="catalogue-section"><h4>Atoms</h4><div class="catalogue-grid">';
            for (const symbol of matchingAtoms) {
                const element = getElement(symbol);
                if (element) {
                    html += `
                        <button class="catalogue-atom-btn" data-symbol="${symbol}" data-level="0">
                            <span class="atom-symbol">${symbol}</span>
                            <span class="atom-name">${element.name}</span>
                        </button>
                    `;
                }
            }
            html += '</div></div>';
        }

        // Section 2: Molecules
        const allBlueprints = filter
            ? this.catalogue.search(filter)
            : this.catalogue.getAllMolecules();
        const blueprints = allBlueprints.filter(bp => isBlueprintStable(bp));
        blueprints.sort((a, b) => b.createdAt - a.createdAt);

        if (blueprints.length > 0) {
            html += '<div class="catalogue-section"><h4>Molecules</h4>';
            html += blueprints.map(bp => this._renderItem(bp)).join('');
            html += '</div>';
        }

        // Section 3: Polymer Templates
        const polymerTemplates = window.getAllPolymerTemplates ? window.getAllPolymerTemplates() : [];
        const matchingPolymers = filter
            ? polymerTemplates.filter(p => p.name.toLowerCase().includes(filterLower) || p.type.toLowerCase().includes(filterLower))
            : polymerTemplates;

        if (matchingPolymers.length > 0) {
            html += '<div class="catalogue-section"><h4>Polymer Templates</h4><div class="catalogue-grid">';
            for (const template of matchingPolymers) {
                const colorMap = { lipid: '#ef4444', protein: '#3b82f6', nucleic_acid: '#22c55e', carbohydrate: '#f59e0b' };
                const color = colorMap[template.type] || '#8b5cf6';
                html += `
                    <button class="catalogue-polymer-btn" data-polymer-id="${template.id}" data-level="2" style="border-color: ${color};">
                        <span class="polymer-name">${template.name}</span>
                        <span class="polymer-type">${template.type}</span>
                    </button>
                `;
            }
            html += '</div></div>';
        }

        if (!html) {
            html = '<p class="empty-state">No matches found.</p>';
        }

        this.listContainer.innerHTML = html;

        // Bind atom click handlers
        this.listContainer.querySelectorAll('.catalogue-atom-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const symbol = btn.dataset.symbol;
                const level = parseInt(btn.dataset.level);
                this.controls.setSelectedElement(symbol);
                this.controls.setTool('place');
                if (window.cellApp) window.cellApp.setLevel(level);
            });
        });

        // Bind molecule click handlers
        this.listContainer.querySelectorAll('.catalogue-item').forEach(item => {
            const fingerprint = item.dataset.fingerprint;
            item.addEventListener('click', () => {
                this._selectBlueprint(fingerprint);
                if (window.cellApp) window.cellApp.setLevel(1); // Molecule level
            });
        });

        // Bind polymer click handlers
        this.listContainer.querySelectorAll('.catalogue-polymer-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const polymerId = btn.dataset.polymerId;
                const level = parseInt(btn.dataset.level);
                const template = polymerTemplates.find(p => p.id === polymerId);
                if (template) {
                    this.controls.selectedPolymerTemplate = template;
                    this.controls.setTool('place');
                    // Show polymer template data in inspector
                    if (this.controls.updateInspectorWithPolymerTemplate) {
                        this.controls.updateInspectorWithPolymerTemplate(template);
                    }
                    if (window.cellApp) window.cellApp.setLevel(level);
                }
            });
        });
    }


    /**
     * Render a single catalogue item
     */
    _renderItem(blueprint) {
        const isSelected = this.controls.selectedBlueprint?.fingerprint === blueprint.fingerprint;
        const atomCount = blueprint.atomData ? blueprint.atomData.length : 0;
        // Encode fingerprint for safe HTML attribute storage
        const encodedFingerprint = encodeURIComponent(blueprint.fingerprint);

        return `
            <div class="catalogue-item ${isSelected ? 'selected' : ''}" 
                 data-fingerprint="${encodedFingerprint}"
                 title="${blueprint.name} - ${blueprint.formula}">
                <div class="catalogue-item-preview">
                    <canvas class="preview-canvas" 
                            width="40" height="40"
                            data-fingerprint="${encodedFingerprint}"></canvas>
                </div>
                <div class="catalogue-item-info">
                    <div class="catalogue-item-name">${blueprint.name}</div>
                    <div class="catalogue-item-formula">${atomCount} atoms</div>
                </div>
                <div class="catalogue-item-status">
                    ${blueprint.isStable ? '&#10003;' : '!'}
                </div>
            </div>
        `;
    }

    /**
     * Select a blueprint for placement
     */
    _selectBlueprint(encodedFingerprint) {
        // Decode the URI-encoded fingerprint
        const fingerprint = decodeURIComponent(encodedFingerprint);
        const blueprint = this.catalogue.getMolecule(fingerprint);
        if (blueprint) {
            this.controls.setSelectedBlueprint(blueprint);
            this.controls.setTool('place');

            // Switch to molecule level if at atom level
            if (this.controls.viewer && this.controls.viewer.level < 1) {
                this.controls.viewer.setLevel(1);
                // Update level buttons
                document.querySelectorAll('.level-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.level === '1');
                });
            }

            // Update UI
            document.querySelectorAll('.catalogue-item').forEach(item => {
                item.classList.toggle('selected', item.dataset.fingerprint === encodedFingerprint);
            });

            // Clear atom selection
            document.querySelectorAll('.atom-btn').forEach(btn => {
                btn.classList.remove('selected');
            });

            // Switch to inspector tab and show blueprint preview
            this._showBlueprintInspector(blueprint);
        }
    }

    /**
     * Show blueprint in the inspector panel
     * @param {MoleculeBlueprint} blueprint - The blueprint to display
     */
    _showBlueprintInspector(blueprint) {
        // Switch to inspector tab
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.tab === 'inspector');
        });
        document.querySelectorAll('.tab-content').forEach(content => {
            content.classList.toggle('active', content.id === 'inspectorTab');
        });

        // Update inspector content
        const content = document.getElementById('inspectorContent');
        if (!content) return;

        const atomCount = blueprint.atomData ? blueprint.atomData.length : 0;
        const bondCount = blueprint.bondData ? blueprint.bondData.length : 0;
        const canvasId = 'inspector-blueprint-preview';

        // Count elements
        const elementCounts = {};
        if (blueprint.atomData) {
            for (const atom of blueprint.atomData) {
                elementCounts[atom.symbol] = (elementCounts[atom.symbol] || 0) + 1;
            }
        }
        const elementList = Object.entries(elementCounts)
            .map(([sym, count]) => `${sym}: ${count}`)
            .join(', ');

        content.innerHTML = `
            <div class="inspector-item">
                <h3>üìã ${blueprint.name || blueprint.formula}</h3>
                <p style="color: #94a3b8; font-style: italic; margin-bottom: 8px;">Click on canvas to place intention</p>
                <div class="inspector-shape-preview">
                    <canvas id="${canvasId}" width="140" height="140"></canvas>
                </div>
                <p><strong>Formula:</strong> ${blueprint.formula}</p>
                <p><strong>Atoms:</strong> ${atomCount} (${elementList})</p>
                <p><strong>Bonds:</strong> ${bondCount}</p>
                <p><strong>Mass:</strong> ${blueprint.mass?.toFixed(3) || '?'} u</p>
                <p style="color: #4ade80;">‚úì Stable Configuration</p>
            </div>
        `;

        // Render blueprint preview after DOM update
        setTimeout(() => {
            this._renderBlueprintPreview(canvasId, blueprint);
        }, 0);
    }

    /**
     * Render a blueprint shape preview on a canvas
     * @param {string} canvasId - ID of the canvas element
     * @param {MoleculeBlueprint} blueprint - The blueprint to render
     */
    _renderBlueprintPreview(canvasId, blueprint) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;

        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        const centerX = width / 2;
        const centerY = height / 2;

        // Clear canvas
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, width, height);

        if (!blueprint.atomData || blueprint.atomData.length === 0) return;

        // Calculate bounds from relative positions
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;

        for (const atom of blueprint.atomData) {
            minX = Math.min(minX, atom.relX);
            minY = Math.min(minY, atom.relY);
            maxX = Math.max(maxX, atom.relX);
            maxY = Math.max(maxY, atom.relY);
        }

        // Calculate scale to fit in canvas with padding
        const padding = 20;
        const bpWidth = maxX - minX + 40;
        const bpHeight = maxY - minY + 40;
        const scale = Math.min(
            (width - padding * 2) / bpWidth,
            (height - padding * 2) / bpHeight,
            2 // Max scale
        );

        // Draw bonds first
        if (blueprint.bondData) {
            for (const bond of blueprint.bondData) {
                const atom1 = blueprint.atomData[bond.atom1Index];
                const atom2 = blueprint.atomData[bond.atom2Index];
                if (!atom1 || !atom2) continue;

                const x1 = centerX + atom1.relX * scale;
                const y1 = centerY + atom1.relY * scale;
                const x2 = centerX + atom2.relX * scale;
                const y2 = centerY + atom2.relY * scale;

                ctx.strokeStyle = '#666';
                ctx.lineWidth = 2;

                const order = bond.order || 1;
                if (order === 1) {
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                } else if (order === 2) {
                    const dx = x2 - x1;
                    const dy = y2 - y1;
                    const len = Math.sqrt(dx * dx + dy * dy);
                    const offsetX = (-dy / len) * 3;
                    const offsetY = (dx / len) * 3;

                    ctx.beginPath();
                    ctx.moveTo(x1 + offsetX, y1 + offsetY);
                    ctx.lineTo(x2 + offsetX, y2 + offsetY);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(x1 - offsetX, y1 - offsetY);
                    ctx.lineTo(x2 - offsetX, y2 - offsetY);
                    ctx.stroke();
                } else if (order === 3) {
                    const dx = x2 - x1;
                    const dy = y2 - y1;
                    const len = Math.sqrt(dx * dx + dy * dy);
                    const offsetX = (-dy / len) * 4;
                    const offsetY = (dx / len) * 4;

                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(x1 + offsetX, y1 + offsetY);
                    ctx.lineTo(x2 + offsetX, y2 + offsetY);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(x1 - offsetX, y1 - offsetY);
                    ctx.lineTo(x2 - offsetX, y2 - offsetY);
                    ctx.stroke();
                }
            }
        }

        // Draw atoms
        for (const atomData of blueprint.atomData) {
            const x = centerX + atomData.relX * scale;
            const y = centerY + atomData.relY * scale;

            const element = getElement(atomData.symbol);
            const radius = Math.max(10, (element?.radius || 10) * scale * 0.4);

            // Atom circle with element color
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fillStyle = element?.color || '#888';
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Element symbol
            ctx.fillStyle = '#fff';
            ctx.font = `bold ${Math.max(9, radius * 0.8)}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(atomData.symbol, x, y);
        }

        // Draw border
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        ctx.strokeRect(0, 0, width, height);
    }

    /**
     * Render preview canvases
     */
    renderPreviews() {
        const canvases = this.listContainer.querySelectorAll('.preview-canvas');

        canvases.forEach(canvas => {
            const fingerprint = canvas.dataset.fingerprint;
            const blueprint = this.catalogue.getMolecule(fingerprint);

            if (blueprint) {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                blueprint.renderPreview(ctx, canvas.width / 2, canvas.height / 2, 35);
            }
        });
    }
}

// Style additions for catalogue items
const style = document.createElement('style');
style.textContent = `
    .catalogue-item {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px;
        background: var(--bg-tertiary);
        border: 1px solid var(--border-subtle);
        border-radius: 8px;
        cursor: pointer;
        transition: all 150ms ease;
    }
    
    .catalogue-item:hover {
        border-color: var(--accent-primary);
        transform: translateX(4px);
    }
    
    .catalogue-item.selected {
        border-color: var(--accent-primary);
        background: rgba(99, 102, 241, 0.1);
    }
    
    .catalogue-item-preview {
        flex-shrink: 0;
    }
    
    .preview-canvas {
        display: block;
        background: var(--bg-secondary);
        border-radius: 4px;
    }
    
    .catalogue-item-info {
        flex: 1;
        min-width: 0;
    }
    
    .catalogue-item-name {
        font-weight: 600;
        font-size: 0.875rem;
        color: var(--text-primary);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    
    .catalogue-item-formula {
        font-size: 0.75rem;
        color: var(--text-secondary);
    }
    
    .catalogue-item-status {
        font-size: 1rem;
    }
    
    .inspector-item {
        padding: 8px 0;
    }
    
    .inspector-item h3 {
        font-size: 1rem;
        margin-bottom: 8px;
        color: var(--accent-primary);
    }
    
    .inspector-item p {
        font-size: 0.875rem;
        color: var(--text-secondary);
        margin-bottom: 4px;
    }
    
    .inspector-shape-preview {
        display: flex;
        justify-content: center;
        margin: 12px 0;
    }
    
    .inspector-shape-preview canvas {
        border-radius: 8px;
        background: #1a1a2e;
    }
    
    .catalogue-section {
        margin-bottom: 16px;
    }
    
    .catalogue-section h4 {
        font-size: 0.75rem;
        color: var(--text-secondary);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-bottom: 8px;
        padding-bottom: 4px;
        border-bottom: 1px solid var(--border-subtle);
    }
    
    .catalogue-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 6px;
    }
    
    .catalogue-atom-btn {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 6px 4px;
        background: var(--bg-tertiary);
        border: 1px solid var(--border-subtle);
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.15s;
    }
    
    .catalogue-atom-btn:hover {
        background: rgba(99, 102, 241, 0.2);
        border-color: var(--accent-primary);
    }
    
    .catalogue-atom-btn .atom-symbol {
        font-weight: 700;
        font-size: 0.9rem;
        color: var(--text-primary);
    }
    
    .catalogue-atom-btn .atom-name {
        font-size: 0.65rem;
        color: var(--text-secondary);
    }
    
    .catalogue-polymer-btn {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 6px 4px;
        background: var(--bg-tertiary);
        border: 2px solid;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.15s;
    }
    
    .catalogue-polymer-btn:hover {
        background: rgba(139, 92, 246, 0.2);
    }
    
    .catalogue-polymer-btn .polymer-name {
        font-weight: 600;
        font-size: 0.7rem;
        color: var(--text-primary);
        text-align: center;
    }
    
    .catalogue-polymer-btn .polymer-type {
        font-size: 0.6rem;
        color: var(--text-secondary);
    }
`;
document.head.appendChild(style);

// Make available globally
window.CatalogueUI = CatalogueUI;


// ==== src/viewer/tutorial.js ====
/**
 * Tutorial System
 * Guides new users through the simulation interface
 * Non-blocking: users can interact with the simulation during the tutorial
 * Uses FIXED positions to avoid UI state dependencies
 */

class Tutorial {
    constructor(app) {
        this.app = app;
        this.currentStep = 0;
        this.active = false;
        this.balloon = null;
        this.highlightEl = null;
        
        // Fixed position constants (pixels from edges)
        // These avoid overlap with: left panel (280px), right panel (280px), header (60px), status (32px)
        this.POSITIONS = {
            // For highlighting left panel elements - balloon goes to immediate right
            RIGHT_OF_LEFT_PANEL: { left: 300, top: 150 },
            // For highlighting right panel elements - balloon goes to immediate left  
            LEFT_OF_RIGHT_PANEL: { right: 300, top: 150 },
            // For canvas interaction - balloon in bottom-right corner of canvas area
            CANVAS_BOTTOM_RIGHT: { right: 320, bottom: 80 },
            // For header elements - balloon below header in center-left area
            BELOW_HEADER: { left: 400, top: 80 },
            // Below play button specifically (right side of header)
            BELOW_PLAY_BUTTON: { right: 400, top: 80 },
            // Above action buttons at bottom of left panel
            LEFT_PANEL_BOTTOM: { left: 300, bottom: 150 },
            // Center of screen
            CENTER: { center: true }
        };

        // Tutorial steps configuration
        this.steps = [
            // === INTRODUCTION === (Step 1/31)
            {
                id: 'welcome',
                title: 'Welcome to BioChemSim! üß¨',
                content: `Build molecules from atoms and watch chemistry happen!

<strong>This tutorial won't block you</strong> ‚Äì try things as you learn!

Use <strong>‚Üí</strong> key or click <strong>Next</strong> to continue.
Press <strong>Esc</strong> to exit anytime.`,
                target: null,
                fixedPosition: 'CENTER'
            },
            
            // === BASIC ATOM PLACEMENT === (Step 2/31)
            {
                id: 'atoms-palette',
                title: 'Step 1: The Atom Palette',
                content: `These are the elements you can place:

‚Ä¢ <strong>H</strong> (Hydrogen) ‚Äì 1 bond
‚Ä¢ <strong>C</strong> (Carbon) ‚Äì 4 bonds  
‚Ä¢ <strong>O</strong> (Oxygen) ‚Äì 2 bonds
‚Ä¢ <strong>N</strong> (Nitrogen) ‚Äì 3 bonds

<em>Click <strong>H</strong> to select it!</em>`,
                target: '#entityPalette',
                fixedPosition: 'RIGHT_OF_LEFT_PANEL'
            },
            // (Step 3/31)
            {
                id: 'place-atoms',
                title: 'Step 2: Place Atoms on Canvas',
                content: `With H selected, <strong>left-click on the canvas</strong> to place hydrogen atoms.

Place 2-3 hydrogens <strong>close together</strong> (but not overlapping).

<em>Go ahead, try it now!</em>`,
                target: null,
                fixedPosition: 'LEFT_PANEL_BOTTOM'
            },
            // (Step 4/31)
            {
                id: 'start-simulation',
                title: 'Step 3: Nothing Moving? Hit Play! ‚ñ∂Ô∏è',
                content: `The simulation starts <strong>paused</strong>.

Click <strong>‚ñ∂Ô∏è Play</strong> to start!

Once running:
‚Ä¢ Atoms move and collide
‚Ä¢ Close atoms with free bonds will <strong>bond together</strong>
‚Ä¢ Two H atoms form H‚ÇÇ molecule!`,
                target: '#playPauseBtn',
                fixedPosition: 'BELOW_PLAY_BUTTON'
            },
            // (Step 5/31)
            {
                id: 'watch-bonding',
                title: 'Chemistry in Action!',
                content: `Watch your atoms! They bond when:

‚úÖ Close enough to touch
‚úÖ Both have <strong>available bonds</strong>

H has 1 bond, so two H atoms form <strong>H‚ÇÇ</strong>

<em>See lines connecting bonded atoms!</em>`,
                target: null,
                fixedPosition: 'LEFT_PANEL_BOTTOM'
            },

            // === SELECT TOOL & INSPECTION === (Step 6/31)
            {
                id: 'select-tool-intro',
                title: 'Inspecting Your Creation',
                content: `Let's learn to inspect what you've made!

Click the <strong>üîç Select</strong> tool, then click on:
‚Ä¢ A <strong>free atom</strong> (not bonded)
‚Ä¢ An <strong>atom in a molecule</strong>
‚Ä¢ The <strong>bond line</strong> between atoms

<em>Watch what appears in the right panel!</em>`,
                target: '#selectTool',
                fixedPosition: 'RIGHT_OF_LEFT_PANEL'
            },
            // (Step 7/31)
            {
                id: 'inspector-panel',
                title: 'The Inspector Panel',
                content: `When you select something, the <strong>Inspector tab</strong> opens automatically!

‚Ä¢ <strong>Free atom</strong> ‚Üí shows element, position, available bonds
‚Ä¢ <strong>Bonded atom</strong> ‚Üí shows its molecule info too
‚Ä¢ <strong>Bond line</strong> ‚Üí shows connected atoms
‚Ä¢ <strong>Molecule</strong> ‚Üí shows formula, stability, all atoms

<em>Click the Inspector tab to see all details!</em>`,
                target: '[data-tab="inspector"]',
                fixedPosition: 'LEFT_OF_RIGHT_PANEL'
            },
            
            // === VIEW LEVELS === (Step 8/31)
            {
                id: 'levels-intro',
                title: 'View Levels: Different Perspectives',
                content: `The numbered buttons change your <strong>view level</strong>:

‚Ä¢ <strong>Level 1</strong> = Individual atoms (current)
‚Ä¢ <strong>Level 2</strong> = Molecules as shapes
‚Ä¢ <strong>Level 3+</strong> = Larger structures

<em>Click <strong>2</strong> to see Molecule View!</em>`,
                target: '#levelButtons',
                fixedPosition: 'BELOW_HEADER'
            },
            // (Step 9/31)
            {
                id: 'molecule-view-select',
                title: 'Selecting in Molecule View',
                content: `In <strong>Level 2</strong> (Molecule View):

‚Ä¢ Click a molecule to select it
‚Ä¢ The <strong>Inspector tab opens automatically</strong> with details
‚Ä¢ Molecules show as <strong>colored shapes</strong> with formula
‚Ä¢ <strong>White glow</strong> = stable molecule

<em>Try clicking your H‚ÇÇ molecule and check the Inspector!</em>`,
                target: null,
                fixedPosition: 'LEFT_PANEL_BOTTOM'
            },
            // (Step 10/31)
            {
                id: 'palette-changes',
                title: 'The Palette Changes Too!',
                content: `Notice the left palette is different now!

‚Ä¢ <strong>Level 1</strong> ‚Üí Atom palette (H, C, O, N...)
‚Ä¢ <strong>Level 2</strong> ‚Üí Molecule palette (your discoveries!)

When you discover stable molecules, they appear here for placement.

<em>Switch between Level 1 and 2 to see!</em>`,
                target: '#entityPalette',
                fixedPosition: 'RIGHT_OF_LEFT_PANEL'
            },

            // === BUILD WATER WITH RESHAPING === (Step 11/31)
            {
                id: 'build-water',
                title: 'Build Water (H‚ÇÇO) - Watch Reshaping!',
                content: `Switch to <strong>Level 1</strong> and build water:

1. Select <strong>O</strong> from palette
2. Place <strong>1 oxygen</strong>
3. Select <strong>H</strong>, place <strong>2 hydrogens</strong> nearby
4. Hit <strong>Play</strong> and watch!

<em>Notice how the molecule RESHAPES into proper geometry!</em>`,
                target: '#entityPalette',
                fixedPosition: 'RIGHT_OF_LEFT_PANEL'
            },
            // (Step 12/32)
            {
                id: 'reshaping-explained',
                title: 'Molecule Reshaping',
                content: `When atoms bond into a <strong>known molecule pattern</strong>:

1. Bonds form between nearby atoms
2. The molecule <strong>reshapes</strong> to correct geometry
3. Atoms move to their proper positions
4. The molecule becomes <strong>stable</strong> and glows!

<em>The simulation knows many common molecules and their shapes!</em>`,
                target: null,
                fixedPosition: 'LEFT_PANEL_BOTTOM'
            },
            // (Step 13/32)
            {
                id: 'molecule-colors',
                title: 'Molecule Colors in Level 2',
                content: `In <strong>Molecule View</strong>, colors show status:

‚Ä¢ <strong style="color: #4CAF50;">Green glow</strong> = Stable molecule
‚Ä¢ <strong style="color: #FFC107;">Yellow</strong> = Unstable (still forming)
‚Ä¢ <strong style="color: #2196F3;">Blue</strong> = Currently reshaping

<em>Switch to Level 2 to see your completed H‚ÇÇO!</em>`,
                target: null,
                fixedPosition: 'LEFT_PANEL_BOTTOM'
            },

            // === MOLECULE BLUEPRINTS & INTENTIONS === (Step 14/32)
            {
                id: 'molecule-palette',
                title: 'The Molecule Palette',
                content: `In <strong>Level 2</strong>, the left palette shows your discovered molecules.

<strong>Important:</strong> Unlike atoms, you <strong>cannot place molecules directly!</strong>

These are <strong>blueprints</strong> ‚Äì clicking one creates an <strong>Intention Zone</strong> instead.

<em>Let's learn what that means...</em>`,
                target: '#entityPalette',
                fixedPosition: 'RIGHT_OF_LEFT_PANEL'
            },
            // (Step 14/31)
            {
                id: 'intentions-intro',
                title: 'What are Intention Zones?',
                content: `An <strong>Intention Zone</strong> is a target area that guides chemistry:

‚Ä¢ Appears as a <strong>glowing circle</strong> on canvas
‚Ä¢ Represents your <strong>goal</strong>: form this molecule here
‚Ä¢ The simulation creates <strong>conditions</strong> for formation

<em>It simulates an environment favorable for that molecule!</em>`,
                target: null,
                fixedPosition: 'LEFT_PANEL_BOTTOM'
            },
            // (Step 15/31)
            {
                id: 'intentions-attract',
                title: 'Intention Zone: Attraction',
                content: `Inside an intention zone:

‚úÖ <strong>Needed atoms</strong> are attracted inward
‚úÖ <strong>Matching unstable molecules</strong> can transform
‚úÖ Atoms bond naturally when conditions are right

<em>Like a magnet for the right ingredients!</em>`,
                target: null,
                fixedPosition: 'LEFT_PANEL_BOTTOM'
            },
            // (Step 16/31)
            {
                id: 'intentions-repel',
                title: 'Intention Zone: Repulsion',
                content: `The zone also pushes away interference:

‚ùå <strong>Unrelated free atoms</strong> are pushed out
‚ùå <strong>Stable molecules</strong> that can't contribute are repelled
‚ö° <strong>Unstable molecules</strong> may break apart to free useful atoms

<em>It clears the way for your target molecule!</em>`,
                target: null,
                fixedPosition: 'LEFT_PANEL_BOTTOM'
            },
            // (Step 17/31)
            {
                id: 'intentions-complete',
                title: 'Intention Zone: Completion',
                content: `When your target molecule forms:

‚ú® The intention zone <strong>completes</strong> and disappears
‚ú® The molecule is now <strong>stable</strong>
‚ú® It gets added to your <strong>Catalogue</strong>!

<em>The simulation creates conditions, chemistry does the rest!</em>`,
                target: null,
                fixedPosition: 'LEFT_PANEL_BOTTOM'
            },

            // === TOOLS === (Step 18/31)
            {
                id: 'tools-overview',
                title: 'The Three Tools',
                content: `Three ways to interact:

‚Ä¢ <strong>üîç Select</strong> ‚Äì Click to inspect entities
‚Ä¢ <strong>‚ûï Place</strong> ‚Äì Add atoms or set intentions
‚Ä¢ <strong>üóëÔ∏è Delete</strong> ‚Äì Remove entities

<em>You've already used Select. Place is active when you pick from palette.</em>`,
                target: '#selectTool',
                fixedPosition: 'RIGHT_OF_LEFT_PANEL'
            },
            // (Step 19/31)
            {
                id: 'right-click-tip',
                title: 'Pro Tip: Right-Click!',
                content: `<strong>Right-click on canvas</strong> anytime to:

‚Ä¢ Cancel current placement mode
‚Ä¢ Switch back to <strong>Select</strong> tool
‚Ä¢ Stop any ongoing action

<em>Super useful! Try it now.</em>`,
                target: null,
                fixedPosition: 'LEFT_PANEL_BOTTOM'
            },

            // === CATALOGUE === (Step 20/31)
            {
                id: 'catalogue-intro',
                title: 'The Catalogue Tab',
                content: `The <strong>Catalogue</strong> in the right panel stores discoveries:

‚Ä¢ Every <strong>stable molecule</strong> you create is saved
‚Ä¢ Click to see molecule details
‚Ä¢ Use it as a reference for what you've made!

<em>Click the Catalogue tab to explore!</em>`,
                target: '[data-tab="catalogue"]',
                fixedPosition: 'LEFT_OF_RIGHT_PANEL'
            },
            // (Step 21/31)
            {
                id: 'catalogue-to-palette',
                title: 'Catalogue & Palette Sync',
                content: `<strong>How it works:</strong>

‚Ä¢ Create a stable molecule, and it's added to the Catalogue
‚Ä¢ Switch to Level 2, and the Palette shows catalogued molecules
‚Ä¢ The palette updates when you enter Level 2

<em>Your discoveries become placeable blueprints!</em>`,
                target: '#levelButtons',
                fixedPosition: 'BELOW_HEADER'
            },

            // === SIMULATION CONTROLS === (Step 22/31)
            {
                id: 'sim-controls',
                title: 'Simulation Controls',
                content: `Master time itself:

‚Ä¢ <strong>‚ñ∂Ô∏è/‚è∏Ô∏è</strong> ‚Äì Play or Pause
‚Ä¢ <strong>‚è≠Ô∏è</strong> ‚Äì Step one frame (when paused)
‚Ä¢ <strong>Slider</strong> ‚Äì Speed control

<em>Pause to place atoms precisely!</em>`,
                target: '.sim-controls',
                fixedPosition: 'BELOW_PLAY_BUTTON'
            },
            // (Step 23/31)
            {
                id: 'canvas-nav',
                title: 'Canvas Navigation',
                content: `Move around your simulation:

‚Ä¢ <strong>Scroll wheel</strong> ‚Äì Zoom in/out
‚Ä¢ <strong>Right-click + drag</strong> ‚Äì Pan around

Works at any view level!

<em>Try zooming in on your molecules!</em>`,
                target: null,
                fixedPosition: 'LEFT_PANEL_BOTTOM'
            },
            
            // === ATOM SPAWNER === (Step 24/31)
            {
                id: 'spawner-intro',
                title: 'The Atom Spawner',
                content: `For automated experiments, use the <strong>Atom Spawner</strong>!

It continuously generates atoms in a zone.

<strong>‚ö†Ô∏è Configure it BEFORE activating!</strong>

<em>Right-click the ‚öõÔ∏è button to open settings.</em>`,
                target: '#spawnerBtn',
                fixedPosition: 'BELOW_PLAY_BUTTON'
            },
            // (Step 25/31)
            {
                id: 'spawner-config',
                title: 'Configuring the Spawner',
                content: `<strong>Right-click ‚öõÔ∏è</strong> to configure:

‚Ä¢ <strong>Atom types</strong> ‚Äì Select only what you need!
‚Ä¢ <strong>Spawn rate</strong> ‚Äì Ticks between spawns
‚Ä¢ <strong>Zone size</strong> ‚Äì Drag edges on canvas

<em>Pro tip: Only enable atoms your target molecule needs!</em>`,
                target: '#spawnerBtn',
                fixedPosition: 'BELOW_PLAY_BUTTON'
            },
            // (Step 26/31)
            {
                id: 'spawner-workflow',
                title: 'Spawner + Intentions Workflow',
                content: `<strong>Best workflow for complex molecules:</strong>

1. <strong>Pause</strong> the simulation
2. In Level 2, click a molecule blueprint (creates intention)
3. <strong>Configure spawner</strong> with needed atoms only
4. <strong>Drag spawner zone</strong> over the intention
5. <strong>Activate spawner</strong> (click ‚öõÔ∏è)
6. <strong>Play</strong> and watch chemistry happen!`,
                target: null,
                fixedPosition: 'CENTER'
            },
            // (Step 27/31)
            {
                id: 'spawner-warning',
                title: '‚ö†Ô∏è Remember to Turn Off Spawner!',
                content: `<strong>Always deactivate when done!</strong>

Leaving it on causes:
‚Ä¢ Too many atoms = slow simulation
‚Ä¢ Unwanted reactions everywhere
‚Ä¢ Chaos! üòÖ

<em>Click ‚öõÔ∏è again to turn OFF when finished.</em>`,
                target: '#spawnerBtn',
                fixedPosition: 'BELOW_PLAY_BUTTON'
            },

            // === POLYMERS & HIGHER LEVELS === (Step 28/31)
            {
                id: 'polymers-intro',
                title: 'Beyond Molecules: Polymers',
                content: `<strong>Level 3</strong> shows <strong>Polymers</strong> ‚Äì chains of molecules!

‚Ä¢ Polymers form when molecules link together
‚Ä¢ Examples: proteins, carbohydrates, nucleic acids
‚Ä¢ They're the building blocks of life!

In the <strong>polymer palette</strong> you'll find polymer blueprints that create <strong>polymer intention zones</strong>, just like molecule intentions!

<em>Build enough molecules and watch them chain up!</em>`,
                target: '#levelButtons',
                fixedPosition: 'BELOW_HEADER'
            },
            // (Step 29/31) - Merged from old 29+30
            {
                id: 'higher-levels',
                title: 'Higher Levels of Complexity',
                content: `The simulation models life at many scales:

‚Ä¢ <strong>Level 4</strong> ‚Äì Cells (membranes, organelles)
‚Ä¢ <strong>Level 5</strong> ‚Äì Organisms
‚Ä¢ <strong>Level 6</strong> ‚Äì Populations

<em>Each level has its own emergent behaviors!</em>

<strong>Note:</strong> The cell system is still being developed! üöß
Current features include basic cell membranes and prokaryote-like structures.`,
                target: '#levelButtons',
                fixedPosition: 'BELOW_HEADER'
            },

            // === SMART UI === (Step 30/31)
            {
                id: 'smart-ui',
                title: 'Smart Interface Shortcuts',
                content: `The UI adapts to help you:

‚Ä¢ <strong>Click atom in palette</strong>
  Switches to Level 1, activates Place tool

‚Ä¢ <strong>Click molecule blueprint</strong>
  Switches to Level 2, activates Place tool

‚Ä¢ <strong>Right-click on canvas</strong>
  Cancels action, returns to Select tool

‚Ä¢ <strong>Click on atom/molecule/polymer</strong>
  Opens Inspector tab automatically, changes view level`,
                target: null,
                fixedPosition: 'CENTER'
            },
            
            // === COMPLETION === (Step 31/31)
            {
                id: 'complete',
                title: 'You\'re Ready! üéâ',
                content: `<strong>Molecules to try:</strong>

‚Ä¢ <strong>CH‚ÇÑ</strong> (methane): 1 C + 4 H
‚Ä¢ <strong>CO‚ÇÇ</strong>: 1 C + 2 O
‚Ä¢ <strong>NH‚ÇÉ</strong> (ammonia): 1 N + 3 H
‚Ä¢ <strong>C‚ÇÇH‚ÇÜ</strong> (ethane): 2 C + 6 H

Click <strong>‚ùì</strong> anytime to revisit this tutorial!`,
                target: null,
                fixedPosition: 'CENTER'
            }
        ];

        this._createElements();
        this._checkFirstVisit();
    }

    /**
     * Check if this is the user's first visit
     */
    _checkFirstVisit() {
        const hasSeenTutorial = localStorage.getItem('bcs-tutorial-seen');
        if (!hasSeenTutorial) {
            setTimeout(() => {
                this._showTutorialHint();
            }, 1500);
        }
    }

    /**
     * Show a subtle hint that tutorial is available
     */
    _showTutorialHint() {
        const hint = document.getElementById('tutorialHint');
        if (hint) {
            hint.classList.add('visible');
            setTimeout(() => {
                hint.classList.remove('visible');
            }, 10000);
        }
    }

    /**
     * Create DOM elements for tutorial (non-blocking - no overlay)
     */
    _createElements() {
        // Highlight element (pointer-events: none so it doesn't block)
        this.highlightEl = document.createElement('div');
        this.highlightEl.className = 'tutorial-highlight';
        this.highlightEl.style.display = 'none';
        document.body.appendChild(this.highlightEl);

        // Balloon
        this.balloon = document.createElement('div');
        this.balloon.className = 'tutorial-balloon';
        this.balloon.style.display = 'none';
        this.balloon.innerHTML = `
            <div class="tutorial-balloon-header">
                <span class="tutorial-step-indicator"></span>
                <button class="tutorial-close" title="Close tutorial (Esc)">&times;</button>
            </div>
            <h3 class="tutorial-title"></h3>
            <div class="tutorial-content"></div>
            <div class="tutorial-nav">
                <button class="tutorial-btn tutorial-prev">‚Üê Back</button>
                <button class="tutorial-btn tutorial-next">Next ‚Üí</button>
            </div>
        `;
        document.body.appendChild(this.balloon);

        // Bind events
        this.balloon.querySelector('.tutorial-close').addEventListener('click', () => this.end());
        this.balloon.querySelector('.tutorial-prev').addEventListener('click', () => this.prev());
        this.balloon.querySelector('.tutorial-next').addEventListener('click', () => this.next());

        // Keyboard navigation
        this._keyHandler = (e) => {
            if (!this.active) return;
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            
            if (e.key === 'Escape') {
                e.preventDefault();
                this.end();
            }
            if (e.key === 'ArrowRight' || e.key === 'Enter') {
                e.preventDefault();
                this.next();
            }
            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                this.prev();
            }
        };
        document.addEventListener('keydown', this._keyHandler);
    }

    /**
     * Start the tutorial
     */
    start() {
        this.active = true;
        this.currentStep = 0;
        this.balloon.style.display = 'block';
        
        localStorage.setItem('bcs-tutorial-seen', 'true');
        
        const hint = document.getElementById('tutorialHint');
        if (hint) hint.classList.remove('visible');

        const btn = document.getElementById('tutorialBtn');
        if (btn) btn.classList.add('active');

        this._showStep();
    }

    /**
     * End the tutorial
     */
    end() {
        this.active = false;
        this.balloon.style.display = 'none';
        this.highlightEl.style.display = 'none';
        
        const btn = document.getElementById('tutorialBtn');
        if (btn) btn.classList.remove('active');
    }

    /**
     * Go to next step
     */
    next() {
        if (this.currentStep < this.steps.length - 1) {
            this.currentStep++;
            this._showStep();
        } else {
            this.end();
        }
    }

    /**
     * Go to previous step
     */
    prev() {
        if (this.currentStep > 0) {
            this.currentStep--;
            this._showStep();
        }
    }

    /**
     * Show current step
     */
    _showStep() {
        const step = this.steps[this.currentStep];
        
        // Update content
        this.balloon.querySelector('.tutorial-step-indicator').textContent = 
            `${this.currentStep + 1} / ${this.steps.length}`;
        this.balloon.querySelector('.tutorial-title').textContent = step.title;
        this.balloon.querySelector('.tutorial-content').innerHTML = step.content;

        // Update nav buttons
        const prevBtn = this.balloon.querySelector('.tutorial-prev');
        const nextBtn = this.balloon.querySelector('.tutorial-next');
        
        prevBtn.style.visibility = this.currentStep === 0 ? 'hidden' : 'visible';
        nextBtn.textContent = this.currentStep === this.steps.length - 1 ? 'Finish ‚úì' : 'Next ‚Üí';

        // Position balloon and highlight
        this._positionBalloon(step);
    }

    /**
     * Position the balloon using FIXED positions (independent of UI state)
     */
    _positionBalloon(step) {
        const balloon = this.balloon;
        const highlight = this.highlightEl;
        
        // Reset all position styles
        balloon.style.top = '';
        balloon.style.left = '';
        balloon.style.right = '';
        balloon.style.bottom = '';
        balloon.style.transform = '';
        balloon.className = 'tutorial-balloon';

        // Handle target highlighting (if any)
        if (step.target) {
            const targetEl = document.querySelector(step.target);
            if (targetEl) {
                const rect = targetEl.getBoundingClientRect();
                const padding = 8;
                highlight.style.display = 'block';
                highlight.style.top = `${rect.top - padding}px`;
                highlight.style.left = `${rect.left - padding}px`;
                highlight.style.width = `${rect.width + padding * 2}px`;
                highlight.style.height = `${rect.height + padding * 2}px`;
            } else {
                highlight.style.display = 'none';
            }
        } else {
            highlight.style.display = 'none';
        }

        // Apply FIXED position (independent of target/UI state)
        const pos = this.POSITIONS[step.fixedPosition] || this.POSITIONS.CENTER;
        
        if (pos.center) {
            balloon.classList.add('position-center');
            return;
        }

        if (pos.top !== undefined) balloon.style.top = `${pos.top}px`;
        if (pos.bottom !== undefined) balloon.style.bottom = `${pos.bottom}px`;
        if (pos.left !== undefined) balloon.style.left = `${pos.left}px`;
        if (pos.right !== undefined) balloon.style.right = `${pos.right}px`;
    }

    /**
     * Reset tutorial state (for testing)
     */
    reset() {
        localStorage.removeItem('bcs-tutorial-seen');
        this.currentStep = 0;
        console.log('Tutorial reset - refresh page to see first-visit prompt');
    }
}

// Export to global scope
window.Tutorial = Tutorial;


// ==== src/main.js ====
/**
 * Main Application Entry Point
 * Initializes and connects all components
 */

class App {
    constructor() {
        // Core components
        this.environment = null;
        this.simulation = null;
        this.catalogue = null;
        this.viewer = null;
        this.controls = null;
        this.catalogueUI = null;
        this.atomSpawner = null;
        this.tutorial = null;

        // State
        this.initialized = false;
    }

    /**
     * Initialize the application
     */
    async init() {
        console.log('üß¨ Initializing Cell Simulator...');

        // Create environment
        this.environment = new Environment(2000, 2000);

        // Create simulation
        this.simulation = new Simulation(this.environment);

        // Create and initialize catalogue
        this.catalogue = new Catalogue();
        await this.catalogue.init();

        // Create viewer
        const canvas = document.getElementById('simCanvas');
        this.viewer = new Viewer(canvas, this.environment);
        this.viewer.centerCamera();

        // Create controls
        this.controls = new Controls(this.viewer, this.simulation, this.catalogue);

        // Create catalogue UI
        this.catalogueUI = new CatalogueUI(this.catalogue, this.controls);

        // Create atom spawner
        this.atomSpawner = new AtomSpawner(this.environment);

        // Set up simulation callbacks
        this.simulation.onUpdate = () => {
            this.viewer.render();
            this._updateStats();
        };

        this.simulation.onTick = (tick) => {
            // Update atom spawner
            if (this.atomSpawner) {
                this.atomSpawner.update(1 / 60);
            }

            // Auto-discover stable molecules every 60 ticks
            if (tick % 60 === 0) {
                this.catalogue.autoDiscover(this.environment.getAllMolecules());
                this.catalogueUI.render();
            }
        };

        // Update stats when viewer renders (for when paused)
        this.viewer.onRender = () => {
            this._updateStats();
        };

        // Set up UI
        this._setupUI();

        // Initialize palette for level 0
        this._updatePaletteForLevel(0);

        // Initial render
        this.viewer.render();

        // Add some initial atoms for demo
        this._addDemoAtoms();

        // Initialize tutorial system
        this.tutorial = new Tutorial(this);
        this._setupTutorialUI();

        this.initialized = true;
        console.log('‚úÖ Cell Simulator initialized!');
    }

    /**
     * Set up UI event handlers
     */
    _setupUI() {
        // Play/Pause button
        const playPauseBtn = document.getElementById('playPauseBtn');
        playPauseBtn?.addEventListener('click', () => {
            this.simulation.toggle();
            playPauseBtn.textContent = this.simulation.running ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Play';
        });

        // Step button
        const stepBtn = document.getElementById('stepBtn');
        stepBtn?.addEventListener('click', () => {
            this.simulation.step();
            this.viewer.render();
            this._updateStats();
        });

        // Speed slider
        const speedSlider = document.getElementById('speedSlider');
        speedSlider?.addEventListener('input', (e) => {
            const speed = e.target.value / 50;  // 0.02 to 2.0
            this.simulation.setSpeed(speed);
        });

        // Spawner button and modal
        this._setupSpawnerUI();

        // Level buttons
        const levelButtons = document.getElementById('levelButtons');
        levelButtons?.addEventListener('click', (e) => {
            const btn = e.target.closest('.level-btn');
            if (btn) {
                const level = parseInt(btn.dataset.level);
                console.log('Setting level to:', level);
                this.viewer.setLevel(level);

                // Update button states
                document.querySelectorAll('.level-btn').forEach((b, i) => {
                    b.classList.toggle('active', i === level);
                });

                // Update palette for this level
                this._updatePaletteForLevel(level);

                // Switch to select mode when changing levels
                this.controls.setTool('select');

                // Force re-render to show the new level
                this.viewer.render();
            }
        });

        // Tool buttons
        document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
            btn.addEventListener('click', () => {
                const tool = btn.dataset.tool;
                this.controls.setTool(tool);

                // Update button states
                document.querySelectorAll('.tool-btn[data-tool]').forEach(b => {
                    b.classList.toggle('active', b.dataset.tool === tool);
                });
            });
        });

        // Atom palette
        this._populateAtomPalette();

        // Tab buttons
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const tab = btn.dataset.tab;

                // Update tab buttons
                document.querySelectorAll('.tab-btn').forEach(b => {
                    b.classList.toggle('active', b.dataset.tab === tab);
                });

                // Update tab content
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.toggle('active', content.id === tab + 'Tab');
                });

                // Switch to select mode when clicking inspector tab
                if (tab === 'inspector') {
                    this.controls.setTool('select');
                }
            });
        });
    }

    /**
     * Set up tutorial button handler
     */
    _setupTutorialUI() {
        const tutorialBtn = document.getElementById('tutorialBtn');
        if (tutorialBtn) {
            tutorialBtn.addEventListener('click', () => {
                if (this.tutorial.active) {
                    this.tutorial.end();
                    tutorialBtn.classList.remove('active');
                } else {
                    this.tutorial.start();
                    tutorialBtn.classList.add('active');
                }
            });
        }
    }

    /**
     * Set the current level (called from catalogue UI)
     * @param {number} level - The level to switch to
     */
    setLevel(level) {
        console.log('App.setLevel called with level:', level);
        this.viewer.setLevel(level);

        // Update button states
        document.querySelectorAll('.level-btn').forEach((b, i) => {
            b.classList.toggle('active', i === level);
        });

        // Update palette for this level
        this._updatePaletteForLevel(level);

        // Force re-render to show the new level
        this.viewer.render();
    }

    /**
     * Populate the atom palette with available elements
     */
    _populateAtomPalette() {
        const palette = document.getElementById('entityPalette');
        if (!palette) return;

        // Essential elements - synced with catalogue-ui.js
        const elements = ['H', 'C', 'N', 'O', 'P', 'S', 'Cl', 'Na', 'K', 'Ca', 'Fe'];

        palette.innerHTML = elements.map(symbol => {
            const element = getElement(symbol);
            return `
                <button class="atom-btn ${symbol === 'C' ? 'selected' : ''}" 
                        data-symbol="${symbol}"
                        style="color: ${element.color}; border-color: ${element.color}40;">
                    <span class="symbol">${symbol}</span>
                    <span class="number">${element.number}</span>
                </button>
            `;
        }).join('');

        // Add click handlers
        palette.querySelectorAll('.atom-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const symbol = btn.dataset.symbol;
                this.controls.setSelectedElement(symbol);

                // Update selection state
                palette.querySelectorAll('.atom-btn').forEach(b => {
                    b.classList.toggle('selected', b.dataset.symbol === symbol);
                });

                // Clear blueprint selection
                this.controls.selectedBlueprint = null;
            });
        });
    }

    /**
     * Update the entity palette based on current level
     */
    _updatePaletteForLevel(level) {
        console.log('_updatePaletteForLevel called with level:', level);
        const palette = document.getElementById('entityPalette');
        const paletteTitle = document.getElementById('paletteTitle');
        if (!palette) {
            console.log('ERROR: palette element not found');
            return;
        }
        if (!paletteTitle) {
            console.log('ERROR: paletteTitle element not found');
        }

        // Level 0: Atoms
        if (level === 0) {
            console.log('Rendering atoms palette');
            paletteTitle.textContent = 'Place Atoms';
            this._renderAtomPalette(palette);
        }
        // Level 1: Molecules from catalogue
        else if (level === 1) {
            console.log('Rendering molecules palette');
            paletteTitle.textContent = 'Place Molecules';
            this._renderMoleculePalette(palette);
        }
        // Level 2: Polymers
        else if (level === 2) {
            console.log('Rendering polymers palette');
            paletteTitle.textContent = 'Place Polymers';
            this._renderPolymerPalette(palette);
        }
        // Level 3+: Cells
        else {
            console.log('Rendering cells palette');
            paletteTitle.textContent = 'Place Cells';
            this._renderCellPalette(palette);
        }
    }

    /**
     * Render atom palette
     */
    _renderAtomPalette(palette) {
        // Synced with catalogue-ui.js commonAtoms
        const elements = ['H', 'C', 'N', 'O', 'P', 'S', 'Cl', 'Na', 'K', 'Ca', 'Fe'];

        palette.innerHTML = elements.map(symbol => {
            const element = getElement(symbol);
            return `
                <button class="palette-btn atom-btn ${symbol === 'C' ? 'selected' : ''}" 
                        data-symbol="${symbol}"
                        style="color: ${element.color}; border-color: ${element.color}40;">
                    <span class="symbol">${symbol}</span>
                    <span class="number">${element.number}</span>
                </button>
            `;
        }).join('');

        palette.querySelectorAll('.atom-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const symbol = btn.dataset.symbol;
                this.controls.setSelectedElement(symbol);
                this.controls.selectedBlueprint = null;
                palette.querySelectorAll('.palette-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');

                // Auto-select Place tool when selecting an atom
                this.controls.setTool('place');
            });
        });
    }

    /**
     * Render molecule palette from catalogue
     */
    _renderMoleculePalette(palette) {
        try {
            console.log('_renderMoleculePalette called, catalogue exists:', !!this.catalogue);
            if (!this.catalogue) {
                palette.innerHTML = '<p class="empty-state">Catalogue not initialized</p>';
                return;
            }
            // Only show stable molecules with 2+ atoms, 1+ bonds, and all valences satisfied
            const allBlueprints = this.catalogue.getAllMolecules();

            // Helper: calculate if blueprint is truly stable from its data
            const isBlueprintStable = (bp) => {
                if (!bp.atomData || bp.atomData.length < 2) return false;
                if (!bp.bondData || bp.bondData.length < 1) return false;

                // Calculate valence usage for each atom
                const atomValences = {};
                for (const atom of bp.atomData) {
                    const element = getElement(atom.symbol);
                    if (!element) return false;
                    atomValences[atom.index] = { max: element.valence, used: 0 };
                }

                // Count bonds for each atom
                for (const bond of bp.bondData) {
                    const order = bond.order || 1;
                    if (atomValences[bond.atom1Index]) {
                        atomValences[bond.atom1Index].used += order;
                    }
                    if (atomValences[bond.atom2Index]) {
                        atomValences[bond.atom2Index].used += order;
                    }
                }

                // Check all atoms have filled valence
                for (const idx in atomValences) {
                    const v = atomValences[idx];
                    if (v.used !== v.max) return false;
                }
                return true;
            };

            const blueprints = allBlueprints.filter(bp => isBlueprintStable(bp));
            console.log('Rendering molecule palette, blueprints:', blueprints.length, 'of', allBlueprints.length, 'total');

            if (blueprints.length === 0) {
                palette.innerHTML = '<p class="empty-state">No stable molecules discovered yet. Create stable molecules at Level 1!</p>';
                return;
            }

            // Helper to escape fingerprint for HTML attributes
            const escapeAttr = (str) => str.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
            const unescapeAttr = (str) => str.replace(/&quot;/g, '"').replace(/&#39;/g, "'");

            palette.innerHTML = blueprints.map(bp => `
                <button class="palette-btn molecule-btn" data-fingerprint="${escapeAttr(bp.fingerprint)}">
                    <span class="formula">${bp.name || bp.formula}</span>
                    <span class="info">${bp.formula} &bull; ${bp.atomData.length} atoms</span>
                </button>
            `).join('');

            palette.querySelectorAll('.molecule-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const rawFingerprint = btn.dataset.fingerprint;
                    const fingerprint = unescapeAttr(rawFingerprint);
                    console.log('Molecule button clicked, fingerprint:', fingerprint);
                    const bp = this.catalogue.getMolecule(fingerprint);
                    console.log('Blueprint found:', bp ? bp.formula : 'NULL');
                    if (bp) {
                        this.controls.selectedBlueprint = bp;
                        this.controls.setTool('place');
                        palette.querySelectorAll('.palette-btn').forEach(b => b.classList.remove('selected'));
                        btn.classList.add('selected');

                        // Show blueprint preview in inspector
                        if (this.catalogueUI && this.catalogueUI._showBlueprintInspector) {
                            this.catalogueUI._showBlueprintInspector(bp);
                        }
                    } else {
                        console.error('Blueprint not found for fingerprint:', fingerprint);
                    }
                });
            });
        } catch (e) {
            console.error('Error in _renderMoleculePalette:', e);
            palette.innerHTML = '<p class="empty-state">Error loading molecules</p>';
        }
    }

    /**
     * Render polymer palette
     */
    _renderPolymerPalette(palette) {
        try {
            // Get polymer templates from catalogue
            const polymerTemplates = this.catalogue ? this.catalogue.getAllPolymers() : [];
            // Get existing polymers from environment
            const existingPolymers = this.environment.getAllProteins ? this.environment.getAllProteins() : [];

            if (polymerTemplates.length === 0 && existingPolymers.length === 0) {
                palette.innerHTML = '<p class="empty-state">No polymer templates available.</p>';
                return;
            }

            // Helper to escape fingerprint for HTML attributes
            const escapeAttr = (str) => str.replace(/"/g, '&quot;').replace(/'/g, '&#39;');

            let html = '';

            // Show essential polymer templates first
            const essentialTemplates = polymerTemplates.filter(p => p.essential);
            const otherTemplates = polymerTemplates.filter(p => !p.essential);

            if (essentialTemplates.length > 0) {
                html += '<p class="palette-subtitle">Essential for Cells</p>';
                html += essentialTemplates.map(template => {
                    const colors = PolymerColors[template.type] || PolymerColors.generic;
                    return `
                        <button class="palette-btn polymer-template-btn" data-fingerprint="${escapeAttr(template.fingerprint)}" style="border-color: ${colors.primary};">
                            <span class="type" style="color: ${colors.primary};">${template.name}</span>
                            <span class="info">${template.type} &bull; ${template.minMolecules} mols</span>
                        </button>
                    `;
                }).join('');
            }

            if (otherTemplates.length > 0) {
                html += '<p class="palette-subtitle">Other Polymers</p>';
                html += otherTemplates.map(template => {
                    const colors = PolymerColors[template.type] || PolymerColors.generic;
                    return `
                        <button class="palette-btn polymer-template-btn" data-fingerprint="${escapeAttr(template.fingerprint)}" style="border-color: ${colors.primary};">
                            <span class="type" style="color: ${colors.primary};">${template.name}</span>
                            <span class="info">${template.type} &bull; ${template.minMolecules} mols</span>
                        </button>
                    `;
                }).join('');
            }

            // Show existing polymers in environment
            if (existingPolymers.length > 0) {
                html += '<p class="palette-subtitle">In Environment</p>';
                html += existingPolymers.map(poly => {
                    const label = poly.getLabel ? poly.getLabel() : 'Polymer';
                    const colors = poly.getColor ? poly.getColor() : { primary: '#8b5cf6' };
                    return `
                        <button class="palette-btn polymer-existing-btn" data-id="${poly.id}" style="border-color: ${colors.primary};">
                            <span class="type" style="color: ${colors.primary};">${label}</span>
                            <span class="info">${poly.molecules.length} mols</span>
                        </button>
                    `;
                }).join('');
            }

            palette.innerHTML = html;

            // Add click handlers for templates
            const unescapeAttr = (str) => str.replace(/&quot;/g, '"').replace(/&#39;/g, "'");

            palette.querySelectorAll('.polymer-template-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const fingerprint = unescapeAttr(btn.dataset.fingerprint);
                    const template = this.catalogue.getPolymer(fingerprint);
                    console.log('Polymer template selected:', template?.name);
                    if (template) {
                        this.controls.selectedPolymerTemplate = template;
                        this.controls.selectedBlueprint = null;  // Clear molecule selection
                        this.controls.setTool('place');
                        palette.querySelectorAll('.palette-btn').forEach(b => b.classList.remove('selected'));
                        btn.classList.add('selected');
                        // Show polymer template data in inspector
                        if (this.controls.updateInspectorWithPolymerTemplate) {
                            this.controls.updateInspectorWithPolymerTemplate(template);
                        }
                    }
                });
            });

        } catch (e) {
            console.error('Error in _renderPolymerPalette:', e);
            palette.innerHTML = '<p class="empty-state">Error loading polymers</p>';
        }
    }

    /**
     * Render cell/prokaryote palette
     */
    _renderCellPalette(palette) {
        palette.innerHTML = `
            <button class="palette-btn cell-btn selected" data-type="prokaryote">
                <span class="symbol">ü¶†</span>
                <span class="info">New Prokaryote</span>
            </button>
            <p class="palette-hint">Click canvas to place a chemistry-based prokaryote</p>
        `;

        palette.querySelector('.cell-btn')?.addEventListener('click', () => {
            this.controls.setTool('place');
        });
    }

    /**
     * Update statistics display
     */
    _updateStats() {
        const stats = this.simulation.getStats();

        document.getElementById('atomCount').textContent = `Atoms: ${stats.atomCount}`;
        document.getElementById('moleculeCount').textContent = `Mol: ${stats.moleculeCount}`;
        document.getElementById('proteinCount').textContent = `Poly: ${stats.proteinCount || 0}`;
        document.getElementById('cellCount').textContent = `Cells: ${stats.cellCount}`;
        document.getElementById('tickCounter').textContent = `Tick: ${stats.tick}`;
        document.getElementById('fpsCounter').textContent = `FPS: ${stats.fps}`;
    }

    /**
     * Add demo atoms for testing
     */
    _addDemoAtoms() {
        const centerX = this.environment.width / 2;
        const centerY = this.environment.height / 2;

        // Create a water molecule (H2O) manually
        const oxygen = new Atom('O', centerX, centerY);
        const hydrogen1 = new Atom('H', centerX - 30, centerY - 20);
        const hydrogen2 = new Atom('H', centerX + 30, centerY - 20);

        this.environment.addAtom(oxygen);
        this.environment.addAtom(hydrogen1);
        this.environment.addAtom(hydrogen2);

        // Create bonds
        const bond1 = new Bond(oxygen, hydrogen1, 1);
        const bond2 = new Bond(oxygen, hydrogen2, 1);

        this.environment.addBond(bond1);
        this.environment.addBond(bond2);

        // Add some free atoms
        for (let i = 0; i < 10; i++) {
            const symbol = Utils.randomChoice(['C', 'H', 'O', 'N']);
            const x = centerX + Utils.random(-200, 200);
            const y = centerY + Utils.random(-200, 200);
            const atom = new Atom(symbol, x, y);
            this.environment.addAtom(atom);
        }

        // Update molecules
        this.environment.updateMolecules();
    }

    /**
     * Register currently selected molecule to catalogue
     */
    registerMolecule() {
        if (this.viewer.selectedMolecule && this.viewer.selectedMolecule.isStable()) {
            const name = prompt('Enter a name for this molecule:', this.viewer.selectedMolecule.formula);
            if (name) {
                this.catalogue.registerMolecule(this.viewer.selectedMolecule, name);
                this.catalogueUI.render();
            }
        }
    }

    /**
     * Delete an intention by ID
     * @param {string} intentionId - The intention ID to delete
     */
    deleteIntention(intentionId) {
        this.environment.removeIntention(intentionId);
        this.viewer.selectedIntention = null;
        this.viewer.render();

        // Clear inspector
        const content = document.getElementById('inspectorContent');
        if (content) {
            content.innerHTML = '<p class="empty-state">Intention deleted.</p>';
        }
    }

    /**
     * Export simulation state
     */
    exportState() {
        const state = {
            environment: this.environment.serialize(),
            catalogue: this.catalogue.export()
        };

        const blob = new Blob([JSON.stringify(state, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = 'cell-simulator-state.json';
        a.click();

        URL.revokeObjectURL(url);
    }

    /**
     * Import simulation state
     */
    importState(json) {
        try {
            const state = JSON.parse(json);

            if (state.environment) {
                this.environment.deserialize(state.environment);
            }
            if (state.catalogue) {
                this.catalogue.import(state.catalogue);
            }

            this.viewer.render();
            this._updateStats();
            this.catalogueUI.render();

            console.log('State imported successfully');
        } catch (e) {
            console.error('Failed to import state:', e);
        }
    }

    /**
     * Set up atom spawner UI (button and modal)
     */
    _setupSpawnerUI() {
        const spawnerBtn = document.getElementById('spawnerBtn');
        const spawnerModal = document.getElementById('spawnerModal');
        const closeModalBtn = document.getElementById('closeSpawnerModal');
        const applyBtn = document.getElementById('applySpawnerConfig');
        const atomPoolSelector = document.getElementById('atomPoolSelector');

        if (!spawnerBtn || !spawnerModal) return;

        // Available atoms for spawning
        const availableAtoms = ['H', 'C', 'N', 'O', 'P', 'S', 'Cl', 'Na', 'K', 'Ca', 'Fe'];

        // Populate atom pool selector
        atomPoolSelector.innerHTML = availableAtoms.map(symbol => {
            const element = getElement(symbol);
            const isSelected = this.atomSpawner.atomPool.includes(symbol);
            return `
                <button class="atom-pool-btn ${isSelected ? 'selected' : ''}" 
                        data-symbol="${symbol}"
                        style="color: ${element.color}; border-color: ${element.color}40;">
                    ${symbol}
                </button>
            `;
        }).join('');

        // Toggle atom in pool on click
        atomPoolSelector.querySelectorAll('.atom-pool-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                btn.classList.toggle('selected');
            });
        });

        // Left-click: toggle spawner on/off
        spawnerBtn.addEventListener('click', (e) => {
            if (e.shiftKey) {
                // Shift+click opens config modal
                this._openSpawnerModal();
            } else {
                // Regular click toggles spawner
                const active = this.atomSpawner.toggle();
                spawnerBtn.classList.toggle('active', active);
                this.viewer.render();
            }
        });

        // Right-click: open config modal
        spawnerBtn.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            this._openSpawnerModal();
        });

        // Close modal
        closeModalBtn?.addEventListener('click', () => {
            spawnerModal.style.display = 'none';
        });

        // Click backdrop to close
        spawnerModal.querySelector('.modal-backdrop')?.addEventListener('click', () => {
            spawnerModal.style.display = 'none';
        });

        // Apply configuration
        applyBtn?.addEventListener('click', () => {
            this._applySpawnerConfig();
            spawnerModal.style.display = 'none';
        });
    }

    /**
     * Open spawner configuration modal
     */
    _openSpawnerModal() {
        const modal = document.getElementById('spawnerModal');
        const intervalInput = document.getElementById('spawnInterval');
        const widthInput = document.getElementById('zoneWidth');
        const heightInput = document.getElementById('zoneHeight');
        const atomPoolSelector = document.getElementById('atomPoolSelector');

        if (!modal) return;

        // Update inputs with current values
        if (intervalInput) intervalInput.value = this.atomSpawner.tickInterval;
        if (widthInput) widthInput.value = Math.round(this.atomSpawner.zone.width);
        if (heightInput) heightInput.value = Math.round(this.atomSpawner.zone.height);

        // Update atom pool selection
        atomPoolSelector?.querySelectorAll('.atom-pool-btn').forEach(btn => {
            const symbol = btn.dataset.symbol;
            btn.classList.toggle('selected', this.atomSpawner.atomPool.includes(symbol));
        });

        modal.style.display = 'flex';
    }

    /**
     * Apply spawner configuration from modal
     */
    _applySpawnerConfig() {
        const intervalInput = document.getElementById('spawnInterval');
        const widthInput = document.getElementById('zoneWidth');
        const heightInput = document.getElementById('zoneHeight');
        const atomPoolSelector = document.getElementById('atomPoolSelector');

        // Get selected atoms
        const selectedAtoms = [];
        atomPoolSelector?.querySelectorAll('.atom-pool-btn.selected').forEach(btn => {
            selectedAtoms.push(btn.dataset.symbol);
        });

        // Apply tick interval
        if (intervalInput) {
            this.atomSpawner.setTickInterval(parseInt(intervalInput.value) || 60);
        }

        // Apply atom pool
        if (selectedAtoms.length > 0) {
            this.atomSpawner.setAtomPool(selectedAtoms);
        }

        // Apply zone size (centered on current zone center)
        if (widthInput && heightInput) {
            const newWidth = parseInt(widthInput.value) || 400;
            const newHeight = parseInt(heightInput.value) || 400;
            const centerX = this.atomSpawner.zone.x + this.atomSpawner.zone.width / 2;
            const centerY = this.atomSpawner.zone.y + this.atomSpawner.zone.height / 2;

            this.atomSpawner.setZone(
                centerX - newWidth / 2,
                centerY - newHeight / 2,
                newWidth,
                newHeight
            );
        }

        this.viewer.render();
        console.log('Spawner config applied:', {
            interval: this.atomSpawner.tickInterval,
            pool: this.atomSpawner.atomPool,
            zone: this.atomSpawner.zone
        });
    }
}

// Create global app instance
window.cellApp = new App();

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    window.cellApp.init().catch(console.error);
});



    </script>
</body>
</html>